$(document).ready(function () {

    // Запрещение ввода символов, отличных от латиницы, цифр, пробела и подчёркивания
    $("#id_model_name").on("input", function () {
        let regex = /^[A-Za-z0-9_ ]{3,80}$/;
        //let regex = /^[A-Za-z0-9_ ]+$/;
        let value = $(this).val();

        if (!regex.test(value)) {
            $(this).val(value.replace(/[^A-Za-z0-9_ ]/g, "")); // Удаляем запрещённые символы
        }
    });

    // Проверка при переходе фокуса из поля ввода
    $("#id_model_name").on("blur", function () {
        $(this).valid();
    });

    // Кастомный метод для валидации regex
    $.validator.addMethod("regex", function (value, element, regexp) {
        let re = new RegExp(regexp);
        return this.optional(element) || re.test(value);
    }, "Only letters, numbers, spaces, and underscores allowed.");




    // Инициализация валидации формы
    $("#id_mainForm").validate({
        rules: {
            modelname: {
                required: true,
                minlength: 3,
                maxlength: 80,
                regex: "^[A-Za-z0-9_ ]+$"  // Используем кастомное правило
            }
        },
        messages: {
            modelname: {
                required: "This field is required",
                minlength: "Minimum 3 characters",
                maxlength: "Maximum 80 characters",
                regex: "Only letters, numbers, spaces, and underscores allowed."  // Изменили с pattern на regex
            }
        },
        errorPlacement: function (error, element) {
            console.log("Ошибка валидации:", error.text());  // Логируем ошибку
            $("#id_lb_model_name_error_message").text(error.text()).show();
        },
        success: function () {
            $("#id_lb_model_name_error_message").hide();  // Убираем сообщение при успехе
        }
    });

    // Блокируем отправку, если форма не валидна
    $("#id_mainForm").on("submit", function (e) {
        if (!$(this).valid()) {
            e.preventDefault();  // Останавливаем отправку формы
            console.log("⛔ Ошибка валидации, форма не отправляется.");
        }
    });
});

export var Constants = {

    true : "true",
    false: "false",
    method_refresh_premodel: "refresh_premodel",
    method_start_refresh_premodel: "start_refresh_premodel",
    method_read_result_refresh_premodel: "read_result_refresh_premodel",
    method_make_model: "make_model",
    method_start_make_model: "start_make_model",
    method_read_model_parts: "read_model_parts",
    method_delete_model_parts: "delete_model_parts",
    method_read_screenshot: "ReadScreenshot",
    method_read_model_from_server: "ReadModelFromServer",
    method_check_file_exist_on_server: "CheckFileExistOnServer",
    method_read_progress_value: "read_progress_value",
    method_read_model_parts_zip_file_from_api: "read_model_parts_zip_file_from_api",
    method_save_model_parts_zip_file: "SaveModelPartsZipFile",
    method_read_model_parts_zip_file: "ReadModelPartsZipFile",
    method_save_model_part: "SaveModelPart",
    is_make_order: "is_make_order",
    word_client_id: "client_id",
    word_task_id: "task_id",
    word_task_id: "task_id",
    path_result_file: "path_result_file",
    parameter_folder_for_model_parts_zip: "folder_for_model_parts_zip",
    downloaded_filename: "jb_puzzle_parts.zip", // суффикс файла при выгрузке заказа
    file_model_ext: ".stl",
    file_model_screenshot: ".scr",
    file_model_prev: ".prev",
    file_model_graph: ".png",
    file_model_zip: ".zip",
    data_delimiter: "_@$@_",
    order_jb_puzzle: "Order JB Puzzle", // префикс zip-файла заказа

    //Number_of_blocks: 6,
    //SeparatorNameSet_from_data: "_@&@_",
    //Separator_between_items: "_&&_",
    //Separator_from_value: "_@@_",
    //Separator_after_hash: "_$$_",
    //Separator_between_dir: "\\",
    //Directory_DataFiles: "DataFiles",
    //Directory_OutputAudio: "OutputAudio",
    //Separator_in_payment_label: "_@_",

    //true: "true",
    //false: "false",

    //t1c: ".t1c", // Выход - файл для перевода с двухколоночной таблицей с текстом в одной левой колонке  
    //t2c: ".t2c", // Выход - файл с серилизованным объектом - набором таблиц c переводом - по словам, предложениям, абзацам, страницам
    //mp3: ".mp3",  // Выход - аудиофайл со сгенертрованным звуком на основании таблицы текста

    //Membership_page_Login: "LoginUser",
    //Membership_page_Create: "RegisterUser",
    //Membership_page_Recovery: "PasswRecovery",
    //initial_playbackset_name: "initial_playback_set",
    //wwwroot_dir: "wwwroot/",
    //text_snippet_filename: "snippet.txt",
    //audio_snippet_filename: "audio_snippet.mp3",
    //all_texts_filename: "all_texts.txt",
    //message_count_per_day: 5,
    //feedback_data_cooki_name: "feedback_data",
    div_dialog_message: $("#id_div_dialog_message"),
    //div_dialog_question: $("#id_div_dialog_question"),
    //tooltip_delay_ms: 500,
    //grid_tooltip_delay_ms: 1500,
    //timeout_file_saved_dialog_ms: 1000,
    timeout_dialog_message_ms: 1500, //900
    //path_initial_playback_set: "wwwroot/datafiles/system_files/initial_playback_set.pbs", //06062023
    //is_debug_mode: false, //26112023 true,
    //lang_ru: "ru",
    //lang_en: "en",
    //initial_topic: "id_tt_choose_text_topic"
    path_file_initial_premodel: "wwwroot/datafiles\\initial_model\\models\\initial_model",
    initial_load: "initial_load",
    path_model_parts_folder: "",
    //calc_jbmodel_server_url: "https://localhost:7095/CalcJBModel" //?method="



    spline_line_color: 0xff0000, // цвет линии сплайна

    //background_color: 0xc3c3c3, // цвет фона сцены
    background_color: 0xffffff, // цвет фона сцены

    color_shape_countour: "#0000ff", //0x0000ff,// 0x0000ff, // цвет контура фигур
    color_shape_countour_str: "0000ff",// 0x0000ff, // цвет контура фигур
    line_width_shape_contour: 4, // ширина линий контура фигур


    shape_line_color: 0xff00ff, // цвет линий разреза
    cell_text_color: 0x0000ff, // 0x9966FF // 0x0000ff // цвет текста
    cell_text_size: 2, //2 // Размер текста ячеек
    texts_array_start_dimension: 5, // начальный размер массива текстовых меток деталей
    spline_segments_amount_max: 15 // максимальное количество сегментов в каждом из создаваемых сплайнах

};


export var Wide_model_types = {
    common: "common",
    user: "user"
};
import * as THREE from 'three';

import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

//import { GUI } from '../three/addons/libs/lil-gui.module.min.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

import { LineMaterial } from 'three/addons/lines/LineMaterial.js';//04122024

import { STLLoader } from 'three/addons/loaders/STLLoader.js';//20082024

import { FontLoader } from 'three/addons/loaders/FontLoader.js';
//import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


//////import { Line2 } from 'three/addons/lines/Line2.js';
//import { CubeGeometry } from 'three/addons/CubeGeometry.js';

import { Constants } from './my_common_const.js';

import { CommonFunc } from './my_common_func.js';

//import {
//    gc_id_prefix_up,
//    gc_id_prefix_lateral,
//    gc_id_prefix_end
// } from './my_start.js';




//import { ProgressDialog } from './my_progress_dialog.js';
import { ProgressBar } from './my_progress_bar.js';

import {
    struc_gabarits,
    struc_segment_transform_data,
    cv_spline_name_prefix,
    cv_segment_name_prefix,

    typ_color_data,
    typ_side_data,
    typ_mesh_colors,
    type_rotate_mode,
    typ_sides_data,
    typ_parameters

} from "./my_common_types.js";

import { Shapes } from "./my_shapes.js";
import { Splines } from "./my_splines.js";
import { Segments } from "./my_segments.js";
import { Rectangle } from './my_rectangle.js';
import { EndShape } from './my_end_shape.js';
import { Tab_orders } from './my_tab_orders.js';

import { GridSelectModels } from './my_grid_select_models.js';


//============================================================================================

export const gc_id_prefix_up = "up";
export const gc_id_prefix_lateral = "lateral";
export const gc_id_prefix_end = "end";
export const gc_id_prefix_orders = "orders";


//30102024 {
const cv_name_group_contours = "group_contours";
const cv_name_group_color_mesh = "group_color_mesh";
const cv_name_group_end_shape = "group_end_shape";
const cv_name_group_end_cells_contours = "group_end_cells_contours";
const cv_name_end_group_cells_mesh = "end_group_cells_mesh";
//30102024 }

export var go_up_side_shape_generator = null;
export var go_lateral_side_shape_generator = null;
export var go_end_side_shape_generator = null;
export var go_tab_orders = null;


var go_active_side_shape_generator = null;
var go_passive_side_shape_generator = null;


start(); // точка запуска javascript


function start() {

    try {

        $("#id_tab_sides").tabs(
            {
                activate: on_tab_side_activate,
                heightStyle: "auto" //"fill"
            }
        );

        go_up_side_shape_generator = start_side_shape_generator(gc_id_prefix_up, gc_id_prefix_lateral);
        go_active_side_shape_generator = go_up_side_shape_generator;
        go_active_side_shape_generator.init_event_handlers();

        //go_lateral_side_shape_generator = start_side_shape_generator(gc_id_prefix_lateral, gc_id_prefix_up);
        //go_passive_side_shape_generator = go_lateral_side_shape_generator;
        //go_passive_side_shape_generator.init_event_handlers();
        //////////01092024 }



        ////$("#id_tab_sides").tabs(
        ////    {
        ////        activate: on_tab_side_activate,
        ////        heightStyle: "auto" //"fill"
        ////    }
        ////);


        //06122024 $("#id_tab_sides").tabs("option", "active", 2);//30112024  активация третьей закладки

        $("#id_tab_sides").tabs("option", "active", 1);// активация второй закладки (lateral side) (для срабатывания события activate
        // и формирования на второй закладке фигуры и данных)

        $("#id_tab_sides").tabs("option", "active", 2);////06122024   активация третьей закладки (end side)

        $("#id_tab_sides").tabs("option", "active", 3);//   активация четвёртой закладки (orders)


        $("#id_tab_sides").tabs("option", "active", 0);// активация первой закладки (up side)


        //26112024 начальное обновление модели (сейчас работает загрузка начальной модели) go_up_side_shape_generator.model_params_changed = true;

    }

    catch (e) {

        alert('error start: ' + e.stack);

    }
}



//--------------------------------------------------------------------------
function on_tab_side_activate(event, ui) {

    let lv_name_tab = ui.newPanel[0].id;

    switch (lv_name_tab) {

        case "tab-1":
            //////17032025 {
            ////if (!go_end_side_shape_generator) {
            ////    go_end_side_shape_generator = start_side_shape_generator(gc_id_prefix_end, gc_id_prefix_up);//12062024
            ////}
            //////17032025 }



            go_active_side_shape_generator = go_up_side_shape_generator;
            go_passive_side_shape_generator = go_lateral_side_shape_generator;


            //////17032025 {
            ////go_end_side_shape_generator.end_shape.draw_cells_contours_and_texts();
            ////go_end_side_shape_generator.end_shape.refresh_end_shapes();
            //////17032025 }


            break;

        case "tab-2":

            //////17032025 {
            ////if (!go_end_side_shape_generator) {
            ////    go_end_side_shape_generator = start_side_shape_generator(gc_id_prefix_end, gc_id_prefix_up);//12062024
            ////}
            //////17032025 }


            if (!go_lateral_side_shape_generator) {
                go_lateral_side_shape_generator = start_side_shape_generator(gc_id_prefix_lateral, gc_id_prefix_up);//12062024
            }

            go_active_side_shape_generator = go_lateral_side_shape_generator;
            go_passive_side_shape_generator = go_up_side_shape_generator;


            //////17032025 {

            ////go_end_side_shape_generator.end_shape.draw_cells_contours_and_texts();
            ////go_end_side_shape_generator.end_shape.refresh_end_shapes();
            //////17032025 }

            break;

        case "tab-3":
            if (!go_end_side_shape_generator) {
                go_end_side_shape_generator = start_side_shape_generator(gc_id_prefix_end, gc_id_prefix_up);//12062024
            }

            go_active_side_shape_generator = go_end_side_shape_generator;
            go_passive_side_shape_generator = go_up_side_shape_generator;

            go_end_side_shape_generator.end_shape.redraw_end_shape(
                null,         //   po_main,
                null, null,   //   pv_added_spline_num, pv_deleted_spline_num,       
                null, null    //   po_is_use_data, po_sides_data       
            );

            go_end_side_shape_generator.end_shape.draw_cells_contours_and_texts();
            go_end_side_shape_generator.end_shape.refresh_end_shapes();
            break;

        case "tab-4":

            go_active_side_shape_generator = null;
            go_passive_side_shape_generator = null;

            go_up_side_shape_generator.reset_event_handlers(go_up_side_shape_generator);
            go_lateral_side_shape_generator.reset_event_handlers(go_lateral_side_shape_generator);;
            go_end_side_shape_generator.reset_event_handlers(go_end_side_shape_generator);

            if (!go_tab_orders) //12062024
            {
                go_tab_orders = new Tab_orders();
            }


            return;



            break;
    }


    go_active_side_shape_generator.init_event_handlers();

}


//--------------------------------------------------------------------------
export function get_active_side_shape_generator() {
    return go_active_side_shape_generator;
}

//--------------------------------------------------------------------------
export function get_passive_side_shape_generator() {
    return go_passive_side_shape_generator;
}

//--------------------------------------------------------------------------
function get_side_shape_generator_by_prefix(pv_prefix) {

    let lo_object;

    switch (pv_prefix) {

        case gc_id_prefix_up:
            lo_object = go_up_side_shape_generator;
            break;

        case gc_id_prefix_lateral:
            lo_object = go_lateral_side_shape_generator;
            break;

        case gc_id_prefix_end:
            lo_object = go_end_side_shape_generator;
            break;

        case gc_id_prefix_end:
            lo_object = go_end_side_shape_generator;
            break;

    }
    go_end_side_shape_generator

    return lo_object;
}



//============================================================================================


var go_sides_data = new typ_sides_data();


//--------------------------------------------------------------------------------

function start_side_shape_generator(pv_active_id_prefix, pv_passive_id_prefix) {

    return new Shape_generator(pv_active_id_prefix, pv_passive_id_prefix);
};




//==============================================================================================================

//==============================================================================================================

// Class Shape_generator
export function Shape_generator(pv_active_id_prefix, pv_passive_id_prefix) {


    this.client_id = null;


    this.id_common_shg_container = "id_shape";// "id_tab_sides";// "id_center";// "id_shg_common";// "id_shape"; //"id_shape_generator_container";//  "id_shape_generator_container";// ;
    this.id_side_shape = "id_shape"; //"id_shape_generator_container";//  "id_shape_generator_container";// ;
    this.id_side_shape_mod = "id_div_visual_model"; //25082024


    this.id_gui = "id_shg_right_top";

    // Свойства
    this.my_prefix = pv_active_id_prefix;
    this.id_prefix = "#" + pv_active_id_prefix + "_";
    this.id_prefix_wo_sharp = pv_active_id_prefix + "_";

    this.passive_id_prefix = "#" + pv_passive_id_prefix + "_";
    this.passive_id_prefix_wo_sharp = pv_passive_id_prefix + "_";

    this.container = document.getElementById(this.id_prefix_wo_sharp + this.id_side_shape);

    this.is_ask_about_save_file = false;
    this.is_model_changed = false;





    this.camera;//  = go_camera;
    this.scene;//  = go_scene;


    this.aspect;
    this.rectangle;


    let lv_id_side_shape = this.id_prefix + this.id_side_shape;
    let lv_id_side_shape_mod = this.id_prefix + this.id_side_shape_mod;

    this.common_prev_width = $(lv_id_side_shape).width();
    this.common_prev_height = $(lv_id_side_shape).height();

    this.prev_width_mod = $(lv_id_side_shape_mod).width();
    this.prev_height_mod = $(lv_id_side_shape_mod).height();


    this.offset = $(lv_id_side_shape).offset();

    this.prev_top = this.offset.top;
    this.prev_left = this.offset.left;

    let lv_$shape_mod = $(lv_id_side_shape_mod);

    this.offset_mod = $(lv_$shape_mod).offset();
    this.prev_top_mod = this.offset_mod.top;
    this.prev_left_mod = this.offset_mod.left;


    let offsetHeight = lv_$shape_mod[0].offsetHeight;
    let offsetLeft = lv_$shape_mod[0].offsetLeft;
    this.prev_offsetTop_mod = lv_$shape_mod[0].offsetTop;
    let offsetWidth = lv_$shape_mod[0].offsetWidth;

    this.button_down = false;
    this.draggableObject = undefined;
    this.delta_rect_drag_x = null;
    this.delta_rect_drag_y = null;
    this.common_func = null;



    this.shapes = null;
    this.splines = null;
    this.segments = null;
    this.end_shape = null; // торцевая фигура

    this.segment_gabarits = null;
    this.segment_transform_data = null;
    //18072024 this.was_draggable = false;

    this.controls = null;
    this.gui = null;

    this.group_contours = null;
    this.group_color_mesh = null;

    this.is_gragging = false;

    this.params = {

        container_width: this.container.clientWidth,
        container_height: this.container.clientHeight,
        shape_width_beg: 70, //50,
        shape_width: 70, //50,
        shape_height_beg: 100,
        shape_height: 100,
        shape_amount_curves: 3,
        spline_amount_segments: 3, //5, //11022025 3,
        ajust_curves_by_shape: true,
        ajust_shape_by_curves: false,
        distance_between_curves_in_percent_of_width: 10,
        distance_bt_curves: 30,

        //20032025 {
        ////is_space_adjust: $(this.id_prefix + "id_chb_space_adjust")[0].checked,
        ////is_curve_width_adjust: $(this.id_prefix + "id_chb_curve_width_adjust")[0].checked,
        //20032025 }

        is_show_text_labels: $(this.id_prefix + "id_chb_show_text_labels")[0].checked,

        color: '#0000ff'
    };

    this.is_big_window = false;

    this.resolution = null; //30072024

    this.container_mod; //= document.getElementById(this.id_prefix_wo_sharp + this.id_side_shape_mod);//20062024
    this.camera_mod;
    this.scene_mod;


    this.material_mod = new THREE.MeshPhongMaterial({ color: 0xff5533, specular: 0x111111, shininess: 200 });

    this.group_parts_mod;

    this.refreshModelInterval = 1000; // 1 //2 sec
    this.model_params_changed = false;
    this.is_building_model = false;

    this.model_prefix_filename = ""; // префикс имени файлов загружаемых деталей 
    this.model_numparts = 0; // всего загружаемых деталей модели
    this.num_loaded_model_parts = 0; //число загруженных деталей модели
    this.model_parts_positions = []; // new Array();
    this.rotate_status = 0; // режим вращения модели

    this.progress_bar = null;
    this.is_shape_gragging = false;
    this.textfont = null; // шрифт для текстовых объектов
    this.text_material = null; // материал для текстовых объектов

    this.spline_segments_amount = this.params.spline_amount_segments; // количество сегментов в каждом создаваемом сплайне
    //--------------------------------------------------------------------------------


    if (typeof this.create_shape_generator != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------



        //----------------------------------------------------------

        Shape_generator.prototype.create_shape_generator = function (/*pv_prefix*/ /*30112024*/) {

            this.init_containers_and_controls(/*pv_prefix *//*30112024*/);
            this.init_three_elements(/*pv_prefix *//*30112024*/);
            ////////////////this.animate_mod();//04122024


            // Загрузка данных начальной премодели
            /// 26012025 this.load_initial_model(/*pv_prefix*/ /*30112024*/);



            /////// 30112024 setInterval(this.onPassInterval, this.refreshModelInterval, this);


        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.add_lights_for_model = function (po_scene) {

            try {

                let lo_spotLight;

                let lv_intensity = 0.7;


                lo_spotLight = new THREE.SpotLight(0xffffff);
                lo_spotLight.position.set(0, 100, 100);
                lo_spotLight.intensity = lv_intensity;
                po_scene.add(lo_spotLight);

                //lo_spotLight = new THREE.SpotLight(0xffffff);
                //lo_spotLight.position.set(100, 100, 0);
                //po_scene.add(lo_spotLight);

                //lo_spotLight = new THREE.SpotLight(0xffffff);
                //lo_spotLight.position.set(0, 100, -100);
                //po_scene.add(lo_spotLight);

                lo_spotLight = new THREE.PointLight(0xffffff);
                lo_spotLight.position.set(-100, 100, 0);
                lo_spotLight.intensity = lv_intensity;
                po_scene.add(lo_spotLight);



                //lo_spotLight = new THREE.SpotLight(0xffffff);
                //lo_spotLight.position.set(0, -100, 100);
                //po_scene.add(lo_spotLight);

                lo_spotLight = new THREE.SpotLight(0xffffff);
                lo_spotLight.position.set(100, -100, 0);
                lo_spotLight.intensity = lv_intensity;
                po_scene.add(lo_spotLight);

                lo_spotLight = new THREE.PointLight(0xffffff);
                lo_spotLight.position.set(0, -100, -100);
                lo_spotLight.intensity = lv_intensity;
                po_scene.add(lo_spotLight);

                //lo_spotLight = new THREE.SpotLight(0xffffff);
                //lo_spotLight.position.set(-100, -100, 0);
                //po_scene.add(lo_spotLight);



                //const geometry = new THREE.SphereGeometry(15);
                //const material = new THREE.MeshBasicMaterial({ color: 0xff000f });

                //let sphere = null;

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 0;
                //sphere.position.y = 100;
                //sphere.position.z = 100;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 100;
                //sphere.position.y = 100;
                //sphere.position.z = 0;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 0;
                //sphere.position.y = 100;
                //sphere.position.z = -100;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = -100;
                //sphere.position.y = 100;
                //sphere.position.z = 0;
                //po_scene.add(sphere);



                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 0;
                //sphere.position.y = -80;
                //sphere.position.z = 100;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 100;
                //sphere.position.y = -80;
                //sphere.position.z = 0;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = 0;
                //sphere.position.y = -80;
                //sphere.position.z = -100;
                //po_scene.add(sphere);

                //sphere = new THREE.Mesh(geometry, material);
                //sphere.position.x = -100;
                //sphere.position.y = -80;
                //sphere.position.z = 0;
                //po_scene.add(sphere);

            }

            catch (e) {

                alert('error add_lights_for_model: ' + e.stack);

            }
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.adjust_splines_by_shape_in_side = function (po_side, pv_value) {


            //po_side.params.shape_height = pv_value;

            //05112024 let lv_scale = pv_value / po_side.params.shape_height_beg;
            //05112024 let lv_scale = pv_value / po_side.params.shape_height;//05112024

            let lv_scale = pv_value / po_side.rectangle.shape_height;//05112024


            po_side.rectangle.shape.scale.y = lv_scale;

            //13122024 po_side.render();


            po_side.segment_transform_data = po_side.segments.get_segment_transform_data(
                /* po_side.segment_gabarits, 02112024 */
                //13022025 po_side.params.ajust_curves_by_shape);
                po_side.params.ajust_curves_by_shape, this.params.spline_amount_segments);//13022025


            if (po_side.params.is_space_adjust) {
                po_side.shapes.adjust_splines_by_external_shape(pv_value);
            }

            po_side.render();//13122024 

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.animate = function () {

            //requestAnimationFrame(this.animate);
            //this.scene.children.forEach(obj => obj.lookAt(this.camera.position)); // Все объекты смотрят на камеру
            //this.controls.update();
            //this.renderer.render(this.scene, this.camera);

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.animate_mod = function () {

            //return;//15122024

            let lo_active_side = get_active_side_shape_generator();

            ////07012025 {
            //if (!lo_active_side) {
            //    return;
            //}
            ////07012025 }


            let lv_slider_value = 0;
            //let lv_delta_slider_value = 0;

            if (lo_active_side) {

                lv_slider_value = $(lo_active_side.id_prefix + "id_dist_part_slider").slider('value');

                //lv_delta_slider_value = lv_slider_value - lo_active_side.slider_value_prev;
                //lo_active_side.common_func.move_details_from_to_center(lo_active_side.group_parts_mod, lv_delta_slider_value);

                //lv_delta_slider_value = lv_slider_value - lo_active_side.slider_value_prev;
                lo_active_side.common_func.move_details_from_to_center(lo_active_side.group_parts_mod, lv_slider_value);


                //lo_active_side.slider_value_prev = lv_slider_value;

                //requestAnimationFrame(lo_active_side.animate_mod);




                //07012025 {
                if (!lo_active_side) {
                    return;
                }
                //07012025 }

                setTimeout(function () {
                    //07012025 {
                    if (!lo_active_side) {
                        return;
                    }
                    //07012025 }

                    requestAnimationFrame(lo_active_side.animate_mod);
                    lo_active_side.render_mod();

                }, 200); // 100);

            }
            else {

                if (this) { //08012025

                    lv_slider_value = $(this.id_prefix + "id_dist_part_slider").slider('value');
                    //lv_delta_slider_value = lv_slider_value - this.slider_value_prev;

                    //this.common_func.move_details_from_to_center(this.group_parts_mod, lv_delta_slider_value);
                    this.common_func.move_details_from_to_center(this.group_parts_mod, lv_slider_value);


                    setTimeout(function () {
                        requestAnimationFrame(this.animate_mod);
                        this.render_mod();

                    }, 200); // 100);

                }
            }


        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.but_insert_segment_onclick = function () {

            // добавить к сплайну сегмент перед выделенным
            let lo_active_side = get_active_side_shape_generator();

            try {

                lo_active_side.shapes.make_insert_segments_before_selected_segments();//24022025

                lo_active_side.shapes.adjust_splines_by_external_shape();

                lo_active_side.render();

            }

            catch (e) {

                alert('error but_insert_segment_onclick: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.but_delete_segment_onclick = function () {

            // удалить из сплайна выделенный сегмент
            let lo_active_side = get_active_side_shape_generator();
            try {

                lo_active_side.shapes.make_delete_selected_segments();//24022025

                lo_active_side.shapes.adjust_splines_by_external_shape();

                lo_active_side.render();


            }

            catch (e) {

                alert('error but_delete_segment_onclick: ' + e.stack);

            }
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.but_mirror_onclick = function () {

            // Сделать зеркальное отражение выделенных сегментов
            let lo_active_side = get_active_side_shape_generator();
            lo_active_side.shapes.make_mirror_selected_segments();

            lo_active_side.shapes.adjust_splines_by_external_shape();

            lo_active_side.render();

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.but_make_random_onclick = function () {

            // Сделать для выделенных сегментов случайные размеры
            let lo_active_side = get_active_side_shape_generator();
            lo_active_side.shapes.make_random_selected_segments();

            lo_active_side.shapes.adjust_splines_by_external_shape();

            lo_active_side.render();

        }

        //------------------------------------------------------------------------------------------
        Shape_generator.prototype.clear_model_data = function (po_data) {

            try {

                //return;


                let lar_no_delete = [];

                if (this.shapes) {
                    if (this.shapes.scene) {
                        lar_no_delete = ["AmbientLight", "PointLight", "SpotLight", "PerspectiveCamera"];//, "Group"];// "Mesh", 
                        this.common_func.clearScene(this.shapes.scene, lar_no_delete);
                    }
                }

                this.shapes = null;
                this.splines = null;
                this.segments = null;
                //this.end_shape = null;

                this.segment_gabarits = null;
                this.segment_transform_data = null;
                //this.controls = null;
                //this.gui = null;



                this.group_contours = null;
                this.group_color_mesh = null;

                this.is_gragging = false;

                this.common_func.clear_group_childrens(this.group_contours);
                this.common_func.clear_group_childrens(this.group_color_mesh);
                this.common_func.clear_group_childrens(this.group_end_shape);
                this.common_func.clear_group_childrens(this.group_end_cells_contours);
                this.common_func.clear_group_childrens(this.end_group_cells_mesh);
                this.common_func.clear_group_childrens(this.group_parts_mod);

                this.is_big_window = false;


                //return;


                //this.resolution = null;

                //this.container_mod;
                //this.camera_mod;
                //this.scene_mod;


                //this.material_mod = new THREE.MeshPhongMaterial({ color: 0xff5533, specular: 0x111111, shininess: 200 });

                //return;


                //this.group_parts_mod = null;


                //this.refreshModelInterval = 1000;
                this.model_params_changed = false;
                this.is_building_model = false;





                this.model_prefix_filename = ""; // префикс имени файлов загружаемых деталей 
                this.model_numparts = 0; // всего загружаемых деталей модели
                this.num_loaded_model_parts = 0; //число загруженных деталей модели
                this.model_parts_positions = []; // new Array();
                this.rotate_status = 0; // режим вращения модели
                //this.progress_bar = null;
                this.is_shape_gragging = false;

            }

            catch (e) {

                alert('error clear_model_data: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.clear_shape_objects = function (po_side) {

            try {


                //this.common_func.clear_group_childrens(po_side.main_curves_group);
                //this.common_func.clear_group_childrens(po_side.group_contours);
                //this.common_func.clear_group_childrens(po_side.group_color_mesh);
                //this.common_func.clear_group_childrens(po_side.group_rect);

                if (this.shapes) {

                    this.shapes.shape_amount_curves = 0;// po_params.shape_amount_curves;
                    //this.spline_amount_segments = po_params.spline_amount_segments;

                    this.shapes.shape_width = 0;// po_params.shape_width;
                    this.shapes.shape_height = 0; // po_params.shape_height;

                    this.shapes.ajust_shape_by_curves = false;// po_params.ajust_shape_by_curves;
                    this.shapes.ajust_curves_by_shape = false;// po_params.ajust_curves_by_shape;

                    this.shapes.distance_between_curves_in_percent_of_width = 0;// po_params.distance_between_curves_in_percent_of_width;
                    this.shapes.distance_between_curves = 0;// po_params.distance_bt_curves;

                    this.shapes.group_rect = null;
                    this.shapes.segment_gabarits = null; // new struc_gabarits();
                    this.shapes.segment_transform_data = null; // new struc_segment_transform_data();
                    this.shapes.ar_splines = [];// Список group - сплайнов кривых в сцене
                    this.shapes.ar_splines_nodes = [];// Список узлов всех сплайнов
                    this.shapes.ar_selected_segments = []; // список выбранных сегментов 
                    //11042024 this.shapes.height_koef_previous = 0; // 1;
                    this.shapes.ar_shapes_colors = []; // список объектов со сплайнами и цветами фигур, упорядоченных слева направо

                }





                if (po_side) {
                    po_side.segment_transform_data = null;
                    po_side.segment_gabarits = null;
                    po_side.segments = null;
                    po_side.splines = null;
                    po_side.shapes = null;
                }



                let lar_no_delete = ["AmbientLight", "PointLight", "SpotLight", "Mesh", "Group"];// /*, "Group"*/14102024
                this.common_func.clearScene(po_side.scene, lar_no_delete);


                //return;

                if (this.rectangle) {
                    this.rectangle.shape.scale.y = 1;
                }
            }

            catch (e) {

                alert('error clear_shape_objects: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.delete_on_server_model_parts = function () {

            try {

                let lo_active_side = get_active_side_shape_generator(); //04102024

                // Посылка команды на удаление промежуточных файлов на сервере

                let lv_url = "https://localhost:7095/CalcJBModel?method=" + Constants.method_delete_model_parts +
                    "&filename=" + lo_active_side.model_prefix_filename
                    + "&chdata=" + Math.random().toString(); // 23112024
                ;

                get_delete_on_server_model_parts(lv_url)
                async function get_delete_on_server_model_parts(pv_url) {
                    //--------------------------------------------------
                    await $.get(pv_url);
                }


                lo_active_side.animate_mod();

                let lv_is_before = false;
                lo_active_side.do_before_after_model_request(lv_is_before, true);




            }

            catch (e) {

                alert('error delete_on_server_model_parts: ' + e.stack);

            }

        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.do_before_after_model_request = function (pv_is_before, pv_is_build_model) {


            //26012025
            ////try {

            ////    let lo_active_side = get_active_side_shape_generator();
            ////    let lo_passive_side = get_passive_side_shape_generator();

            ////    if (pv_is_before) {

            ////        $('#up_id_div_visual_model').css('opacity', 0.3);// прозрачность контента
            ////        $('#lateral_id_div_visual_model').css('opacity', 0.3);// прозрачность контента

            ////        $('#up_id_loading_indicator').show();// индикация ожидани
            ////        $('#lateral_id_loading_indicator').show();// индикация ожидания
            ////        $('#up_id_loading_indicator').css('opacity', 1);// индикация ожидания
            ////        $('#lateral_id_loading_indicator').css('opacity', 1);// индикация ожидания


            ////        lo_active_side.is_building_model = true;
            ////        lo_passive_side.is_building_model = true;

            ////        lo_active_side.rotate_status = type_rotate_mode.stop; // None; // выключить вращение модели
            ////        lo_active_side.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
            ////        $(lo_active_side.id_prefix + 'id_dist_part_slider').slider('value', 0);

            ////        lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);
            ////        lo_active_side.controls_mod.reset();


            ////        lo_active_side.progress_bar.div_progressbar.fadeIn();//26112024



            ////        //24112024 {
            ////        lo_passive_side.rotate_status = type_rotate_mode.stop; // None; // выключить вращение модели
            ////        lo_passive_side.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
            ////        $(lo_passive_side.id_prefix + 'id_dist_part_slider').slider('value', 0);

            ////        lo_passive_side.common_func.clear_group_childrens(lo_passive_side.group_parts_mod);
            ////        lo_passive_side.controls_mod.reset();
            ////        //24112024 }
            ////    }

            ////    else {

            ////        // after

            ////        /////lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);

            ////        $('#up_id_div_visual_model').css('opacity', 1);// прозрачность контента
            ////        $('#lateral_id_div_visual_model').css('opacity', 1);// прозрачность контента

            ////        $('#up_id_loading_indicator').hide();// прекращение индикации ожидания
            ////        $('#lateral_id_loading_indicator').hide();// прекращение индикации ожидания


            ////        lo_active_side.model_params_changed = false;
            ////        lo_passive_side.model_params_changed = false;
            ////        lo_active_side.is_building_model = false;
            ////        lo_passive_side.is_building_model = false;


            ////        if (pv_is_build_model) {
            ////            lo_active_side.set_visible_rotate_controls(true); // сделать видимым контрол  - слайд расстояния между деталями
            ////            lo_active_side.rotate_status = type_rotate_mode.clockwise; // включить вращение модели
            ////        }
            ////        else {
            ////            lo_active_side.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
            ////            lo_active_side.rotate_status = type_rotate_mode.stop; // выключить вращение модели
            ////        }

            ////        lo_active_side.common_func.set_group_to_center(lo_active_side.group_parts_mod);

            ////        if (lo_active_side.progress_bar.div_progressbar) {
            ////            lo_active_side.progress_bar.div_progressbar.fadeOut();//26112024
            ////        }

            ////        //24112024 {

            ////        if (pv_is_build_model) {
            ////            lo_passive_side.set_visible_rotate_controls(true); // сделать видимым контрол  - слайд расстояния между деталями
            ////            lo_passive_side.rotate_status = type_rotate_mode.clockwise; // включить вращение модели
            ////        }
            ////        else {
            ////            lo_passive_side.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
            ////            lo_passive_side.rotate_status = type_rotate_mode.stop; // выключить вращение модели
            ////        }

            ////        lo_passive_side.common_func.set_group_to_center(lo_passive_side.group_parts_mod);
            ////        //24112024 }



            ////    }
            ////}







            try {

                let lo_active_side = get_active_side_shape_generator();
                //let lo_passive_side = get_passive_side_shape_generator();

                if (pv_is_before) {

                    $('#up_id_div_visual_model').css('opacity', 0.3);// прозрачность контента
                    $('#lateral_id_div_visual_model').css('opacity', 0.3);// прозрачность контента

                    $('#up_id_loading_indicator').show();// индикация ожидани
                    $('#lateral_id_loading_indicator').show();// индикация ожидания
                    $('#up_id_loading_indicator').css('opacity', 1);// индикация ожидания
                    $('#lateral_id_loading_indicator').css('opacity', 1);// индикация ожидания

                    //31012025 {
                    $('#up_id_id_div_progressbar').show();// индикация ожидани
                    $('#lateral_id_div_progressbar').show();// индикация ожидания
                    //31012025 }



                    go_up_side_shape_generator.is_building_model = true;
                    go_lateral_side_shape_generator.is_building_model = true;

                    go_up_side_shape_generator.rotate_status = type_rotate_mode.stop; // None; // выключить вращение модели
                    go_up_side_shape_generator.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
                    $(go_up_side_shape_generator.id_prefix + 'id_dist_part_slider').slider('value', 0);

                    go_up_side_shape_generator.common_func.clear_group_childrens(go_up_side_shape_generator.group_parts_mod);
                    go_up_side_shape_generator.controls_mod.reset();

                    if (lo_active_side.progress_bar) {
                        if (lo_active_side.progress_bar.div_progressbar) {
                            lo_active_side.progress_bar.div_progressbar.fadeIn();//26112024
                        }
                    }


                    //24112024 {
                    go_lateral_side_shape_generator.rotate_status = type_rotate_mode.stop; // None; // выключить вращение модели
                    go_lateral_side_shape_generator.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
                    $(go_lateral_side_shape_generator.id_prefix + 'id_dist_part_slider').slider('value', 0);

                    go_lateral_side_shape_generator.common_func.clear_group_childrens(go_lateral_side_shape_generator.group_parts_mod);
                    go_lateral_side_shape_generator.controls_mod.reset();
                    //24112024 }
                }

                else {

                    // after

                    /////lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);

                    $('#up_id_div_visual_model').css('opacity', 1);// прозрачность контента
                    $('#lateral_id_div_visual_model').css('opacity', 1);// прозрачность контента

                    $('#up_id_loading_indicator').hide();// прекращение индикации ожидания
                    $('#lateral_id_loading_indicator').hide();// прекращение индикации ожидания

                    //31012025 {
                    $('#up_id_id_div_progressbar').hide();// индикация ожидани
                    $('#lateral_id_div_progressbar').hide();// индикация ожидания
                    //31012025 }

                    go_up_side_shape_generator.model_params_changed = false;
                    go_up_side_shape_generator.model_params_changed = false;
                    go_up_side_shape_generator.is_building_model = false;
                    go_lateral_side_shape_generator.is_building_model = false;


                    if (pv_is_build_model) {
                        go_up_side_shape_generator.set_visible_rotate_controls(true); // сделать видимым контрол  - слайд расстояния между деталями
                        go_up_side_shape_generator.rotate_status = type_rotate_mode.clockwise; // включить вращение модели
                    }
                    else {
                        go_up_side_shape_generator.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
                        go_up_side_shape_generator.rotate_status = type_rotate_mode.stop; // выключить вращение модели
                    }

                    go_up_side_shape_generator.common_func.set_group_to_center(go_up_side_shape_generator.group_parts_mod);

                    if (lo_active_side.progress_bar) {
                        if (lo_active_side.progress_bar.div_progressbar) {
                            lo_active_side.progress_bar.div_progressbar.fadeOut();//26112024
                        }
                    }

                    //24112024 {

                    if (pv_is_build_model) {
                        go_lateral_side_shape_generator.set_visible_rotate_controls(true); // сделать видимым контрол  - слайд расстояния между деталями
                        go_lateral_side_shape_generator.rotate_status = type_rotate_mode.clockwise; // включить вращение модели
                    }
                    else {
                        go_lateral_side_shape_generator.set_visible_rotate_controls(false); // сделать невидимым контрол  - слайд расстояния между деталями
                        go_lateral_side_shape_generator.rotate_status = type_rotate_mode.stop; // выключить вращение модели
                    }

                    go_lateral_side_shape_generator.common_func.set_group_to_center(go_lateral_side_shape_generator.group_parts_mod);
                    //24112024 }



                }
            }



            catch (e) {

                alert('error do_before_after_model_request: ' + e.stack);

            }


        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.do_save_model = async function () {


            this.is_ask_about_save_file = true;
            this.is_model_changed = false;

            try {

                //18032025 go_end_side_shape_generator.end_shape.draw_cells_contours_and_texts();//17032025
                ////go_end_side_shape_generator.end_shape.refresh_end_shapes(); //23122024





                let lo_sides_data = this.read_model_sides_data();
                let lo_scene_mod = go_up_side_shape_generator.scene_mod; //24012025
                await this.common_func.save_model(lo_sides_data, lo_scene_mod);
            }

            catch (e) {

                alert('error do_save_model: ' + e.stack);

            }

        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.draw_shape_by_sides_data = function (po_sides_data) {

            try {
                let ls_sides_data = JSON.parse(po_sides_data);

                go_up_side_shape_generator.clear_shape_objects(go_up_side_shape_generator);

                go_up_side_shape_generator.make_shape(true, ls_sides_data.data1);
                go_up_side_shape_generator.render();


                go_lateral_side_shape_generator.clear_shape_objects(go_lateral_side_shape_generator);
                go_lateral_side_shape_generator.make_shape(true, ls_sides_data.data2);

                go_end_side_shape_generator.clear_shape_objects(go_end_side_shape_generator);

                go_end_side_shape_generator.end_shape.redraw_end_shape(
                    null, //po_main,
                    null, //pv_added_spline_num,
                    null, //pv_deleted_spline_num,
                    true, //po_is_use_data, 
                    ls_sides_data
                );


                go_end_side_shape_generator.end_shape.draw_cells_contours_and_texts();//!!18032025

                // 29012025 {
                go_up_side_shape_generator.set_meshes_color_by_data();
                go_lateral_side_shape_generator.set_meshes_color_by_data();
                go_end_side_shape_generator.set_meshes_color_by_data();


                go_up_side_shape_generator.render();
                go_lateral_side_shape_generator.render();
                go_end_side_shape_generator.render();
                // 29012025 }
            }

            catch (e) {

                go_up_side_shape_generator.common_func.hideWaitingIndicator();

                alert('error draw_shape_by_sides_data: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.get_parameters_from_side_data = function (po_side_data) {


            let ls_parameters = new typ_parameters();

            try {
                ls_parameters.container_width = po_side_data.parameters.container_width;
                ls_parameters.container_height = po_side_data.parameters.container_height;
                ls_parameters.shape_width_beg = po_side_data.parameters.shape_width_beg;
                ls_parameters.shape_width = po_side_data.parameters.shape_width;
                ls_parameters.shape_height_beg = po_side_data.parameters.shape_height_beg;
                ls_parameters.shape_height = po_side_data.parameters.shape_height;
                ls_parameters.shape_amount_curves = po_side_data.parameters.shape_amount_curves;
                ls_parameters.spline_amount_segments = po_side_data.parameters.spline_amount_segments;
                ls_parameters.ajust_curves_by_shape = po_side_data.parameters.ajust_curves_by_shape;
                ls_parameters.ajust_shape_by_curves = po_side_data.parameters.ajust_shape_by_curves;
                ls_parameters.distance_between_curves_in_percent_of_width = po_side_data.parameters.distance_between_curves_in_percent_of_width;
                ls_parameters.distance_bt_curves = po_side_data.parameters.distance_bt_curves;
                ls_parameters.is_space_adjust = po_side_data.parameters.is_space_adjust;
                ls_parameters.is_curve_width_adjust = po_side_data.parameters.is_curve_width_adjust;
                ls_parameters.color = +po_side_data.parameters.color;//02052025
            }

            catch (e) {

                this.model_params_changed = false;

                alert('error get_parameters_from_side_data: ' + e.stack);

            }

            return ls_parameters;
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.get_rectangle_coordinates_by_name = function (pv_name) {

            let lo_gabarits = null;

            let lo_rect = this.scene.getObjectByName(pv_name);

            if (lo_rect) {
                //13122024 lo_gabarits = this.shapes.GetTwoShapeIntersect(lo_rect, lo_rect);
                lo_gabarits = this.common_func.GetTwoShapeIntersect(lo_rect, lo_rect); //13122024
            }

            return lo_gabarits;

        }




        //------------------------------------------------------------------------
        // Формирование количества сегментов в создаваемых сплайнах
        Shape_generator.prototype.inc_spline_segments_amount = function () {

            try {

                if (this.spline_segments_amount++ > Constants.spline_segments_amount_max) {
                    this.spline_segments_amount = 1;
                }

            }

            catch (e) {

                alert('error inc_spline_segments_amount: ' + e.stack);

            }

            return this.spline_segments_amount;
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.init_containers_and_controls = function (/*pv_prefix*/) {

            try {

                $.fn.colorPicker.defaults.colors = [
                    //'ffffff',
                    //'f0f0f0', //Constants.background_color
                    'ffffff',
                    'fa0d00',
                    'fa6e00',
                    'faf100',
                    '3dfa00',
                    '00a7fa',
                    '3b00fa'
                    //'f0f0f0' //Constants.background_color
                ];


                switch (this.my_prefix) {

                    case gc_id_prefix_up:
                        $("#up_id_pos_color_picker").colorPicker({ showHexField: false/*, onColorChange: function (id, newValue) { alert("id=" + id + " value= " + newValue) }*/ });
                        break;

                    case gc_id_prefix_lateral:
                        $("#lateral_id_pos_color_picker").colorPicker({ showHexField: false/*, onColorChange: function (id, newValue) { alert("id=" + id + " value= " + newValue) }*/ });
                        break;

                    case gc_id_prefix_end:
                        break;

                }

                $(this.id_prefix + "id_shg_right_top").draggable();
                $(this.id_prefix + "id_shg_right_top").draggable("disable");

                $(this.id_prefix + this.id_side_shape_mod).draggable();
                $(this.id_prefix + this.id_side_shape_mod).draggable("disable");



                $(this.id_prefix + "id_CurvesCount").spinner(
                    {
                        min: 1,
                        max: 20
                    }

                );


                $(this.id_prefix + "id_dist_part_slider").slider(
                    {
                        orientation: "vertical",
                        value: 0,
                        max: 20,
                        ///stop: set_model_to_center,
                        ///slide:  move_details_from_to_center
                    }
                );

                $(this.id_prefix + 'id_dist_part_slider').slider('value', 0);

            }

            catch (e) {

                alert('error init_containers_and_controls: ' + e.stack);

            }

        }





        //------------------------------------------------------------------------
        Shape_generator.prototype.init_event_handlers = function () {

            try {

                let lo_active_side_shape_generator = get_active_side_shape_generator();
                let lo_passive_side_shape_generator = get_passive_side_shape_generator();

                //17062024 $(document).off('click doubleclick change pointerdown pointerup pointermove');
                $(document).off('click  change pointerdown pointerup pointermove');//17062024
                $(window).off('resize dblclick doubleclick mousemove');
                $(window).off('resize dblclick doubleclick mousemove');
                $(window).off('resize dblclick doubleclick mousemove');

                //17062024 $(document).unbind('click doubleclick change pointerdown pointerup pointermove');
                $(document).unbind('click change pointerdown pointerup pointermove');//17062024
                $(window).unbind('resize dblclick mousemove');

                if (lo_passive_side_shape_generator) {

                    if (lo_passive_side_shape_generator.controls) {
                        lo_passive_side_shape_generator.controls.removeEventListener('change', this.render);// очистка обработчика событий
                        lo_passive_side_shape_generator.controls.removeEventListener('change', lo_passive_side_shape_generator.render);// очистка обработчика событий
                    }

                }

                if (this.controls) {
                    this.controls.addEventListener('change', this.render);
                }


                // очистка обработчиков событий
                $(this.passive_id_prefix + "id_but_read_model").off("click");
                $(this.passive_id_prefix + "id_but_new_model").off("click");


                $(this.passive_id_prefix + "id_but_refresh").off("click");

                $(this.passive_id_prefix + "id_chb_space_adjust").off("click");
                $(this.passive_id_prefix + "id_chb_curve_width_adjust").off("click");
                $(this.passive_id_prefix + "id_chb_show_text_labels").off("click");


                $(this.passive_id_prefix + "id_but_del_spline").off("click");
                $(this.passive_id_prefix + "id_but_add_spline").off("click");
                $(this.passive_id_prefix + "id_but_save_model").off("click");
                $(this.passive_id_prefix + "id_but_make_model").off("click");
                $(this.passive_id_prefix + "id_but_set_color").off("click");

                $(this.passive_id_prefix + "id_but_rotate_mode").off("click");
                $(this.passive_id_prefix + "id_but_ch_nsegm").off("click");



                $(this.id_prefix + "id_chb_space_adjust").off("click").click(this.onclick_chb_space_adjust);
                $(this.id_prefix + "id_chb_curve_width_adjust").off("click").click(this.onclick_chb_curve_width_adjust);
                $(this.id_prefix + "id_chb_show_text_labels").off("click").click(this.onclick_chb_show_text_labels);

                $(this.id_prefix + "id_but_read_model").off("click").click(this.onclick_read_model);
                $(this.id_prefix + "id_but_new_model").off("click").click(this.onclick_new_model);

                $(this.id_prefix + "id_but_del_spline").off("click").click(this.onclick_del_spline);
                $(this.id_prefix + "id_but_add_spline").off("click").click(this.onclick_add_spline);
                $(this.id_prefix + "id_but_save_model").off("click").click(this.onclick_save_model);
                $(this.id_prefix + "id_but_make_model").off("click").click(this.onclick_make_model);
                $(this.id_prefix + "id_but_set_color").off("click").click(this.onclick_id_but_set_color);
                $(this.id_prefix + "id_but_rotate_mode").off("click").click(this.onclick_id_but_rotate_mode);
                $(this.id_prefix + "id_but_ch_nsegm").off("click").click(this.onclick_but_change_segments_amount);

                $(this.id_prefix + "id_but_refresh").off("click").click(this.onclick_refresh_model);

                $(this.id_prefix + this.id_side_shape).off("dblclick").dblclick(this.ondblclick_id_shape);//17062024
                $(this.id_prefix + this.id_side_shape_mod).off("dblclick").dblclick(this.ondblclick_id_shape);//25082024
                $(this.id_prefix + this.id_side_shape).dblclick(null);
                $(this.id_prefix + this.id_side_shape_mod).dblclick(null);//25082024

                //--------------------------------------------------------------------------------------------

                ////// обработчики событий gui


                //}
                //--------------------------------------------------------------------------------------------


                // очистка обработчиков событий
                document.removeEventListener('pointerdown', this.onPointerDown);



                document.removeEventListener('pointerup', this.onPointerUp);
                //document.addEventListener('pointermove', null);
                window.removeEventListener('resize', this.onWindowResize);
                window.removeEventListener('mousemove', this.onmousemove);

                $(this.id_prefix + this.id_side_shape).dblclick(null);//17062024 

                if (lo_passive_side_shape_generator) {
                    document.removeEventListener('pointerdown', lo_passive_side_shape_generator.onPointerDown);

                    document.removeEventListener('pointerup', lo_passive_side_shape_generator.onPointerUp);
                    //document.addEventListener('pointermove', null);
                    window.removeEventListener('resize', lo_passive_side_shape_generator.onWindowResize);
                    window.removeEventListener('mousemove', lo_passive_side_shape_generator.onmousemove);

                    $(this.id_prefix + this.id_side_shape).off("dblclick").dblclick(lo_passive_side_shape_generator.ondblclick_id_shape);//17062024
                    $(this.id_prefix + this.id_side_shape).dblclick(null);//17062024 

                }

                //17062024 {

                if (lo_active_side_shape_generator) {
                    document.removeEventListener('pointerdown', lo_active_side_shape_generator.onPointerDown);
                    document.removeEventListener('pointerup', lo_active_side_shape_generator.onPointerUp);
                    //document.addEventListener('pointermove', null);
                    window.removeEventListener('resize', lo_active_side_shape_generator.onWindowResize);
                    window.removeEventListener('mousemove', lo_active_side_shape_generator.onmousemove);
                    ////    window.removeEventListener('dblclick', lo_active_side_shape_generator.ondblclick_id_shape);//17062024
                    ////    window.addEventListener('dblclick', null);//17062024

                }


                //17062024 {




                document.addEventListener('pointerdown', this.onPointerDown);

                document.addEventListener('pointerup', this.onPointerUp);
                //document.addEventListener('pointermove', onPointerMove);
                window.addEventListener('resize', this.onWindowResize);
                window.addEventListener('mousemove', this.onmousemove);
                //////////////////window.addEventListener('dblclick', this.ondblclick_id_shape);//17062024

                //window.addEventListener('click', window_onclick	);
                $(this.passive_id_prefix + this.id_side_shape).off("click");
                $(this.passive_id_prefix + "id_but_mirror").off("click");
                $(this.passive_id_prefix + "id_but_del_segment").off("click");
                $(this.passive_id_prefix + "id_but_add_segment").off("click");

                $(this.id_prefix + this.id_side_shape).off("click").on("click", this.onclick_shape);//17072024 

                $(this.id_prefix + "id_but_mirror").off("click").on("click", this.but_mirror_onclick);
                $(this.id_prefix + "id_but_del_segment").off("click").on("click", this.but_delete_segment_onclick);
                $(this.id_prefix + "id_but_add_segment").off("click").on("click", this.but_insert_segment_onclick);
                $(this.id_prefix + "id_but_random").off("click").on("click", this.but_make_random_onclick);


                //this.render();//05052024
                lo_active_side_shape_generator.onWindowResize();//21062024




                // 05012025 this.render_mod();





                //--------------------------------------------------------------------
                // наблюдатель за изменением цвета элемента

                // Создание экземпляра MutationObserver
                const observer = new MutationObserver(this.common_func.handleColorChange);

                // Целевой элемент, за которым нужно следить
                const targetElement = document.getElementById(this.id_prefix_wo_sharp + "id_for_colorpicker");

                // Параметры наблюдения
                const config = { attributes: true, attributeFilter: ['style'] };

                // Начало наблюдения за целевым элементом
                observer.observe(targetElement, config); //, lf_callback);

                //--------------------------------------------------------------------


            }
            catch (e) {

                alert('error init_event_handlers: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.init_three_elements = function (/*pv_prefix*/) {

            try {

                if (
                    this.my_prefix == gc_id_prefix_up
                    || this.my_prefix == gc_id_prefix_lateral
                    || this.my_prefix == gc_id_prefix_end
                ) {

                    this.container = document.getElementById(this.id_prefix_wo_sharp + this.id_side_shape);//20062024);


                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(+Constants.background_color);


                    this.scene.matrixAutoUpdate = false; // Запрещает изменять матрицу поворота

                    let lo_cameraPersp, lo_cameraOrtho;


                    let lv_aspect = window.innerWidth / window.innerHeight;
                    const lv_frustumSize = 160;
                    lo_cameraOrtho = new THREE.OrthographicCamera(
                        -lv_frustumSize * lv_aspect / 2, lv_frustumSize * lv_aspect / 2,
                        lv_frustumSize / 2, -lv_frustumSize / 2,
                        0.1, 1000
                    );

                    this.aspect = lv_aspect;

                    this.camera = lo_cameraOrtho;


                    this.scene.add(new THREE.AmbientLight(0xf0f0f0, 3));
                    //this.scene.add(new THREE.DirectionalLight(0xf0f0f0, 3));
                    const light = new THREE.SpotLight(0xffffff, 4.5);
                    light.position.set(0, 1500, 200);
                    light.angle = Math.PI * 0.2;
                    light.decay = 0;
                    light.castShadow = true;
                    light.shadow.camera.near = 200;
                    light.shadow.camera.far = 2000;
                    light.shadow.bias = - 0.000222;
                    light.shadow.mapSize.width = 1024;
                    light.shadow.mapSize.height = 1024;
                    this.scene.add(light);

                    let lo_planeGeometry;
                    //lo_planeGeometry = new THREE.PlaneGeometry(2000, 2000);
                    lo_planeGeometry = new THREE.PlaneGeometry(200, 200);




                    let lo_planeMaterial;
                    lo_planeMaterial = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.2 });

                    //this.plane = new THREE.Mesh(lo_planeGeometry, lo_planeMaterial);
                    //this.plane.receiveShadow = true;
                    //this.plane.matrixAutoUpdate = false; // Запрещает изменять матрицу поворота
                    //this.scene.add(this.plane);



                    //06022025 this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance", alpha: true });
                    //06022025 this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "low-power", alpha: true }); //06022025
                    this.renderer = new THREE.WebGLRenderer({ antialias: true, webgl1: true }); //06022025
                    //this.renderer.context.getExtension("WEBGL_lose_context").loseContext();//06022025 

                    ///////////////////////////11012025 this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);// 06052024



                    this.container.appendChild(this.renderer.domElement);


                    // Controls
                    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.damping = 0.2;

                    this.controls.enableRotate = false;// bvi


                    this.camera.position.set(0, 0, 1);//позиционирование камеры перед плоскостью





                    let lo_center = new THREE.Vector3(75, 50, 0);

                    let lo_distance = this.camera.position.distanceTo(this.controls.target); // Расстояние от камеры до центра
                    let lo_direction = new THREE.Vector3().subVectors(this.camera.position, this.controls.target).normalize(); // Направление камеры

                    this.camera.position.copy(lo_center.clone().add(lo_direction.multiplyScalar(lo_distance))); // Сохраняем дистанцию
                    this.camera.lookAt(lo_center); // Направляем камеру на центр

                    // 3. Обновляем точку фокусировки OrbitControls
                    this.controls.target.copy(lo_center);
                    this.controls.update();


                    //07022025 this.text_material = new THREE.MeshBasicMaterial({ color: Constants.color_text /*0xffffff*/ });
                    //07022025 this.cell_text_mesh = null; //07022025


                    //06022025 {
                    ////// Загружаем шрифт
                    ////if (go_up_side_shape_generator) {

                    ////    if (!go_up_side_shape_generator.textfont) {

                    ////        let fontLoader = new FontLoader();
                    ////        fontLoader.load("./three_fonts/optimer_regular.typeface.json",
                    ////            //fontLoader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",

                    ////            function (po_font) {

                    ////                try {

                    ////                    //let lo_active_side = get_active_side_shape_generator();//14072024

                    ////                    //lo_active_side.textfont = po_font;  // Сохраняем шрифт
                    ////                    go_up_side_shape_generator.textfont = po_font;  // Сохраняем шрифт

                    ////                    ////    //createText("Hello, World!");  // Создаём первый текст
                    ////                }
                    ////                catch (e) {

                    ////                    console.error("Шрифт ещё не загружен!");
                    ////                }

                    ////            });
                    ////    }
                    ////}
                    //06022025 }

                }



                //11012025 {
                //if (this.my_prefix != gc_id_prefix_end
                //    // && this.my_prefix != gc_id_prefix_lateral //25122024
                //) {

                if (
                    this.my_prefix == gc_id_prefix_up
                    || this.my_prefix == gc_id_prefix_lateral
                ) {

                    //11012025 }

                    // установки для модели
                    //======================================================================

                    this.lo_renderer_mod = null;
                    this.container_mod = document.getElementById(this.id_prefix_wo_sharp + this.id_side_shape_mod);//20062024
                    this.scene_mod = new THREE.Scene();
                    ///this.group_parts_mod = new THREE.Object3D(); //14102024 
                    //this.group_parts_mod.position.set(0, 0, 0);
                    this.group_parts_mod = new THREE.Group(); //14102024 
                    this.scene_mod.add(this.group_parts_mod); //14102024 

                    //this.scene_mod.background = new THREE.Color(0xf0f0f0);


                    // CAMERA
                    var SCREEN_WIDTH = this.container_mod.clientWidth, SCREEN_HEIGHT = this.container_mod.clientHeight;
                    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
                    this.camera_mod = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                    this.scene_mod.add(this.camera_mod);

                    //this.camera_mod.position.set(0, 150, 400);
                    this.camera_mod.position.set(50, 150, 250);
                    this.camera_mod.lookAt(this.scene_mod.position);




                    ////this.scene_mod.add(new THREE.AmbientLight(0xf0f0f0, 3));
                    ////const light_mod = new THREE.SpotLight(0xffffff, 4.5);
                    ////light_mod.position.set(0, 1500, 200);
                    ////light_mod.angle = Math.PI * 0.2;
                    ////light_mod.decay = 0;
                    ////light_mod.castShadow = true;
                    ////light_mod.shadow.camera.near = 200;
                    ////light_mod.shadow.camera.far = 2000;
                    ////light_mod.shadow.bias = - 0.000222;
                    ////light_mod.shadow.mapSize.width = 1024;
                    ////light_mod.shadow.mapSize.height = 1024;
                    ////this.scene_mod.add(light_mod);


                    ////let ambientLight = new THREE.AmbientLight(0x7c7c7c, 3.0);

                    ////let light1 = new THREE.DirectionalLight(0xFFFFFF, 3.0);
                    ////light1.position.set(0.32, 0.39, 0.7);

                    ////this.scene_mod.add(ambientLight);
                    ////this.scene_mod.add(light1);



                    //////let lo_planeGeometry_mod;
                    //////lo_planeGeometry_mod = new THREE.PlaneGeometry(2000, 2000);
                    //////lo_planeGeometry_mod.rotateX(- Math.PI / 2);

                    //////let lo_planeMaterial_mod;
                    ////////lo_planeMaterial_mod = new THREE.ShadowMaterial({ color: 0x000000, opacity: 0.2 });
                    //////lo_planeMaterial_mod = new THREE.ShadowMaterial({ color: 0xFF0000, opacity: 1 });

                    //////this.plane_mod = new THREE.Mesh(lo_planeGeometry, lo_planeMaterial);
                    //////this.plane_mod.receiveShadow = true;
                    //////this.scene_mod.add(this.plane_mod);



                    //06022025 this.renderer_mod = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });

                    //////////////his.renderer_mod.setSize(this.id_side_shape_mod.clientWidth, this.id_side_shape_mod.clientHeight);// 06052024

                    //06022025 this.renderer_mod = new THREE.WebGLRenderer({ antialias: true, powerPreference: "low-power", alpha: true }); //06022025
                    this.renderer_mod = new THREE.WebGLRenderer({ antialias: true, webgl1: true }); //06022025
                    //this.renderer_mod.context.getExtension("WEBGL_lose_context").loseContext();//06022025 

                    this.container_mod.appendChild(this.renderer_mod.domElement);




                    //this.renderer_mod.setClearColor(0x000fff);//, 1);// цвет фона
                    //08112024 this.renderer_mod.setClearColor(0xf0f0f0);//, 1);// цвет фона
                    this.renderer_mod.setClearColor(0xffffff);//, 1);// цвет фона //08112024 



                    ////////////this.renderer_mod.setPixelRatio(window.devicePixelRatio);
                    /////////////////////////this.renderer_mod.setAnimationLoop(this.animate_mod);









                    // Controls
                    this.controls_mod = new OrbitControls(this.camera_mod, this.renderer_mod.domElement);
                    ////this.controls_mod.damping = 0.2;
                    ////this.controls_mod.enableRotate = false;// bvi
                    //this.controls_mod.autoRotate = true;




                    this.add_lights_for_model(this.scene_mod);

                    this.model_parts_positions = []; // new Array();



                } // 06122024 this.my_prefix != gc_id_prefix_end


                if (this.my_prefix == gc_id_prefix_end) { //11012025

                    //else {

                    this.group_end_shape = new THREE.Group();
                    this.group_end_shape.name = cv_name_group_end_shape;
                    this.group_end_shape.renderOrder = 5;

                    this.group_end_cells_contours = new THREE.Group();
                    this.group_end_cells_contours.name = cv_name_group_end_cells_contours;
                    this.group_end_cells_contours.renderOrder = 3;

                    this.end_group_cells_mesh = new THREE.Group();
                    this.end_group_cells_mesh.name = cv_name_end_group_cells_mesh;
                    this.end_group_cells_mesh.renderOrder = 2;

                    this.end_shape = new EndShape(this);
                    //this.group_end_shape.add(this.end_shape);


                    //31012025 {
                    this.scene.add(this.group_end_shape);
                    this.scene.add(this.group_end_cells_contours);
                    this.scene.add(this.end_group_cells_mesh);

                    //this.plane.add(this.group_end_shape);
                    //this.plane.add(this.group_end_cells_contours);
                    //this.plane.add(this.end_group_cells_mesh);
                    //31012025  }


                    //07022025 {
                    this.group_cell_texts = new THREE.Group();
                    this.scene.add(this.group_cell_texts);
                    //07022025 }


                }


                //=================================================================================================

                // обработчики событий gui
                if (!this.gui) {
                    this.reset_gui_parameters();
                }


                //=================================================================================================


                this.common_func = new CommonFunc();

                this.client_id = this.common_func.get_random_number_int(1, 9999999999).toString();


                ////if (this.my_prefix == gc_id_prefix_end) {


                ////12122024 {
                //this.group_end_shape = new THREE.Group();
                //this.group_end_shape.name = cv_name_group_end_shape;

                //this.end_shape = new EndShape(this);
                ////this.group_end_shape.add(this.end_shape);

                //this.scene.add(this.group_end_shape);
                ////12122024 }





                ////this.render();

                ////////}
                ////////else {

                this.make_shape(false, null);

                //this.render();
                ////}



                this.grid_select_models = new GridSelectModels(this.id_prefix);


                //this.scene.children.forEach(obj => obj.lookAt(this.camera.position));//31012025


                this.render();

                //this.animate(); //31012025

                //==============================================================================
                //==============================================================================

            }

            catch (e) {

                alert('error init_three_elements: ' + e.stack);

            }

        }




        //------------------------------------------------------------------------
        Shape_generator.prototype.load_initial_model = function () {

            try {

                let lv_end_watching_progress_value = 50;
                this.progress_bar = new ProgressBar(this, this.client_id, "https://localhost:7095/CalcJBModel", Constants.method_start_refresh_premodel, this.read_result_refresh_premodel, lv_end_watching_progress_value);
                this.progress_bar.task_id = this.common_func.get_random_number_int(1, 9999999999).toString(); //22112024

                let lv_path_file_initial_premodel = Constants.path_file_initial_premodel;
                this.grid_select_models.read_model_from_server(lv_path_file_initial_premodel, true);

                this.render();//26012025

            }

            catch (e) {

                alert('error load_initial_model: ' + e.stack);

            }
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.load_model_parts = function (po_data) {

            try {


                let lo_active_side = get_active_side_shape_generator();

                if (po_data == null || po_data.number_outfiles == null || po_data.number_outfiles <= 0) {

                    let lv_is_before = false;
                    lo_active_side.do_before_after_model_request(lv_is_before, false);

                    return;
                }

                // Очистка сцены new THREE.Group();
                let lar_no_delete = ["AmbientLight", "PointLight", "SpotLight", "PerspectiveCamera", "Group"];// 14102024
                lo_active_side.common_func.clearScene(lo_active_side.scene_mod, lar_no_delete);


                let lv_filename = "";

                lo_active_side.num_loaded_model_parts = 0;//16102024

                // Очистка группы деталей
                lo_active_side.group_parts_mod.clear();


                lo_active_side.model_prefix_filename = po_data.common_outfilename_part; // префикс - общая часть имён файлов деталей
                go_tab_orders.model_prefix_filename = po_data.common_outfilename_part;


                // Загрузка деталей модели
                //26012025 for (let lv_i = 1; lv_i <= po_data.number_outfiles; lv_i++) {
                for (let lv_i = 0; lv_i < po_data.names_part_files.length; lv_i++) { //26012025

                    //26012025 lv_filename = po_data.common_outfilename_part + "_" + lv_i.toString() + Constants.file_model_ext;
                    lv_filename = po_data.common_outfilename_part + Constants.data_delimiter + po_data.names_part_files[lv_i]; //26012025 

                    //26012025 lo_active_side.model_numparts = po_data.number_outfiles;
                    lo_active_side.model_numparts = po_data.names_part_files.length; //26012025



                    //this.model_curr_numpart = lv_i;

                    lo_active_side.load_model_part(lv_filename);

                }


            }

            catch (e) {

                alert('error load_model_parts: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.load_model_part = function (pv_filename) {

            let lo_active_side = get_active_side_shape_generator();
            let lo_passive_side = get_passive_side_shape_generator();

            try {

                let lv_url = "https://localhost:7095/CalcJBModel?method=" + Constants.method_read_model_parts +
                    "&filename=" + pv_filename
                    + "&chdata=" + Math.random().toString(); // 23112024
                ;


                let lv_is_before = true;


                get_model_part(lv_url);


                //--------------------------------------------------
                async function get_model_part(pv_url) {
                    //--------------------------------------------------
                    await $.get(pv_url, "", lo_active_side.oncomplete_read_model_part);
                }
                //--------------------------------------------------

            }
            catch (e) {

                let lv_is_before = false;
                lo_active_side.do_before_after_model_request(lv_is_before, false);

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.make_model = function () {

            try {

                let lv_end_watching_progress_value = 50;
                this.progress_bar = new ProgressBar(this, this.client_id, "https://localhost:7095/CalcJBModel", Constants.method_start_make_model, this.load_model_parts, lv_end_watching_progress_value);

                this.progress_bar.task_id = this.common_func.get_random_number_int(1, 9999999999).toString(); //22112024


                this.progress_bar.set_display_value(3);

                let lv_url = "https://localhost:7095/CalcJBModel?method="
                    + Constants.method_start_make_model
                    + "&"
                    + Constants.word_client_id + "=" + this.client_id
                    + "&"
                    + Constants.word_task_id + "=" + this.progress_bar.task_id
                    + "&chdata=" + Math.random().toString(); // 23112024

                //let lv_url = "https://localhost:7095/CalcJBModel?method="
                //    + Constants.method_make_model
                //    + "&chdata=" + Math.random().toString(); // 23112024


                let lo_sides_data = this.read_model_sides_data(); lo_sides_data.task_id = this.progress_bar.task_id;
                lo_sides_data.task_id = this.progress_bar.task_id;


                this.send_side_data_for_start_make_model(lv_url, lo_sides_data);


            }

            catch (e) {

                this.model_params_changed = false; //29082024

                alert('error make_model: ' + e.stack);

            }


        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.make_shape = function (pv_is_use_data, po_side_data) {

            try {

                if (pv_is_use_data) {
                    this.gui.reset();
                    this.params = this.get_parameters_from_side_data(po_side_data); //05112024
                    this.common_func.guiUpdateDisplay(this.gui);

                    this.reset_gui_parameters();

                    //go_end_side_shape_generator.ColorParts = po_side_data.colorParts;
                }


                if (this.my_prefix != gc_id_prefix_end) {

                    this.shapes = new Shapes(
                        this,
                        this.scene,
                        this.params,
                        pv_is_use_data,
                        po_side_data
                    );

                    this.splines = new Splines(
                        this,
                        pv_is_use_data
                    );

                    this.segments = new Segments(
                        this,
                        pv_is_use_data
                    );

                    //02112024 if (!pv_is_use_data) {
                    this.segment_gabarits = this.segments.get_segment_size();
                    //13022025 this.segment_transform_data = this.segments.get_segment_transform_data(/*this.segment_gabarits,*/ this.params.ajust_curves_by_shape);
                    this.segment_transform_data = this.segments.get_segment_transform_data(/*this.segment_gabarits,*/ this.params.ajust_curves_by_shape, this.params.spline_amount_segments);//13022025
                    //02112024 }

                    this.shapes.create_shapes(pv_is_use_data, po_side_data);

                    this.rectangle = new Rectangle(this.scene,
                        this.params.shape_width, this.params.shape_height); //05112024




                    this.group_contours = new THREE.Group();
                    this.group_contours.name = cv_name_group_contours;
                    this.scene.add(this.group_contours);
                    //this.plane.add(this.group_contours);//31012025

                    this.group_color_mesh = new THREE.Group();
                    this.group_color_mesh.name = cv_name_group_color_mesh;


                    this.scene.add(this.group_color_mesh);
                    //this.plane.add(this.group_color_mesh);//31012025


                    //if (pv_is_use_data) {
                    //    let lar_splines_order = this.shapes.SortSplinesOrderFromLeftToRight();//28012025
                    //    this.shapes.redraw_meshes_color(lar_splines_order);//2012025
                    //}
                    //else {
                    //    this.shapes.adjust_splines_by_external_shape();//28012025
                    //}


                    if (!pv_is_use_data) {
                        this.shapes.adjust_splines_by_external_shape();//28012025

                    }

                }

                else {
                    //12122024 {
                    //////if (!this.group_end_shape) {
                    //////    this.group_end_shape = new THREE.Group();
                    //////    this.group_end_shape.name = cv_name_group_end_shape;
                    //////}

                    ////////if (!this.end_shape) {
                    ////////if (this.my_prefix == gc_id_prefix_end) {

                    //////this.end_shape = new EndShape(/*this*/);//12122024
                    //////this.scene.add(this.group_end_shape);
                    ////////}
                    //12122024 }
                }



            }

            catch (e) {

                this.model_params_changed = false;

                alert('error make_shape: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.OnCompleteStartMakeModel = function (po_data) {

            try {
                let lo_active_side = get_active_side_shape_generator();
                let lo_passive_side = get_passive_side_shape_generator();

                if (po_data == null || po_data == "" || typeof po_data == "undefined") {

                    let lv_is_before = false;
                    lo_active_side.do_before_after_model_request(lv_is_before, false);

                    return;
                }

                if (po_data.client_id != lo_active_side.client_id
                    || po_data.task_id != lo_active_side.progress_bar.task_id
                ) {
                    return;
                }


                this.progress_bar.start_progress();


            }

            catch (e) {

                alert('error OnCompleteStartMakeModel: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.oncomplete_read_model_part = function (po_data) {


            try {

                const loader = new STLLoader();
                const geometry_mod = loader.parse(po_data);

                let lo_active_side = get_active_side_shape_generator();
                let lo_passive_side = get_passive_side_shape_generator();

                let lv_url = null;

                /////////////geometry_mod.center();// Объект - в центре вращения


                lo_active_side.num_loaded_model_parts++; // подсчёт числа загруженных деталей




                //14012025 {
                //-------------------------------------------------------------------
                // сохранение детали на сервере


                //try {
                //    let lv_url = "/Index?handler=" + Constants.method_save_model_part + "&filename=" + pv_filename;

                //    let response = await fetch(lv_url, {
                //        method: "POST",
                //        headers: {
                //            //"Accept": "application/json"
                //            "Content-Type": "application/json"
                //        },

                //        body: po_data

                //    });

                //    //const message = await response.json();
                //    const message = await response.text();
                //    let lo_active_side = get_active_side_shape_generator();


                //}

                //catch (e) {
                //    alert('error send: ' + e.stack);
                //}




                //=========================================================================
                const mesh_mod = new THREE.Mesh(geometry_mod, lo_active_side.material_mod);

                lo_active_side.group_parts_mod.add(mesh_mod);//14102024



                if (lo_active_side.num_loaded_model_parts == lo_active_side.model_numparts)

                // конец загрузки деталей

                {
                    ////// Задержка для загрузки всех деталей
                    ////var delayInMilliseconds = 1000; // 1 second

                    ////setTimeout(function () {

                    lo_active_side.common_func.set_group_to_center(lo_active_side.group_parts_mod);

                    // Запоминание в массиве начальных координат деталей

                    lo_active_side.model_parts_positions.length = 0;
                    for (let lv_i = 0; lv_i < lo_active_side.group_parts_mod.children.length; lv_i++) {


                        //lo_active_side.group_parts_mod.children[lv_i].updateMatrix();
                        //lo_active_side.group_parts_mod.children[lv_i].updateMatrixWorld();

                        ////lo_active_side.model_parts_positions.
                        ////    push(lo_active_side.group_parts_mod.children[lv_i].geometry.boundingBox);
                        lo_active_side.model_parts_positions[lv_i] =
                            lo_active_side.group_parts_mod.children[lv_i].geometry.boundingBox;


                    }



                    ////lo_active_side.is_building_model = false;
                    ////lo_passive_side.is_building_model = false;

                    ////$('#up_id_loading_indicator').hide();// прекращение индикации ожидания
                    ////$('#lateral_id_loading_indicator').hide();// прекращение индикации ожидания
                    ////lo_active_side.set_visible_rotate_controls(true); // сделать видимым контрол  - слайд расстояния между деталями
                    ////lo_active_side.rotate_status = type_rotate_mode.clockwise; // включить вращение модели
                    ////$('#up_id_div_visual_model').css('opacity', 1);// прозрачность контента
                    ////$('#lateral_id_div_visual_model').css('opacity', 1);// прозрачность контента




                    //18012025 {
                    //---------------------------------------------------------------------------------
                    // чтение и сохранение на сервере zip-файла с деталями модели

                    let lv_filename_zip = lo_active_side.model_prefix_filename + Constants.file_model_zip;

                    lv_url = "https://localhost:7095/CalcJBModel?method=" + Constants.method_read_model_parts_zip_file_from_api
                        + "&"
                        + "filename" + "=" + lv_filename_zip
                        + "&chdata=" + Math.random().toString();

                    let lv_is_download_to_downloads_folder = false;// сохранение в папку "Загрузки"
                    let lv_downloaded_filename = lv_filename_zip;// "jb_puzzle_parts.zip";
                    let lv_is_save_to_server = true;// сохранение файла на сервер 


                    CommonFunc.prototype.read_file_from_server(lv_url, lv_is_download_to_downloads_folder,
                        lv_downloaded_filename, lv_is_save_to_server,
                        lo_active_side.delete_on_server_model_parts);

                    //18012025 }







                    ////// Посылка команды на удаление промежуточных файлов на сервере

                    ////let lv_url = "https://localhost:7095/CalcJBModel?method=" + Constants.method_delete_model_parts +
                    ////    "&filename=" + lo_active_side.model_prefix_filename
                    ////    + "&chdata=" + Math.random().toString(); // 23112024
                    ////;

                    ////get_delete_on_server_model_parts(lv_url)
                    ////async function get_delete_on_server_model_parts(pv_url) {
                    ////    //--------------------------------------------------
                    ////    await $.get(pv_url);
                    ////}


                    ////lo_active_side.animate_mod();

                    ////let lv_is_before = false;
                    ////lo_active_side.do_before_after_model_request(lv_is_before, true);


                }

            }


            catch (e) {

                //alert('error oncomplete_read_model_part: ' + e.stack);
                CommonFunc.prototype.Show_message("Error making model!", 2000);


            }


        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.OnCompleteRefreshModel = function (po_data) {
            try {


                let lo_active_side = get_active_side_shape_generator();
                let lo_passive_side = get_passive_side_shape_generator();

                if (po_data == null || po_data == "") {

                    let lv_is_before = false;
                    lo_active_side.do_before_after_model_request(lv_is_before, false);

                    alert("Error updating model!")

                    return;
                }

                let ls_progress_data = JSON.parse(po_data);

                ////if (po_data.indexOf(Constants.word_task_id) < 0) {
                ////    return;
                ////}


                if (ls_progress_data == null || typeof ls_progress_data == "undefined") {
                    return;
                }

                if (ls_progress_data.client_id != lo_active_side.client_id
                    || ls_progress_data.task_id != lo_active_side.progress_bar.task_id
                ) {
                    return;
                }





                /////////////////////////////21112024 lo_active_side.progress_bar.set_display_value(5);

                this.progress_bar.start_progress();



                /////////////this.refresh_model_data = 

                //16112025 { in the load_refresh_model

                //////const loader = new STLLoader();
                //////const lo_geometry = loader.parse(po_data);

                //////// Очистка сцены
                //////let lar_no_delete = ["PointLight", "PerspectiveCamera", "Group"];// "Mesh", 
                //////lo_active_side.common_func.clearScene(lo_active_side.scene_mod, lar_no_delete);
                //////lo_active_side.on_load_model(lo_geometry);
                //16112025 }


            }

            catch (e) {

                this.model_params_changed = false; //29082024

                alert('error OnCompleteRefreshModel: ' + e.stack);

            }
        }



        //-------------------------------------------------------------------
        //22112024 Shape_generator.prototype.load_refresh_model = function (po_data) {
        Shape_generator.prototype.oncomplete_read_result_refresh_premodel = function (po_data) {

            let lo_active_side = get_active_side_shape_generator();
            let lo_passive_side = get_passive_side_shape_generator(); //04102024

            const loader = new STLLoader();
            const lo_geometry = loader.parse(po_data);

            // Очистка сцены
            let lar_no_delete = ["AmbientLight", "PointLight", "SpotLight", "PerspectiveCamera", "Group"];// "Mesh", 
            lo_active_side.common_func.clearScene(lo_active_side.scene_mod, lar_no_delete);
            lo_passive_side.common_func.clearScene(lo_passive_side.scene_mod, lar_no_delete); //24112024

            lo_active_side.on_load_model(lo_geometry);
            lo_passive_side.on_load_model(lo_geometry);

        }


        //-------------------------------------------------------------------
        Shape_generator.prototype.on_load_model = function (geometry_mod) {


            try {

                go_up_side_shape_generator.is_building_model = false;//27012025
                go_lateral_side_shape_generator.is_building_model = false;//27012025

                //26012025 {

                geometry_mod.center();// Объект - в центре вращения



                ////let lo_active_side = get_active_side_shape_generator();
                ////let lo_passive_side = get_passive_side_shape_generator();


                ////lo_active_side.progress_bar.set_display_value(70);


                //////-------------------------------------------------------------------
                ////const mesh_mod1 = new THREE.Mesh(geometry_mod, lo_active_side.material_mod);
                ////const mesh_mod2 = new THREE.Mesh(geometry_mod, lo_active_side.material_mod);


                ////lo_active_side.group_parts_mod.add(mesh_mod1);
                ////lo_passive_side.group_parts_mod.add(mesh_mod2);//24112024

                ////lo_active_side.progress_bar.set_display_value(90);

                ////let lv_is_before = false;
                ////lo_active_side.do_before_after_model_request(lv_is_before, false);

                ////lo_active_side.progress_bar.set_display_value(100);
                ////lo_active_side.progress_bar.stop_progress();

                ////lo_active_side.animate_mod();

                ////lo_active_side.is_building_model = false;
                ////lo_passive_side.is_building_model = false;




                let lo_active_side = get_active_side_shape_generator();
                //let lo_passive_side = get_passive_side_shape_generator();

                if (lo_active_side.progress_bar) { //27012025
                    lo_active_side.progress_bar.set_display_value(70);
                }

                //-------------------------------------------------------------------
                const mesh_mod1 = new THREE.Mesh(geometry_mod, go_up_side_shape_generator.material_mod);
                const mesh_mod2 = new THREE.Mesh(geometry_mod, go_lateral_side_shape_generator.material_mod);


                go_up_side_shape_generator.group_parts_mod.add(mesh_mod1);
                go_lateral_side_shape_generator.group_parts_mod.add(mesh_mod2);//24112024

                if (lo_active_side.progress_bar) { //27012025
                    lo_active_side.progress_bar.set_display_value(90);
                }

                let lv_is_before = false;
                lo_active_side.do_before_after_model_request(lv_is_before, false);

                if (lo_active_side.progress_bar) { //27012025
                    lo_active_side.progress_bar.set_display_value(100);
                    lo_active_side.progress_bar.stop_progress();
                }


                lo_active_side.animate_mod();

                go_up_side_shape_generator.is_building_model = false;
                go_lateral_side_shape_generator.is_building_model = false;



                //26012025 }

            }

            catch (e) {

                go_up_side_shape_generator.model_params_changed = false; //29082024
                go_lateral_side_shape_generator.model_params_changed = false; //29082024

                alert('error on_load_model: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.OnErrorRefreshModel = function () {

            let lo_active_side = get_active_side_shape_generator();
            let lv_is_before = false;

            lo_active_side.do_before_after_model_request(lv_is_before, false);


            /////alert("OnErrorRefreshModel");

            //02092024 lo_active_side.is_building_model = false;

        }




        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_id_but_rotate_mode = function () {

            try {

                let lo_active_side = get_active_side_shape_generator();

                if (lo_active_side.rotate_status > 3) {
                    lo_active_side.rotate_status = 0;
                }
                lo_active_side.rotate_status++;

            }

            catch (e) {

                alert('error onclick_id_but_rotate_mode: ' + e.stack);

            }

        }
        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_id_but_set_color = function () {

            try {

                let lo_active_side = get_active_side_shape_generator();

                //for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {


                //lo_active_side_shape_generator.shapes.get_left_and_right_splines_of_clicked_figure();


                ////lo_active_side_shape_generator.shapes.set_shape_color(
                ////    lo_active_side_shape_generator.shapes.ar_splines[0].children[3],
                ////    lo_active_side_shape_generator.shapes.ar_splines[1].children[3],
                ////    0x00ff00);



                ////lo_active_side_shape_generator.shapes.draw_contour_and_shape(
                ////    lo_active_side_shape_generator.shapes.ar_splines[0].children[3],
                ////    lo_active_side_shape_generator.shapes.ar_splines[1].children[3]);






                ////lo_active_side_shape_generator.camera.updateProjectionMatrix();
                ////lo_active_side_shape_generator.render();



                ////for (let lv_i = 0; lv_i < lo_active_side_shape_generator.ar_selected_segments.length; lv_i++) {

                ////    let lo_selected_segment = lo_active_side_shape_generator.ar_selected_segments[lv_i];

                ////    if (lo_selected_segment.parent) {

                ////        let lo_colored_chape = this.get_shape_by_group();

                ////        let lo_colored_chape = lo_selected_segment.parent.parent;

                ////        lo_active_side_shape_generator.shapes.set_shape_color("00ff00");

                ////        //this.ar_selected_segments[lv_i] = this.make_mirror_segment(lo_selected_segment);//23042024
                ////        //lar_selected_spline_groups.push(lo_parent_parent);
                ////    }
                ////}









                ////////$("#id_empty_div_for_colorpick").click();



                ////////08072024 {


                //////let lo_active_side_shape_generator = get_active_side_shape_generator();
                ////////let lv_id_colored_shape = lo_active_side_shape_generator.id_prefix + "id_shape";
                //////let lv_id_colored_shape = lo_active_side_shape_generator.id_prefix + "id_shg_right";


                /////$("#up_id_my_gui_1").colorPicker({ showHexField: false, onColorChange: function (id, newValue) { alert("id=" + id + " value= " + newValue) } });
                ///$("#up_id_for_colorpicker").colorPicker({ showHexField: false, onColorChange: function (id, newValue) { alert("id=" + id + " value= " + newValue) } });


                let lv_id_for_colorpicker = lo_active_side.id_prefix + "id_for_colorpicker";
                ///$(lv_id_for_colorpicker).colorPicker({ showHexField: false, onColorChange: function (id, newValue) { alert("id=" + id + " value= " + newValue) } });
                let lv_colorPicker_palette = "#colorPicker_palette-0";


                //////////$(lv_id_colored_shape).change(function () {
                //////////    alert("color changed");
                //////////});



                ////////$.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $(lv_id_colored_shape));

                ///$.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $("#id_empty_div_for_colorpick"));
                //$.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $("#up_id_my_gui_1"));
                //$.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $("#up_id_shg_right"));


                //$.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $("#up_id_for_colorpicker"));
                $.fn.colorPicker.togglePalette($(lv_colorPicker_palette), $(lv_id_for_colorpicker));



            }
            catch (e) {

                alert('error init_event_handlers: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.onColorChange = function (pv_value) {

            let lo_active_side = get_active_side_shape_generator();


            let lar_splines_order = [];

            let lv_num_spline_left = null;
            let lv_num_spline_right = null;

            let lo_spline_left = null;
            let lo_spline_right = null;

            //02052025 let lv_hexColor = null;
            let lo_color_rgb = null;


            //19012025 {
            let lar_splines_order2 = null;
            let lv_num_spline_left2 = null;
            let lv_num_spline_right2 = null;
            let lo_spline_left2 = null;
            let lo_spline_right2 = null;


            let lv_color_hex = 0;
            //19012025 }



            try {

                while (true) {

                    //02052025 lv_hexColor = lo_active_side.common_func.rgbToNumber(pv_value);
                    //05022025 lv_color = lo_active_side.common_func.rgbToNumber(pv_value);

                    //lo_color_rgb = lo_active_side.common_func.extractRGBComponents(pv_value);//05022025


                    ////const color = new THREE.Color(pv_value /*"rgb(0, 0, 255)"*/); // RGB-синий
                    ////color.convertSRGBToLinear(); // Преобразуем в линейное пространство
                    lo_color_rgb = new THREE.Color(pv_value /*"rgb(0, 0, 255)"*/); // RGB-синий


                    //lv_color_hex = this.common_func.rgbToNumber(pv_value);//17032025 
                    ////lo_color_rgb = color;

                    //lo_color_rgb


                    if (lo_active_side.my_prefix == gc_id_prefix_end) { //"end_shape"

                        let lo_handled_cell = go_end_side_shape_generator.end_shape.set_color_to_selected_rectangle_cells(pv_value);

                        if (lo_handled_cell == null) {
                            return;
                        }

                        // Установка цвета фигуры на сторонах, если есть нулевая ячейка на конце

                        if (lo_handled_cell.cell_num_row == 0) {

                            // Установка цвета фигур верхней стороны
                            if (lo_handled_cell.cell_num_col == 0) {
                                lv_num_spline_left = null;
                                lv_num_spline_right = 0;
                            }
                            if (lo_handled_cell.cell_num_col > 0) {
                                lv_num_spline_left = lo_handled_cell.cell_num_col - 1;
                                lv_num_spline_right = lo_handled_cell.cell_num_col;
                            }

                            lar_splines_order = go_up_side_shape_generator.shapes.SortSplinesOrderFromLeftToRight();

                            lo_spline_left = go_up_side_shape_generator.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_left);
                            lo_spline_right = go_up_side_shape_generator.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_right);
                            go_up_side_shape_generator.shapes.draw_contour_and_shape(lo_color_rgb, lo_spline_left, lo_spline_right, false, true, false, true);
                        }

                        //05012025 if (lo_handled_cell.cell_num_col == 0) {

                        let lv_ncol_max = go_end_side_shape_generator.end_shape.ColorParts[0].length - 1;
                        if (lo_handled_cell.cell_num_col == lv_ncol_max) {

                            // Установка цвета фигур боковой стороны
                            if (lo_handled_cell.cell_num_row == 0) {

                                lv_num_spline_left = null;
                                lv_num_spline_right = 0;
                                //lv_num_spline_left = lv_ncol_max;
                                //lv_num_spline_right = null;


                            }
                            if (lo_handled_cell.cell_num_row > 0) {
                                //if (lo_handled_cell.cell_num_row < lv_ncol_max) {
                                lv_num_spline_left = lo_handled_cell.cell_num_row - 1;
                                lv_num_spline_right = lo_handled_cell.cell_num_row;
                            }

                            lar_splines_order = go_lateral_side_shape_generator.shapes.SortSplinesOrderFromLeftToRight();

                            lo_spline_left = go_lateral_side_shape_generator.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_left);
                            lo_spline_right = go_lateral_side_shape_generator.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_right);
                            go_lateral_side_shape_generator.shapes.draw_contour_and_shape(lo_color_rgb, lo_spline_left, lo_spline_right, false, true, false, true);
                        }

                        break;
                    } //"end_shape"


                    if (lo_active_side.group_contours.userData) {

                        if (lo_active_side.group_contours.userData.num_spline_left != null || lo_active_side.group_contours.userData.num_spline_right != null) {

                            lar_splines_order = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();
                            lv_num_spline_left = lo_active_side.group_contours.userData.num_spline_left;
                            lv_num_spline_right = lo_active_side.group_contours.userData.num_spline_right;
                            lo_spline_left = lo_active_side.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_left);
                            lo_spline_right = lo_active_side.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_right);
                            lo_active_side.shapes.draw_contour_and_shape(lo_color_rgb, lo_spline_left, lo_spline_right, false, true, false, true);


                            //19012025 {
                            // если для верхней стороны выделена самая правая фигура - 
                            // красим в тот же цвет верхнюю фигуру на боковой стороне
                            if (lo_active_side == go_up_side_shape_generator) {

                                if (lo_spline_left !== null && lo_spline_right == null) {

                                    lar_splines_order2 = go_lateral_side_shape_generator.shapes.SortSplinesOrderFromLeftToRight();
                                    //lv_num_spline_left2 = null;
                                    //lv_num_spline_right2 = 1;
                                    lo_spline_left2 = null;
                                    lo_spline_right2 = go_lateral_side_shape_generator.common_func.getSplineByNumber(lar_splines_order2, 0);
                                    go_lateral_side_shape_generator.shapes.draw_contour_and_shape(lo_color_rgb, lo_spline_left2, lo_spline_right2, false, true, false, true);

                                }

                            }

                            // если для боковой стороны выделена самая левая фигура - 
                            // красим в тот же цвет правую фигуру на верхней стороне
                            if (lo_active_side == go_lateral_side_shape_generator) {

                                if (lo_spline_left == null && lo_spline_right !== null) {

                                    lar_splines_order2 = go_up_side_shape_generator.shapes.SortSplinesOrderFromLeftToRight();
                                    lv_num_spline_left2 = go_up_side_shape_generator.shapes.ar_splines.length - 1;
                                    //lv_num_spline_right2 = 1;
                                    lo_spline_left2 = go_up_side_shape_generator.common_func.getSplineByNumber(lar_splines_order2, lv_num_spline_left2);
                                    lo_spline_right2 = null;
                                    go_up_side_shape_generator.shapes.draw_contour_and_shape(lo_color_rgb, lo_spline_left2, lo_spline_right2, false, true, false, true);

                                }

                            }
                            //19012025 }


                            // установка цвета ячейки на торце
                            let lv_cell_num_row = 0;
                            let lv_cell_num_col = 0;

                            let lv_num_cell = 0;

                            if (lv_num_spline_left == null) {

                                lv_num_cell = 0;
                            }
                            else {

                                lv_num_cell = lv_num_spline_left + 1;

                            }


                            switch (lo_active_side.my_prefix) {

                                case gc_id_prefix_up:
                                    lv_cell_num_row = 0;
                                    lv_cell_num_col = lv_num_cell;// + 1;
                                    break;

                                case gc_id_prefix_lateral:
                                    lv_cell_num_row = lv_num_cell;// + 1;
                                    //05012025 lv_cell_num_col = 0;
                                    lv_cell_num_col = go_end_side_shape_generator.end_shape.ColorParts[0].length - 1; //05012025

                                    break;
                            }

                            //17032025 go_end_side_shape_generator.end_shape.set_color_to_rectangle_cell(lo_color_rgb, lv_cell_num_row, lv_cell_num_col);
                            go_end_side_shape_generator.end_shape.set_color_to_rectangle_cell(pv_value, lv_cell_num_row, lv_cell_num_col);//17032025
                            //go_end_side_shape_generator.end_shape.set_color_to_rectangle_cell(lv_color_hex, lv_cell_num_row, lv_cell_num_col);//17032025


                        }
                    }

                    break;
                } // while true


                lo_active_side.render();

            }
            catch (e) { //21122024

                alert('error onColorChange: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.onFinishChange_param = function (pv_value) {


            let lo_active_side = get_active_side_shape_generator();


            if (lo_active_side.is_big_window) {
                $(lo_active_side.id_prefix + "id_shg_right_top").draggable("enable");//22062024
                $(lo_active_side.id_prefix + lo_active_side.id_side_shape_mod).draggable("enable");//26082024

            }

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.onChange_shape_height = function (pv_value) {

            let lo_active_side = get_active_side_shape_generator();
            let lo_passive_side = get_passive_side_shape_generator();

            //30102024 {
            if (lo_active_side.shapes == null) {
                return;
            }

            if (lo_passive_side.shapes == null) {
                return;
            }
            //30102024 }

            //30102024 if (lo_passive_side) {
            if (typeof lo_passive_side.gui != "undefined" && lo_passive_side.gui) {
                lo_passive_side.params.shape_height = pv_value;
                CommonFunc.prototype.guiUpdateDisplay(lo_passive_side.gui);
                lo_passive_side.adjust_splines_by_shape_in_side(lo_passive_side, pv_value);
            }

            //}


            if (lo_active_side.is_big_window) {
                $(lo_active_side.id_prefix + "id_shg_right_top").draggable("disable");
                $(lo_active_side.id_prefix + lo_active_side.id_side_shape_mod).draggable("disable");

            }


            lo_active_side.params.shape_height = pv_value;
            CommonFunc.prototype.guiUpdateDisplay(lo_active_side.gui);

            //if (lo_active_side.params.is_space_adjust) {
            lo_active_side.adjust_splines_by_shape_in_side(lo_active_side, pv_value);
            //}

            //27112024 lo_active_side.model_params_changed = true; // признак изменения параметров модели

            //03012025 {
            ////go_end_side_shape_generator.end_shape.redraw_end_shape(
            ////    this,       //this.main,
            ////    null, null, //pv_added_spline_num, pv_deleted_spline_num,
            ////    null, null  //po_is_use_data, po_sides_data
            ////);
            //03012025 }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onChange_shape_width = function (pv_value) {

            let lo_active_side = get_active_side_shape_generator();
            let lo_passive_side = get_passive_side_shape_generator();

            if (lo_active_side.shapes == null) {
                return;
            }

            if (lo_passive_side.shapes == null) {
                return;
            }

            //05112024 let lv_scale = pv_value / lo_active_side.params.shape_width_beg;
            let lv_scale = pv_value / lo_active_side.rectangle.shape_width;

            //06122024 {
            ////// закомментировано - при изменении ширины одной стороны ширина другой не меняется
            ////if (lo_passive_side) {

            ////    if (typeof lo_passive_side.gui !== "undefined" && lo_passive_side.gui) {
            ////        lo_passive_side.params.shape_width = pv_value;
            ////        CommonFunc.prototype.guiUpdateDisplay(lo_passive_side.gui);

            ////        lo_passive_side.rectangle.shape.scale.x = lv_scale;
            ////        lo_passive_side.render();
            ////        if (lo_active_side.params.is_space_adjust) {
            ////            lo_passive_side.shapes.adjust_splines_by_external_shape();
            ////        }


            ////    }

            ////}
            //06122024 }


            if (lo_active_side.is_big_window) {
                $(lo_active_side.id_prefix + "id_shg_right_top").draggable("disable");//22062024
                $(lo_active_side.id_prefix + lo_active_side.id_side_shape_mod).draggable("disable");//26082024

            }

            lo_active_side.params.shape_width = pv_value;
            CommonFunc.prototype.guiUpdateDisplay(lo_active_side.gui);

            lo_active_side.rectangle.shape.scale.x = lv_scale;
            //13122024 lo_active_side.render();


            if (lo_active_side.params.is_space_adjust) {
                lo_active_side.shapes.adjust_splines_by_external_shape();
                /////////lo_active_side.adjust_splines_by_shape_in_side(lo_active_side, pv_value);

            }


            //27112024 lo_active_side.model_params_changed = true; // признак изменения данных модели

            //03012025 {
            ////go_end_side_shape_generator.end_shape.redraw_end_shape(
            ////    this,       //this.main,
            ////    null, null, //pv_added_spline_num, pv_deleted_spline_num,
            ////    null, null  //po_is_use_data, po_sides_data
            ////);
            //03012025 }


            lo_active_side.render(); //13122024

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.ondblclick_id_shape = function (po_event) {


            try {

                let lo_active_side = get_active_side_shape_generator();


                let lv_id_str; // = lo_active_side.id_prefix + lo_active_side.id_side_shape;
                let lv_id_gui = lo_active_side.id_prefix + lo_active_side.id_gui;

                let lv_id_shape_mod = lo_active_side.id_prefix + lo_active_side.id_side_shape_mod;


                //let lv_shg_common_width = $(lv_id_str).width();


                let lv_side_shape1 = /*"div#" + */ gc_id_prefix_up + "_" + lo_active_side.id_side_shape;
                let lv_side_shape2 = /*"div#" + */ gc_id_prefix_lateral + "_" + lo_active_side.id_side_shape;


                let lv_side_shape_mod1 = /*"div#" +*/ gc_id_prefix_up + "_" + lo_active_side.id_side_shape_mod;
                let lv_side_shape_mod2 = /*"div#" +*/ gc_id_prefix_lateral + "_" + lo_active_side.id_side_shape_mod;


                let lv_prev_width;
                let lv_prev_height;
                let lv_prev_top;
                let lv_prev_left;
                let lv_offset;
                let lv_delta_top;

                switch (po_event.currentTarget.id) {

                    case lv_side_shape1:
                    case lv_side_shape2:

                        lv_id_str = lo_active_side.id_prefix + lo_active_side.id_side_shape;
                        lv_prev_width = lo_active_side.common_prev_width;
                        lv_prev_height = lo_active_side.common_prev_height
                        lv_offset = lo_active_side.offset;
                        lv_prev_top = lo_active_side.prev_top;
                        lv_prev_left = lo_active_side.prev_left;
                        lv_delta_top = 0;



                        break;

                    case lv_side_shape_mod1:
                    case lv_side_shape_mod2:

                        lv_id_str = lo_active_side.id_prefix + lo_active_side.id_side_shape_mod;
                        lv_prev_width = lo_active_side.prev_width_mod;
                        lv_prev_height = lo_active_side.prev_height_mod;
                        lv_offset = lo_active_side.offset_mod;
                        lv_prev_top = lo_active_side.prev_top_mod;
                        lv_prev_left = lo_active_side.prev_left_mod;
                        lv_delta_top = lo_active_side.prev_offsetTop_mod;

                        break;


                    default:
                    // code block
                }


                let lv_shg_common_width = $(lv_id_str).width();




                //25082024 if ((lv_shg_common_width >= lo_active_side.common_prev_width - 10) && (lv_shg_common_width <= lo_active_side.common_prev_width + 10)) {
                if ((lv_shg_common_width >= lv_prev_width - 10) && (lv_shg_common_width <= lv_prev_width + 10)) {

                    lo_active_side.prev_height_mod = $(lv_id_shape_mod).height();




                    lo_active_side.is_big_window = true;

                    $(lv_id_str).width(window.innerWidth);
                    $(lv_id_str).height(window.innerHeight);
                    $(lv_id_str).offset({ top: 0, left: 0 });

                    //$(lo_active_side.id_prefix + "id_shg_right").draggable("enable");
                    $(lo_active_side.id_prefix + "id_shg_right_top").draggable("enable");
                    //$(lo_active_side.id_prefix + lo_active_side.id_side_shape_mod).draggable("enable");//26082024

                    if (lv_id_str !== lv_id_shape_mod) {
                        $(lv_id_shape_mod).draggable("enable");//26082024
                    }
                }
                else {

                    lo_active_side.is_big_window = false;

                    //25082024 {
                    ////$(lv_id_str).width(lo_active_side.common_prev_width);
                    ////$(lv_id_str).height(lo_active_side.common_prev_height + 3);
                    ////$(lv_id_str).offset({ top: lo_active_side.prev_top, left: lo_active_side.prev_left /*- 10*/ });




                    $(lv_id_str).width(lv_prev_width);
                    $(lv_id_str).height(lv_prev_height + 3);
                    $(lv_id_str).offset({ top: lv_prev_top + lv_delta_top, left: lv_prev_left });


                    // восстановление положения инструментальной панели gui
                    // запрещение перемещения инструментальной панели

                    //$(lo_active_side.id_prefix + "id_shg_right").draggable("disable");//22062024
                    $(lo_active_side.id_prefix + "id_shg_right_top").draggable("disable");//22062024

                    //$(lo_active_side.id_prefix + lo_active_side.id_side_shape_mod).draggable("disable");//26082024
                    $(lv_id_shape_mod).draggable("disable");//26082024


                    $(lv_id_gui).css("top", 0);
                    $(lv_id_gui).css("left", 0);


                    $(lv_id_shape_mod).css("top", 0);  //26082024
                    $(lv_id_shape_mod).css("left", 0); //26082024


                    //25082024 }

                    //////// восстановление положения инструментальной панели gui
                    ////////$(lo_active_side.id_prefix + "id_shg_right").draggable("disable");//22062024
                    //////$(lo_active_side.id_prefix + "id_shg_right_top").draggable("disable");//22062024
                    //////$(lv_id_gui).css("top", 0);
                    //////$(lv_id_gui).css("left", 0);


                }

                lo_active_side.onWindowResize();

            }

            catch (e) {

                alert('error ondblclick_id_shape: ' + e.stack);

            }

            return false;
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.onWindowResize = function () {

            let lo_active_side = get_active_side_shape_generator();

            //if (lo_active_side.my_prefix != gc_id_prefix_end) { // 06122024


            lo_active_side.aspect = lo_active_side.container.clientWidth / lo_active_side.container.clientHeight;
            lo_active_side.renderer.setSize(lo_active_side.container.clientWidth, lo_active_side.container.clientHeight);
            lo_active_side.camera.aspect = lo_active_side.container.clientWidth / lo_active_side.container.clientHeight;
            lo_active_side.camera.updateProjectionMatrix();
            lo_active_side.render();


            //11012025 { if (lo_active_side.my_prefix != gc_id_prefix_end) { // 06122024
            if (lo_active_side.my_prefix == gc_id_prefix_up || lo_active_side.my_prefix == gc_id_prefix_lateral) { // 11012025

                lo_active_side.aspect_mod = lo_active_side.container_mod.clientWidth / lo_active_side.container_mod.clientHeight;
                lo_active_side.renderer_mod.setSize(lo_active_side.container_mod.clientWidth, lo_active_side.container_mod.clientHeight);
                lo_active_side.camera_mod.aspect = lo_active_side.container_mod.clientWidth / lo_active_side.container_mod.clientHeight;
                lo_active_side.camera_mod.updateProjectionMatrix();
                lo_active_side.render_mod();

            }


        }
        //////------------------------------------------------------------------------
        ////Shape_generator.prototype.onChangeCurvesCount = function (po_event, pv_value) {

        ////	go_shape_generator.shapes.redraw_splines_by_count(pv_value);

        ////}
        //////------------------------------------------------------------------------
        ////Shape_generator.prototype.onChangeInputCurvesCount = function (po_event, pv_value) {

        ////	let lv_curves_count = $("#id_CurvesCount")[0].value;
        ////	go_shape_generator.shapes.redraw_splines_by_count(lv_curves_count);

        ////}


        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_del_spline = function () {

            let lo_active_side = get_active_side_shape_generator();
            lo_active_side.shapes.delete_splines();

        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_chb_space_adjust = function (po_event, pv_value) {

            let lo_active_side = get_active_side_shape_generator();
            lo_active_side.params.is_space_adjust = $(lo_active_side.id_prefix + "id_chb_space_adjust")[0].checked;//08052024
            lo_active_side.shapes.adjust_splines_by_external_shape();

            //27112024 lo_active_side.model_params_changed = true; // признак изменения параметров модели
            lo_active_side.render(); //13122024 
        }
        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_chb_curve_width_adjust = function (po_event, pv_value) {

            let lo_active_side = get_active_side_shape_generator();
            lo_active_side.params.is_curve_width_adjust = $(lo_active_side.id_prefix + "id_chb_curve_width_adjust")[0].checked;
            //27112024 lo_active_side.model_params_changed = true; // признак изменения параметров модели

        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_chb_show_text_labels = function (po_event, pv_value) {


            try {

                let lo_active_side = get_active_side_shape_generator();

                let lv_is_show_text_labels = $(lo_active_side.id_prefix + "id_chb_show_text_labels")[0].checked;//08052024

                lo_active_side.params.is_show_text_labels = lv_is_show_text_labels;

                go_end_side_shape_generator.end_shape.set_show_text_labels(lv_is_show_text_labels);

                //27112024 lo_active_side.model_params_changed = true; // признак изменения параметров модели
                lo_active_side.render(); //13122024

            }

            catch (e) {

                alert('error onclick_chb_show_text_labels: ' + e.stack);

            }

        }

        //------------------------------------------------------------------------
        // Изменение количества сегментов в выделенной кривой
        Shape_generator.prototype.onclick_but_change_segments_amount = function () {

            try {


                let lo_active_side = get_active_side_shape_generator();


                let lar_deleted_splines_beg_x = lo_active_side.shapes.do_delete_splines();



                let lv_is_random_segmets = false; // признак формирования случайных сегментов
                let lv_needed_segments_amount = lo_active_side.inc_spline_segments_amount();// увеличение количества создаваемых сегментов
                let lo_segment_transform_data = lo_active_side.segments.get_segment_transform_data(lo_active_side.params.ajust_curves_by_shape, lv_needed_segments_amount);


                for (let lv_spline_offset_x of lar_deleted_splines_beg_x) {

                    lo_active_side.shapes.add_spline(lo_segment_transform_data, lv_spline_offset_x, lv_needed_segments_amount, lv_is_random_segmets);

                }

                go_end_side_shape_generator.end_shape.redraw_end_shape(
                    lo_active_side,
                    lo_active_side.shapes.shape_amount_curves - 1, null,    //pv_added_spline_num, pv_deleted_spline_num,
                    null, null                                              //po_is_use_data, po_sides_data
                );

                go_end_side_shape_generator.end_shape.appending_texts_array(lo_active_side.shapes.shape_amount_curves + 1);//10022025

                lo_active_side.render();


            }
            catch (e) {

                alert('error onclick_add_spline: ' + e.stack);

            }
        }




        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_add_spline = function () {

            try {

                let lo_active_side = get_active_side_shape_generator();
                lo_active_side.shapes.add_spline(lo_active_side.segment_transform_data);

                go_end_side_shape_generator.end_shape.redraw_end_shape(
                    lo_active_side,
                    lo_active_side.shapes.shape_amount_curves - 1, null,    //pv_added_spline_num, pv_deleted_spline_num,
                    null, null                                              //po_is_use_data, po_sides_data
                );

                //27112024 lo_active_side.model_params_changed = true; // признак изменения параметров модели

                go_end_side_shape_generator.end_shape.appending_texts_array(lo_active_side.shapes.shape_amount_curves + 1);//10022025

                lo_active_side.render(); //28122024

            }

            catch (e) {

                alert('error onclick_add_spline: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_read_model = function () {


            try {

                let lo_active_side = get_active_side_shape_generator();
                //////////////////////lo_active_side_shape_generator.common_func.save_model(lo_active_side_shape_generator.scene);



                //////////////////////// Перевод фокуса для убирания подсказки кнопки
                //////////////////////$("#id_name_block_settings")[0].focus();// 01082023



                //////////////////////my_main.Set_button_new_set_pressed(false);// Сброс режима создания нового набора настроек
                //////////////////////my_main.Set_button_choice_set_pressed(true);// Установка режима выбора существующих настроек


                //////////////////////$("#id_div_GridSelectBlockSettings").show();


                var lv_path = "/Index?handler=ReadListModels"; //11092022
                lo_active_side.grid_select_models.$grid.jqGrid('setGridParam', { url: lv_path, datatype: 'json' }).trigger("reloadGrid");
                /////////////////////////////////$("#id_div_GridSelectModels").slideToggle(300);

                lo_active_side.grid_select_models.$div_grid.dialog("open");

                return false;



                //// test !!

                //let lo_active_side = get_active_side_shape_generator();
                //lo_active_side.common_func.build_scenes_by_sides_data(null);


            }

            catch (e) {

                alert('error onclick_read_model: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_new_model = function () {


            try {

                let lo_active_side = get_active_side_shape_generator();

                lo_active_side.load_initial_model();

            }

            catch (e) {

                alert('error onclick_read_model: ' + e.stack);

            }
        }
        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_save_model = function () {


            try {

                let lo_active_side = get_active_side_shape_generator();

                let lv_filename = $("#id_model_name").val();
                lo_active_side.common_func.check_file_exist_on_server(lv_filename, lo_active_side.oncomplete_check_file_exist_on_server);


                ////////////////////////////let lo_sides_data = lo_active_side.read_model_sides_data();
                ////////////////////////////let lo_scene_mod = lo_active_side.scene_mod;
                ////////////////////////////lo_active_side.common_func.save_model(lo_sides_data, lo_scene_mod);


            }

            catch (e) {

                alert('error onclick_save_model: ' + e.stack);

            }
        }
        //------------------------------------------------------------------------
        Shape_generator.prototype.oncomplete_check_file_exist_on_server = async function (pv_is_file_exist) {

            try {

                let lo_active_side = get_active_side_shape_generator();

                if (pv_is_file_exist == Constants.true) {

                    if (lo_active_side.is_ask_about_save_file) {

                        await lo_active_side.do_save_model();

                    }

                    else {

                        let lv_question = "File \"" + $("#id_model_name").val() + "\" already exists. Replace it?";

                        lo_active_side.common_func.show_question(lv_question,

                            async function () {

                                await lo_active_side.do_save_model();
                                ////lo_active_side.is_ask_about_save_file = true;
                                ////lo_active_side.is_model_changed = false;

                                ////let lo_sides_data = lo_active_side.read_model_sides_data();
                                ////let lo_scene_mod = lo_active_side.scene_mod;
                                ////lo_active_side.common_func.save_model(lo_sides_data, lo_scene_mod);


                                $(this).dialog("close");
                            },
                            function () { $(this).dialog("close"); }, null);

                    }
                }
                else {

                    await lo_active_side.do_save_model();

                }

            }


            catch (e) {

                alert('error oncomplete_check_file_exist_on_server: ' + e.stack);

            }
        }


        //27112024 {
        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_refresh_model = function () {

            //30112024 {

            let lo_active_side = get_active_side_shape_generator();
            ////lo_active_side.model_params_changed = true;

            lo_active_side.refreshModel();

            //30112024 }


        }
        //27112024 }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onclick_make_model = function () {

            let lo_active_side_shape_generator = get_active_side_shape_generator();
            lo_active_side_shape_generator.make_model();

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onChange_distance_bt_curves = function () {

        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.onmousemove = function (po_event) {

            let lo_active_side;



            try {

                lo_active_side = get_active_side_shape_generator();

                if (!lo_active_side) {
                    return;
                }


                if (lo_active_side.shapes == null) {
                    return;
                }
                if (lo_active_side.shapes.ar_splines_nodes == null) {
                    return;
                }



                //25072024 {
                //if (po_event.button != 0) {
                lo_active_side.is_gragging = true;
                //}
                //25072024 }



                //let lar_findresult;

                lo_active_side.container.style.cursor = "default";

                if (lo_active_side.button_down) {

                    //@@if (lo_active_side_shape_generator.draggableObject) {


                    //1807202 lo_active_side_shape_generator.was_draggable = true;


                    lo_active_side.container.style.cursor = "pointer";

                    let lo_pos = lo_active_side.common_func.recalc_coord_event2world(lo_active_side.camera, lo_active_side.container, event.clientX, event.clientY);

                    if (lo_pos == null) //03092024 
                    {
                        return;
                    }




                    while (true) {

                        //28072004
                        if (typeof lo_active_side.draggableObject == "undefined"
                            || lo_active_side.draggableObject == null) {
                            break;
                        }



                        if (lo_active_side.draggableObject.geometry.type == "LineGeometry") {

                            //06012025 {
                            ////// двигаем параллелепипед 

                            ////lo_active_side_shape_generator.container.style.cursor = "pointer";
                            ////lo_active_side_shape_generator.draggableObject.position.x = lo_pos.x + lo_active_side_shape_generator.delta_rect_drag_x;
                            ////lo_active_side_shape_generator.draggableObject.position.y = lo_pos.y + lo_active_side_shape_generator.delta_rect_drag_y;

                            ////lo_active_side_shape_generator.render();
                            //06012025 }

                            break;
                        }



                        let lar_spline_points = lo_active_side.shapes.get_spline_points(lo_active_side.draggableObject.parent.parent);

                        if (lo_active_side.draggableObject.geometry.type == "BoxGeometry") {
                            // Выделен один из крайних (квадратных) узлов, двигаем всю кривую (сплайн)

                            let lv_delta_x = lo_pos.x - lo_active_side.draggableObject.position.x;

                            for (let lv_i = 0; lv_i < lar_spline_points.length; lv_i++) {
                                lar_spline_points[lv_i].x = lar_spline_points[lv_i].x + lv_delta_x;
                            }

                            lo_active_side.container.style.cursor = "ew-resize";

                            ////05012025 {
                            let lar_splines_order = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();
                            lo_active_side.shapes.redraw_meshes_color(lar_splines_order);
                            ////05012025 }

                        }

                        if (lo_active_side.draggableObject.geometry.type == "CircleGeometry") {

                            // Выделен один из остальных узлов, двигаем один узел
                            lo_active_side.draggableObject.position.x = lo_pos.x;
                            lo_active_side.draggableObject.position.y = lo_pos.y;

                        } // CircleGeometry


                        // Удаление предыдущих линий
                        let lar_lines = lo_active_side.shapes.get_lines_in_group(lo_active_side.draggableObject.parent.parent);
                        for (let lv_i = 0; lv_i < lar_lines.length; lv_i++) {
                            lo_active_side.common_func.removeObjectsWithChildren(lar_lines[lv_i], true);
                        }

                        // Перерисовка сегментов
                        lo_active_side.shapes.redraw_segments(lo_active_side.draggableObject.parent.parent);


                        lo_active_side.splines.draw_curve(lo_active_side.draggableObject.parent.parent, lar_spline_points, lo_active_side.splines.name_prefix, true);
                        lo_active_side.render();

                        break;

                    }// while

                    //@@}// draggableObject

                } //button down

                else {
                    // no button down

                    lo_active_side.container.style.cursor = "default";

                    // Формирование курсора мыши
                    while (true) {

                        let { top, left, width, height } = lo_active_side.container.getBoundingClientRect();
                        let lv_clickMouse = new THREE.Vector2();
                        lv_clickMouse.x = ((event.clientX - left) / width) * 2 - 1;
                        lv_clickMouse.y = - ((event.clientY - top) / height) * 2 + 1;

                        let lo_raycaster = new THREE.Raycaster();
                        lo_raycaster.setFromCamera(lv_clickMouse, lo_active_side.camera);

                        let lo_found;

                        lo_found = lo_raycaster.intersectObjects(lo_active_side.shapes.ar_splines_nodes, true);

                        if (lo_found.length) {

                            // Сплайн

                            let lo_object = lo_found[0].object;

                            if (lo_object.visible) {

                                if (lo_object.geometry.type == "BoxGeometry") {
                                    // Выделен один из крайних узлов, двигаем всю кривую (сплайн)
                                    lo_active_side.container.style.cursor = "ew-resize";
                                }

                                if (lo_object.geometry.type == "CircleGeometry") {
                                    // Выделен не крайний узел, двигаем один узел
                                    lo_active_side.container.style.cursor = "pointer";
                                }

                            }

                        }

                        if (lo_active_side.rectangle) {

                            lo_found = lo_raycaster.intersectObjects([lo_active_side.rectangle.shape]);
                            if (lo_found.length) {
                                lo_active_side.container.style.cursor = 'default';// "pointer";
                                break;
                            }
                        }


                        break;

                    }// while

                } //lo_active_side_shape_generator.button_down


            }// try

            catch (e) {

                lo_active_side.container.style.cursor = "default";
                alert('error onmousemove: ' + e.stack);

            }

            //po_event.preventDefault();
            //po_event.stopPropagation();
            //return false;

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onPassInterval = function (po_this) {

            try {

                let lo_passive_side = get_passive_side_shape_generator();

                if (po_this.model_params_changed) {

                    if (!po_this.is_building_model && !lo_passive_side.is_building_model) {

                        po_this.model_params_changed = false;
                        ////19102024 po_this.is_building_model = true;
                        ////19102024 lo_passive_side.is_building_model = true;


                        po_this.refreshModel();

                    }
                }

            }

            catch (e) {

                alert('error onPassInterval: ' + e.stack);

            }
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.onPointerUp = function (po_event) {

            try {
                po_event.stopPropagation();

                let lo_active_side = get_active_side_shape_generator();

                ////07012025 {
                //if (!lo_active_side) {
                //    return;
                //}
                ////07012025 }


                lo_active_side.button_down = false;
                lo_active_side.draggableObject = undefined;


                //16122024 {

                //if (lo_active_side.shapes == null) {
                //    return;
                //}

                //let lar_splines_order = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();//03082024
                //lo_active_side.shapes.redraw_meshes_color(lar_splines_order);//03082024


                if (lo_active_side.my_prefix !== gc_id_prefix_end) {  //15122024



                    if (this.is_shape_gragging)//05012025
                    {

                        if (lo_active_side.shapes == null) {
                            return;
                        }

                        let lar_splines_order = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();//03082024
                        lo_active_side.shapes.redraw_meshes_color(lar_splines_order);//03082024

                        //this.is_shape_gragging = false;//05012025

                        //05012025 {
                        go_end_side_shape_generator.end_shape.redraw_end_shape(
                            null,         //   po_main,
                            null, null,   //   pv_added_spline_num, pv_deleted_spline_num,       
                            null, null    //   po_is_use_data, po_sides_data       
                        );
                        //05012025 }

                        lo_active_side.select_contour_between_slides(po_event/*, this.is_shape_gragging*/); //10032025

                    }
                    //////05012025 }
                }
                else {

                    if (lo_active_side.shapes == null) {
                        return;
                    }

                    let lar_splines_order = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();//03082024
                    lo_active_side.shapes.redraw_meshes_color(lar_splines_order);//03082024
                    //16122024 }

                    //go_end_side_shape_generator.end_shape.refresh_end_shapes(); //22122024


                }

                this.is_shape_gragging = false;//05012025

                lo_active_side.render();

            }

            catch (e) {

                alert('error onPointerUp: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.onPointerDown = function (po_event) {

            let lo_active_side = get_active_side_shape_generator();

            ////07012025 {
            //if (!lo_active_side) {
            //    return;
            //}
            ////07012025 }

            let lv_is_gragging;

            try {

                if (lo_active_side.my_prefix == gc_id_prefix_end) {

                    if (po_event.button == 0 && po_event.buttons == 1) {

                        // Левая кнопка

                        //lo_active_side.button_down = true;
                        lv_is_gragging = false;

                        lo_active_side.end_shape.handle_click_on_end_side(po_event);

                        //po_event.stopPropagation()
                    }

                    return false;
                }




                if (lo_active_side.shapes == null) {
                    return;
                }


                let lo_clicked_spline_and_segment = lo_active_side.shapes.get_splines_and_segment_of_clicked_figure(po_event);


                if (po_event.button == 2 && po_event.buttons == 2) {

                    // Правая кнопка

                    // Выделение сегмента

                    let lo_clicked_spline = lo_clicked_spline_and_segment.spline_right;//13072024
                    let lo_clicked_segment = lo_clicked_spline_and_segment.segment;

                    if (lo_clicked_segment) {
                        lo_active_side.shapes.switch_visible_nodes_by_segment(lo_clicked_segment);
                        //13122024 lo_active_side_shape_generator.render();
                    }

                    return;
                }



                if (po_event.button == 0 && po_event.buttons == 1) {

                    // Левая кнопка

                    let lo_active_side = get_active_side_shape_generator();

                    lo_active_side.button_down = true;


                    lv_is_gragging = false;


                    while (true) {

                        let { top, left, width, height } = lo_active_side.container.getBoundingClientRect();//07052024

                        let lv_clickMouse = new THREE.Vector2();
                        lv_clickMouse.x = ((po_event.clientX - left) / width) * 2 - 1;
                        lv_clickMouse.y = - ((po_event.clientY - top) / height) * 2 + 1;

                        // Определение - щелчок внутри фигуры, или нет
                        if (lo_active_side.rectangle) {

                            let lv_isInside = lo_active_side.common_func.IsInsideRectangle(po_event, lo_active_side.rectangle.shape); //13122024

                            if (!lv_isInside) {
                                return;
                            }

                        }


                        let lo_raycaster = new THREE.Raycaster();
                        lo_raycaster.setFromCamera(lv_clickMouse, lo_active_side.camera);

                        let lo_found;

                        lo_found = lo_raycaster.intersectObjects(lo_active_side.shapes.ar_splines_nodes, true);
                        if (lo_found.length) {

                            // Узел
                            lv_is_gragging = true;

                            lo_active_side.draggableObject = lo_found[0].object;
                            break;
                        }


                        if (lo_active_side.rectangle) {

                            let lo_object = lo_active_side.scene.getObjectByName(lo_active_side.rectangle.shape.name);

                            if (lo_object) {

                                lo_found = lo_raycaster.intersectObjects([lo_active_side.rectangle.shape]); //, true);
                                if (lo_found.length) {

                                    // Прямоугольник
                                    lo_active_side.draggableObject = lo_found[0].object;

                                    let lo_pos = lo_active_side.common_func.recalc_coord_event2world(lo_active_side.camera, lo_active_side.container, po_event.clientX, po_event.clientY);
                                    lo_active_side.delta_rect_drag_x = lo_active_side.draggableObject.position.x - lo_pos.x;
                                    lo_active_side.delta_rect_drag_y = lo_active_side.draggableObject.position.y - lo_pos.y;

                                    lv_is_gragging = true;

                                    break;
                                }
                            }
                        }

                        break;
                    }

                    //------------------------------------------------------------------------------------

                    if (lv_is_gragging) {

                        this.is_shape_gragging = true;//05012025
                        return;
                    }

                    //------------------------------------------------------------------------------------


                    // click

                    //06012025 {
                    ////// Выделение границ фигуры между кривыми

                    ////let lo_clicked_splines_and_segment = lo_active_side.shapes.get_splines_and_segment_of_clicked_figure(po_event);

                    ////let lo_clicked_splines = {
                    ////    spline_left: lo_clicked_splines_and_segment.spline_left,
                    ////    spline_right: lo_clicked_splines_and_segment.spline_right
                    ////};


                    ////let lo_prev_clicked_splines = null; //04122024

                    ////if (lo_active_side.group_contours) { //04122024
                    ////    if (lo_active_side.group_contours.userData) { //04122024

                    ////        lo_prev_clicked_splines = lo_active_side.group_contours.userData;
                    ////    }

                    ////}


                    ////lo_active_side.shapes.clear_group_contours();


                    ////if (lo_active_side.group_contours) { //04122024

                    ////    if (lo_active_side.group_contours.userData == null) {

                    ////        lo_active_side.shapes.select_shape_contour(lo_clicked_splines_and_segment);

                    ////    }
                    ////    else {


                    ////        if (lo_prev_clicked_splines) { //04122024

                    ////            if (lo_clicked_splines.spline_left == lo_prev_clicked_splines.spline_left
                    ////                && lo_clicked_splines.spline_right == lo_prev_clicked_splines.spline_right) {

                    ////                lo_active_side.group_contours.userData = null;
                    ////            }
                    ////            else {
                    ////                lo_active_side.shapes.select_shape_contour(lo_clicked_splines_and_segment);
                    ////            }
                    ////        }
                    ////    }


                    ////}//04122024

                    if (!lv_is_gragging) //10032025 
                    {
                        lo_active_side.select_contour_between_slides(po_event);
                    }


                    // 06012025 }

                    lo_active_side.render();

                }

            }

            catch (e) {

                alert('error onPointerDown: ' + e.stack);

            }


        }



        //-------------------------------------------------------------------
        /*async*/ Shape_generator.prototype.read_result_refresh_premodel = function (po_data) {


            let lo_active_side = get_active_side_shape_generator(); //04102024
            let lo_passive_side = get_passive_side_shape_generator(); //04102024

            try {

                lo_active_side.progress_bar.set_display_value(51);


                let lv_url = "https://localhost:7095/CalcJBModel?method="
                    + Constants.method_read_result_refresh_premodel
                    + "&"
                    + Constants.word_client_id + "=" + this.client_id
                    + "&"
                    + Constants.word_task_id + "=" + po_data.task_id
                    + "&"
                    + Constants.path_result_file + "=" + po_data.path_result_file
                    + "&chdata=" + Math.random().toString(); // 23112024



                get_read_result_refresh_premodel(lv_url);


                //--------------------------------------------------
                async function get_read_result_refresh_premodel(pv_url) {
                    //--------------------------------------------------
                    await $.get(pv_url, "", lo_active_side.oncomplete_read_result_refresh_premodel);
                }


            }

            catch (e) {


                lo_active_side.model_params_changed = false; //04102024
                lo_passive_side.model_params_changed = false; //04102024

                let lv_is_before = false;
                lo_active_side.do_before_after_model_request(lv_is_before, false);
                lo_passive_side.do_before_after_model_request(lv_is_before, false);

                alert('error read_result_refresh_premodel: ' + e.stack);

            }

        }

        //}




        //------------------------------------------------------------------------
        Shape_generator.prototype.refreshModel = async function () {

            try {

                let lv_end_watching_progress_value = 50;
                this.progress_bar = new ProgressBar(this, this.client_id, "https://localhost:7095/CalcJBModel", Constants.method_start_refresh_premodel, this.read_result_refresh_premodel, lv_end_watching_progress_value);
                this.progress_bar.task_id = this.common_func.get_random_number_int(1, 9999999999).toString(); //22112024


                this.progress_bar.set_display_value(3);


                let lv_url = "https://localhost:7095/CalcJBModel?method="
                    + Constants.method_start_refresh_premodel
                    + "&"
                    + Constants.word_client_id + "=" + this.client_id
                    + "&"
                    + Constants.word_task_id + "=" + this.progress_bar.task_id
                    + "&chdata=" + Math.random().toString(); // 23112024


                let lo_sides_data = this.read_model_sides_data();
                lo_sides_data.task_id = this.progress_bar.task_id;

                this.send_side_data_for_refresh_model(lv_url, lo_sides_data);


            }

            catch (e) {

                this.model_params_changed = false; //29082024

                alert('error refreshModel: ' + e.stack);

            }
        }




        //------------------------------------------------------------------------
        Shape_generator.prototype.reset_gui_parameters = function () {


            try {

                if (this.gui) {
                    this.gui.close();
                    this.gui.destroy();
                }

                this.gui = null;

                this.gui = new GUI({ container: document.getElementById(this.id_prefix_wo_sharp + 'id_gui') });

                this.gui.add(this.params, 'distance_bt_curves', 0, 40).step(0.5).name('Distance  between curves').onChange(this.onChange_distance_bt_curves).listen();//05112024
                this.gui.add(this.params, 'shape_height', 20, 200).step(0.5).name('Shape length').onChange(this.onChange_shape_height).onFinishChange(this.onFinishChange_param).listen();//05112024
                this.gui.add(this.params, 'shape_width', 10, 100).step(0.5).name('Shape width').onChange(this.onChange_shape_width).onFinishChange(this.onFinishChange_param).listen();//05112024

                //this.gui.addColor(this.params, 'color').name('Color');

                this.gui.open();

            }

            catch (e) {

                alert('error reset_gui_parameters: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.render = function () {

            try {

                let lo_active_side = get_active_side_shape_generator();

                if (lo_active_side) {

                    lo_active_side.renderer.render(
                        lo_active_side.scene,
                        lo_active_side.camera);

                }

            }

            catch (e) {

                alert('error render: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.render_mod = function () {

            try {

                let lo_active_side = get_active_side_shape_generator();

                //07012025 {
                if (!lo_active_side) {
                    return;
                }
                //07012025 }

                if (lo_active_side.my_prefix != gc_id_prefix_end) { // 06122024


                    if (lo_active_side) {

                        lo_active_side.common_func.model_rotation(lo_active_side.group_parts_mod);

                        lo_active_side.renderer_mod.render(lo_active_side.scene_mod, lo_active_side.camera_mod);



                    }
                }
            }

            catch (e) {

                alert('error render_mod: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.reset_event_handlers = function (po_side) {

            try {

                //let lo_active_side_shape_generator = get_active_side_shape_generator();
                //let lo_passive_side_shape_generator = get_passive_side_shape_generator();

                $(document).off('click  change pointerdown pointerup pointermove');//17062024
                $(window).off('resize dblclick doubleclick mousemove');
                $(window).off('resize dblclick doubleclick mousemove');
                $(window).off('resize dblclick doubleclick mousemove');

                $(document).unbind('click change pointerdown pointerup pointermove');//17062024
                $(window).unbind('resize dblclick mousemove');

                if (po_side) {

                    if (po_side.controls) {

                        if (po_side.render) {
                            po_side.controls.removeEventListener('change', po_side.render);// очистка обработчика событий
                        }
                    }

                    //if (this.render) {
                    //    po_side.controls.removeEventListener('change', this.render);// очистка обработчика событий
                    //}

                }

                //if (po_side.controls) {
                //    po_side.controls.addEventListener('change', po_side.render);
                //}


                // очистка обработчиков событий
                $(this.passive_id_prefix + "id_but_read_model").off("click");
                $(this.passive_id_prefix + "id_but_new_model").off("click");
                $(this.passive_id_prefix + "id_but_refresh").off("click");
                $(this.passive_id_prefix + "id_chb_space_adjust").off("click");
                $(this.passive_id_prefix + "id_chb_curve_width_adjust").off("click");
                $(this.passive_id_prefix + "id_but_del_spline").off("click");
                $(this.passive_id_prefix + "id_but_add_spline").off("click");
                $(this.passive_id_prefix + "id_but_save_model").off("click");
                $(this.passive_id_prefix + "id_but_make_model").off("click");
                $(this.passive_id_prefix + "id_but_set_color").off("click");
                $(this.passive_id_prefix + "id_but_rotate_mode").off("click");
                $(this.passive_id_prefix + "id_but_ch_nsegm").off("click");



                //$(this.id_prefix + "id_chb_space_adjust").off("click").click(this.onclick_chb_space_adjust);
                //$(this.id_prefix + "id_chb_curve_width_adjust").off("click").click(this.onclick_chb_curve_width_adjust);

                //$(this.id_prefix + "id_but_read_model").off("click").click(this.onclick_read_model);

                //$(this.id_prefix + "id_but_del_spline").off("click").click(this.onclick_del_spline);
                //$(this.id_prefix + "id_but_add_spline").off("click").click(this.onclick_add_spline);
                //$(this.id_prefix + "id_but_save_model").off("click").click(this.onclick_save_model);
                //$(this.id_prefix + "id_but_make_model").off("click").click(this.onclick_make_model);
                //$(this.id_prefix + "id_but_set_color").off("click").click(this.onclick_id_but_set_color);
                //$(this.id_prefix + "id_but_rotate_mode").off("click").click(this.onclick_id_but_rotate_mode);

                //$(this.id_prefix + "id_but_refresh").off("click").click(this.onclick_refresh_model);

                //$(this.id_prefix + this.id_side_shape).off("dblclick").dblclick(this.ondblclick_id_shape);//17062024
                //$(this.id_prefix + this.id_side_shape_mod).off("dblclick").dblclick(this.ondblclick_id_shape);//25082024
                //$(this.id_prefix + this.id_side_shape).dblclick(null);
                //$(this.id_prefix + this.id_side_shape_mod).dblclick(null);//25082024

                //--------------------------------------------------------------------------------------------

                ////// обработчики событий gui


                //}
                //--------------------------------------------------------------------------------------------


                // очистка обработчиков событий
                document.removeEventListener('pointerdown', this.onPointerDown);
                document.removeEventListener('pointerup', this.onPointerUp);
                //document.addEventListener('pointermove', null);
                window.removeEventListener('resize', this.onWindowResize);
                window.removeEventListener('mousemove', this.onmousemove);

                $(this.id_prefix + this.id_side_shape).dblclick(null);//17062024 

                //if (lo_passive_side_shape_generator) {
                //    document.removeEventListener('pointerdown', lo_passive_side_shape_generator.onPointerDown);

                //    document.removeEventListener('pointerup', lo_passive_side_shape_generator.onPointerUp);
                //    //document.addEventListener('pointermove', null);
                //    window.removeEventListener('resize', lo_passive_side_shape_generator.onWindowResize);
                //    window.removeEventListener('mousemove', lo_passive_side_shape_generator.onmousemove);

                //    $(this.id_prefix + this.id_side_shape).off("dblclick").dblclick(lo_passive_side_shape_generator.ondblclick_id_shape);//17062024
                //    $(this.id_prefix + this.id_side_shape).dblclick(null);//17062024 

                //}


                if (po_side) {
                    document.removeEventListener('pointerdown', po_side.onPointerDown);
                    document.removeEventListener('pointerup', po_side.onPointerUp);
                    //document.addEventListener('pointermove', null);
                    window.removeEventListener('resize', po_side.onWindowResize);
                    window.removeEventListener('mousemove', po_side.onmousemove);

                }


                //17062024 {




                //document.addEventListener('pointerdown', this.onPointerDown);
                //document.addEventListener('pointerup', this.onPointerUp);
                ////document.addEventListener('pointermove', onPointerMove);
                //window.addEventListener('resize', this.onWindowResize);
                //window.addEventListener('mousemove', this.onmousemove);
                ////////////////////window.addEventListener('dblclick', this.ondblclick_id_shape);//17062024

                ////window.addEventListener('click', window_onclick	);
                //$(this.passive_id_prefix + this.id_side_shape).off("click");
                //$(this.passive_id_prefix + "id_but_mirror").off("click");

                //$(this.id_prefix + this.id_side_shape).off("click").on("click", this.onclick_shape);//17072024 

                //$(this.id_prefix + "id_but_mirror").off("click").on("click", this.but_mirror_onclick);


                ////this.render();//05052024
                //lo_active_side_shape_generator.onWindowResize();//21062024




                // 05012025 this.render_mod();





                ////--------------------------------------------------------------------
                //// наблюдатель за изменением цвета элемента

                //// Создание экземпляра MutationObserver
                //const observer = new MutationObserver(this.common_func.handleColorChange);

                //// Целевой элемент, за которым нужно следить
                //const targetElement = document.getElementById(this.id_prefix_wo_sharp + "id_for_colorpicker");

                //// Параметры наблюдения
                //const config = { attributes: true, attributeFilter: ['style'] };

                //// Начало наблюдения за целевым элементом
                //observer.observe(targetElement, config); //, lf_callback);

                ////--------------------------------------------------------------------


            }
            catch (e) {

                alert('error reset_event_handlers: ' + e.stack);

            }

        }




        //------------------------------------------------------------------------
        Shape_generator.prototype.read_model_sides_data = function () {

            let lo_sides_data = new typ_sides_data();

            try {
                let lo_model_data = new typ_sides_data();

                let lo_up_side_shape_generator = get_side_shape_generator_by_prefix(gc_id_prefix_up);
                let lo_lateral_side_shape_generator = get_side_shape_generator_by_prefix(gc_id_prefix_lateral);

                let lo_active_side_shape = get_active_side_shape_generator();


                ////lo_model_data.colorParts = this.read_color_parts();
                ////lo_model_data.data1 = lo_up_side_shape_generator.read_side_model_data();
                ////lo_model_data.data2 = lo_lateral_side_shape_generator.read_side_model_data();


                lo_sides_data.client_id = lo_active_side_shape.client_id; //21112024 
                //lo_model_data.task_id = "0";


                let lar_colorParts = this.read_color_parts();
                let lar_data1 = lo_up_side_shape_generator.read_side_model_data();
                let lar_data2 = lo_lateral_side_shape_generator.read_side_model_data();

                lo_sides_data.ColorParts = lar_colorParts;
                lo_sides_data.data1 = lar_data1;
                lo_sides_data.data2 = lar_data2;


            }

            catch (e) {

                alert('error read_model_sides_data: ' + e.stack);

            }
            return lo_sides_data;

        }

        //------------------------------------------------------------------------
        Shape_generator.prototype.read_color_parts = function () {

            let lar_ColorParts = [];

            lar_ColorParts = go_end_side_shape_generator.end_shape.ColorParts;

            return lar_ColorParts;

        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.read_side_model_data = function () {

            let lo_side_data = new typ_side_data();


            try {
                let ls_parameters = this.read_side_parameters();

                let lo_splines_points_data = this.shapes.get_splines_points_for_model();


                lo_side_data.parameters = ls_parameters;
                lo_side_data.numCurves = lo_splines_points_data.PointsCurves.length;
                lo_side_data.idMaterial = 0;
                lo_side_data.idSize = 0;
                lo_side_data.Lockedit = false;
                lo_side_data.Fl_manual_parameters = false;
                lo_side_data.M_Material = 0;
                lo_side_data.M_Width = this.params.shape_width;
                lo_side_data.M_Height = this.params.shape_width;
                lo_side_data.M_Length = this.params.shape_height;
                lo_side_data.M_Price_rub = 0.0;
                lo_side_data.Part_gap = 2;
                lo_side_data.CurveColors = [];
                lo_side_data.Segments_beg_points_numbers = lo_splines_points_data.Segments_beg_points_numbers;
                lo_side_data.PointsCurves = lo_splines_points_data.PointsCurves;
                lo_side_data.rectangle_scale_y = this.rectangle.shape.scale.y;







                //return {
                //    parameters: ls_parameters,
                //    numCurves: lar_splines_points.length,
                //    idMaterial: 0,
                //    idSize: 0,
                //    Lockedit: false,
                //    Fl_manual_parameters: false,
                //    M_Material: 0,
                //    M_Width: this.params.shape_width,
                //    M_Height: this.params.shape_width,
                //    M_Length: this.params.shape_height,
                //    M_Price_rub: 0.0,
                //    Part_gap: 2,
                //    CurveColors: [],
                //    Segments_beg_points_numbers: lo_splines_points_data.Segments_beg_points_numbers,
                //    PointsCurves: lo_splines_points_data.PointsCurves,

                //}

            }

            catch (e) {

                alert('error read_side_model_data: ' + e.stack);

            }
            //return lo_sides_data;


            return lo_side_data;
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.read_side_parameters = function () {

            let ls_parameters = new typ_parameters();

            //ls_parameters.is_space_adjust = $(this.id_prefix + "id_chb_space_adjust")[0].checked;
            //ls_parameters.is_curve_width_adjust = $(this.id_prefix + "id_chb_curve_width_adjust")[0].checked;

            //ls_parameters.distance_bt_curves = this.params.distance_bt_curves;
            //ls_parameters.distance_bt_curves_in_percent = this.params.distance_between_curves_in_percent_of_width;
            //ls_parameters.shape_height = this.params.shape_height;
            //ls_parameters.shape_width = this.params.shape_width;


            try {


                ls_parameters.container_width = this.params.container_width;
                ls_parameters.container_height = this.params.container_height;
                ls_parameters.shape_width_beg = this.params.shape_width_beg;
                ls_parameters.shape_width = this.params.shape_width;
                ls_parameters.shape_height_beg = this.params.shape_height_beg;
                ls_parameters.shape_height = this.params.shape_height;
                ls_parameters.shape_amount_curves = this.params.shape_amount_curves;
                ls_parameters.spline_amount_segments = this.params.spline_amount_segments;
                ls_parameters.ajust_curves_by_shape = $(this.id_prefix + "id_chb_space_adjust")[0].checked; //this.params.ajust_curves_by_shape;  
                ls_parameters.ajust_shape_by_curves = $(this.id_prefix + "id_chb_curve_width_adjust")[0].checked; //this.params.ajust_shape_by_curves;

                ls_parameters.is_show_text_labels = $(this.id_prefix + "id_chb_show_text_labels")[0].checked; //this.params.ajust_shape_by_curves;//09022025

                ls_parameters.distance_between_curves_in_percent_of_width = this.params.distance_between_curves_in_percent_of_width;
                ls_parameters.distance_bt_curves = this.params.distance_bt_curves;
                ls_parameters.is_space_adjust = $(this.id_prefix + "id_chb_space_adjust")[0].checked; //this.params.is_space_adjust;       
                ls_parameters.is_curve_width_adjust = $(this.id_prefix + "id_chb_curve_width_adjust")[0].checked; //this.params.is_curve_width_adjust; 
                ls_parameters.color = this.params.color;

            }

            catch (e) {

                alert('error read_side_parameters: ' + e.stack);

            }
            return ls_parameters;
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.select_contour_between_slides = function (po_event/*, pv_is_shape_gragging*/) {


            // Выделение границ фигуры между кривыми

            try {

                let lo_active_side = get_active_side_shape_generator();

                let lo_clicked_splines_and_segment = lo_active_side.shapes.get_splines_and_segment_of_clicked_figure(po_event);

                let lo_clicked_splines = {
                    spline_left: lo_clicked_splines_and_segment.spline_left,
                    spline_right: lo_clicked_splines_and_segment.spline_right
                };


                let lo_prev_clicked_splines = null;

                if (lo_active_side.group_contours) {
                    if (lo_active_side.group_contours.userData) {

                        lo_prev_clicked_splines = lo_active_side.group_contours.userData;
                    }

                }


                lo_active_side.shapes.clear_group_contours();


                if (lo_active_side.group_contours) { //04122024

                    if (lo_active_side.group_contours.userData == null) {

                        lo_active_side.shapes.select_shape_contour(lo_clicked_splines_and_segment/*, pv_is_shape_gragging*/);

                    }
                    else {


                        if (lo_prev_clicked_splines) {

                            if (lo_clicked_splines.spline_left == lo_prev_clicked_splines.spline_left
                                && lo_clicked_splines.spline_right == lo_prev_clicked_splines.spline_right) {

                                lo_active_side.group_contours.userData = null;
                            }
                            else {
                                lo_active_side.shapes.select_shape_contour(lo_clicked_splines_and_segment/*, pv_is_shape_gragging*/);
                            }
                        }
                    }


                }



            }

            catch (e) {

                alert('error select_contour_between_slides: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.send_side_data_for_refresh_model = function (pv_url, po_json_data) {


            try {
                let lv_is_before = true;
                this.do_before_after_model_request(lv_is_before, true);

                send_for_refresh_model(pv_url, po_json_data);

                //-------------------------------------------------------------------
                async function send_for_refresh_model(pv_url, po_json_data) {


                    let lo_active_side = get_active_side_shape_generator(); //04102024
                    let lo_passive_side = get_passive_side_shape_generator(); //04102024

                    try {

                        var lv_for_body = JSON.stringify(po_json_data);
                        const response = await fetch(pv_url, {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: lv_for_body
                        });

                        ////const message = await response.json();
                        const message = await response.text();

                        lo_active_side.OnCompleteRefreshModel(message);

                    }

                    catch (e) {


                        lo_active_side.model_params_changed = false;

                        let lv_is_before = false;
                        lo_active_side.do_before_after_model_request(lv_is_before, false);

                        //alert('error send_for_refresh_model: ' + e.stack);
                        go_this.Show_message("Error updating model!", 2000);


                    }

                }


            }

            catch (e) {

                this.model_params_changed = false; //29082024

                alert('error send_side_data: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        Shape_generator.prototype.send_side_data_for_start_make_model = function (pv_url, po_json_data) {


            try {

                let lv_is_before = true;
                this.do_before_after_model_request(lv_is_before, true);

                send_for_start_make_model(pv_url, po_json_data);

                //-------------------------------------------------------------------
                async function send_for_start_make_model(pv_url, po_json_data) {


                    let lo_active_side = get_active_side_shape_generator(); //04102024
                    let lo_passive_side = get_passive_side_shape_generator(); //04102024

                    try {

                        var lv_for_body = JSON.stringify(po_json_data);
                        const response = await fetch(pv_url, {
                            method: "POST",
                            headers: {
                                //"Accept": "application/json",
                                "Content-Type": "application/json"
                            },
                            body: lv_for_body
                        });

                        const message = await response.json();
                        //const message = await response.text();

                        lo_active_side.OnCompleteStartMakeModel(message);

                    }

                    catch (e) {

                        lo_active_side.model_params_changed = false;

                        let lv_is_before = false;
                        lo_active_side.do_before_after_model_request(lv_is_before, false);


                        //alert('error send_for_start_make_model: ' + e.stack);
                        lo_active_side.common_func.Show_message("Error making model!", 2000);


                    }


                }
            }

            catch (e) {

                alert('error send_side_data_make_model: ' + e.stack);

            }
        }


        ////////-------------------------------------------------------------------
        //////Shape_generator.prototype.on_load_read_model_part = function (geometry_mod) {



        //////    let lo_active_side = get_active_side_shape_generator();
        //////    let lo_passive_side = get_passive_side_shape_generator();

        //////    geometry_mod.center();// Объект - в центре вращения



        //////    //////////////////////const dirLight2 = new THREE.DirectionalLight(0xccccff, 3);
        //////    //////////////////////dirLight2.position.set(- 1, 0.75, - 0.5);
        //////    //////////////////////lo_active_side.scene_mod.add(dirLight2);


        //////    //const material_mod = new THREE.MeshPhongMaterial(/*{ color: 0x555555 }*/);


        //////    //const material_mod = new THREE.MeshPhongMaterial({
        //////    //    specular: 0x444444,
        //////    //    //map: decalDiffuse,
        //////    //    //normalMap: decalNormal,
        //////    //    normalScale: new THREE.Vector2(1, 1),
        //////    //    shininess: 30,
        //////    //    transparent: false, //true,
        //////    //    depthTest: true,
        //////    //    depthWrite: false,
        //////    //    polygonOffset: true,
        //////    //    polygonOffsetFactor: - 4,
        //////    //    wireframe: false //true // false
        //////    //});


        //////    ////const material_mod = new THREE.MeshLambertMaterial({
        //////    ////    //color: 0xffffff,
        //////    ////    color: 0xfff0f0,
        //////    ////    opacity: 0.5,
        //////    ////    //side: THREE.DoubleSide,
        //////    ////    transparent: true
        //////    ////});


        //////    //const material_mod = new THREE.MeshBasicMaterial({
        //////    //    color: 0x00ff00, // черный цвет номера
        //////    //    side: THREE.DoubleSide,
        //////    //    shading: THREE.FlatShading
        //////    //});



        //////    ////camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
        //////    ////camera.position.set(1, 2, - 3);
        //////    ////camera.lookAt(0, 1, 0);
        //////    //var material_mod = new THREE.MeshBasicMaterial({ vertexColors: THREE.FaceColors });
        //////    ///const material_mod = new THREE.MeshPhongMaterial({ color: 0xcbcbcb, depthWrite: false }) 

        //////    //////let materialFront = new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random() * 0xffffff) });
        //////    //////let materialSide = new THREE.MeshBasicMaterial({ color: new THREE.Color(Math.random() * 0x00ffff) });

        //////    //////let materialArray = [materialFront, materialSide];
        //////    //////let material_mod = new THREE.MeshLambertMaterial(materialArray);


        //////    //const dirLight = new THREE.DirectionalLight(0xffffff, 3);
        //////    //dirLight.position.set(- 3, 10, - 10);
        //////    //dirLight.castShadow = true;
        //////    //dirLight.shadow.camera.top = 2;
        //////    //dirLight.shadow.camera.bottom = - 2;
        //////    //dirLight.shadow.camera.left = - 2;
        //////    //dirLight.shadow.camera.right = 2;
        //////    //dirLight.shadow.camera.near = 0.1;
        //////    //dirLight.shadow.camera.far = 40;
        //////    //lo_active_side.scene_mod.add(dirLight);



        //////    //=========================================================================
        //////    const mesh_mod = new THREE.Mesh(geometry_mod, lo_active_side.material_mod);

        //////    lo_active_side.scene_mod.add(mesh_mod);


        //////    $('#up_id_loading_indicator').hide();// прекращение индикации ожидания
        //////    $('#lateral_id_loading_indicator').hide();// прекращение индикации ожидания


        //////    lo_active_side.animate_mod();

        //////    lo_active_side.is_building_model = false;
        //////    lo_passive_side.is_building_model = false;


        //////}



        //-----------------------------------------------------------------
        // Задание цвета фигур по считанным данным
        Shape_generator.prototype.set_meshes_color_by_data = function (/*par_splines_order*/) {

            try {

                //this.clear_group_color_mesh();//03082024

                let lar_colorparts = go_end_side_shape_generator.end_shape.ColorParts;

                let lar_splines_order = null;

                let lo_spline_left = null;
                let lo_spline_right = null;
                let lv_cell_color = null;


                if (this != go_end_side_shape_generator) {

                    lar_splines_order = this.shapes.SortSplinesOrderFromLeftToRight();
                }



                for (let lv_i = 0; lv_i < lar_colorparts.length; lv_i++) {

                    for (let lv_j = 0; lv_j < lar_colorparts[0].length; lv_j++) {

                        if (lar_colorparts[lv_i][lv_j] == null || typeof lar_colorparts[lv_i][lv_j] == "undefined") {
                            continue;
                        }

                        if (!lar_colorparts[lv_i][lv_j].cell_color || typeof lar_colorparts[lv_i][lv_j].cell_color == "undefined") {
                            continue;
                        }


                        lv_cell_color = lar_colorparts[lv_i][lv_j].cell_color;


                        if (this == go_end_side_shape_generator) { // Торцовая сторона

                            this.end_shape.set_color_to_rectangle_cell(lv_cell_color, lv_i, lv_j);

                        }

                        //else {

                        if (this == go_up_side_shape_generator) { // Верхняя сторона

                            if (lv_i == 0) {

                                lo_spline_left = this.common_func.getSplineByNumber(lar_splines_order, lv_j - 1);
                                lo_spline_right = this.common_func.getSplineByNumber(lar_splines_order, lv_j);
                                this.shapes.draw_contour_and_shape(lv_cell_color, lo_spline_left, lo_spline_right, false, true, false, true);

                            }
                        }

                        if (this == go_lateral_side_shape_generator) { // Боковая сторона

                            if (lv_j == lar_colorparts.length - 1) {

                                lo_spline_left = this.common_func.getSplineByNumber(lar_splines_order, lv_i - 1);
                                lo_spline_right = this.common_func.getSplineByNumber(lar_splines_order, lv_i);
                                this.shapes.draw_contour_and_shape(lv_cell_color, lo_spline_left, lo_spline_right, false, true, false, true);

                            }
                        }

                    }
                }



            }

            catch (e) {

                alert('error set_meshes_color_by_data: ' + e.stack);

            }
        }



        //------------------------------------------------------------------------
        Shape_generator.prototype.set_visible_rotate_controls = function (pv_is_visible) {

            try {

                if (pv_is_visible) {

                    $("#up_id_dist_part_slider").css("visibility", "visible");
                    $("#lateral_id_dist_part_slider").css("visibility", "visible");
                }
                else {

                    $("#up_id_dist_part_slider").css("visibility", "hidden");
                    $("#lateral_id_dist_part_slider").css("visibility", "hidden");
                }



            }

            catch (e) {

                alert('error switch_visible_rotate_controls: ' + e.stack);

            }

        }



        //////////------------------------------------------------------------------------
        ////Shape_generator.prototype.onclick_shape = function (po_event) {

        ////    ////    //14072024 {
        ////    ////    //////////let lo_active_side_shape_generator = get_active_side_shape_generator();

        ////    ////    //////////if (lo_active_side_shape_generator.was_draggable) {
        ////    ////    //////////    lo_active_side_shape_generator.was_draggable = false;
        ////    ////    //////////    return;
        ////    ////    //////////}






        ////    ////////25072024 {

        ////    //////    let lo_active_side_shape_generator = get_active_side_shape_generator();


        ////    //////    if (lo_active_side_shape_generator.is_gragging) {
        ////    //////        // dragging
        ////    //////        return;
        ////    //////    }

        ////    //////    // click

        ////    //////    let lo_clicked_splines_and_segment = lo_active_side_shape_generator.shapes.get_splines_and_segment_of_clicked_figure(po_event);

        ////    //////    let lo_clicked_splines = {
        ////    //////        spline_left: lo_clicked_splines_and_segment.spline_left,
        ////    //////        spline_right: lo_clicked_splines_and_segment.spline_right
        ////    //////    };

        ////    //////    let lo_prev_clicked_splines = lo_active_side_shape_generator.group_contours.userData;

        ////    //////    lo_active_side_shape_generator.shapes.clear_group_contours();

        ////    //////    if (lo_active_side_shape_generator.group_contours.userData == null)
        ////    //////    {
        ////    //////        lo_active_side_shape_generator.shapes.select_shape_contour(lo_clicked_splines_and_segment);

        ////    //////    }
        ////    //////    else
        ////    //////    {

        ////    //////        if (lo_clicked_splines.spline_left == lo_prev_clicked_splines.spline_left
        ////    //////            && lo_clicked_splines.spline_right == lo_prev_clicked_splines.spline_right)
        ////    //////        {
        ////    //////            lo_active_side_shape_generator.group_contours.userData = null;
        ////    //////        }
        ////    //////        else {
        ////    //////            lo_active_side_shape_generator.shapes.select_shape_contour(lo_clicked_splines_and_segment);
        ////    //////        }

        ////    //////    }

        ////    //////


        ////    //////    lo_active_side_shape_generator.render();

        ////    //25072024 }



        ////}




        //const cv_width = this.params.container_width;
        //const cv_height = this.params.container_height;
        //const cv_shape_width = this.params.shape_width;
        //const cv_shape_height = this.params.shape_height;





        ////////------------------------------------------------------------------------
        //////Shape_generator.prototype.draw_side_shape_by_data = function (/*po_side,*/ po_side_data) {

        //////    //for (let lv_i = 0; lv_i < po_side_data.numCurves; lv_i++) {


        //////    //}

        //////    /*po_side*/this.make_shape(true, po_side_data);

        //////}

        //=====================================================================

    } // (typeof this.create_shape_generator !== "function")


    //---------------------------------------------------------------------

    this.create_shape_generator(pv_active_id_prefix /*30112024*/);

    //06052024 this.render();//05052024
    //}

    // end Class Shape_generator
    //=====================================================================
}
import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"


export function struc_gabarits() {
    this.min = new THREE.Vector2(0, 0);
    this.max = new THREE.Vector2(0, 0);
    this.width = 0;
    this.height = 0;
}

export function struc_segment_transform_data() {
    this.kx = 0;
    this.ky = 0;
    this.distance_bt_x = 0;
}

export const cv_rectangle_name = "rectangle";
export const cv_spline_group_name_prefix = "spline_group";
export const cv_spline_name_prefix = "spline";
export const cv_segment_group_name_prefix = "segment_group";
//04032025 export const cv_segment_name_prefix = "segment";
export const cv_segment_name_prefix = "segment_line"; //04032025



//function typ_ob_data() {

//    this.numCurves = 1;
//    this.idMaterial = 7;
//    this.idSize = 1;

//    this.CurveColors = new Array();
//    this.PointsCurves = new Array();

//    this.Lockedit = false;
//    this.Fl_manual_parameters = false;
//    this.M_Material = '';
//    this.M_Width = 0.0;
//    this.M_Height = 0.0;
//    this.M_Length = 0.0;
//    this.M_Price_rub = 0.0;
//    this.Part_gap = gv_Part_gap;
//}


//export function typ_model_data() {
//    this.color_parts = new Array();
//    this.curves_points_upper_side = new Array();
//    this.curves_points_lateral_side = new Array();
//};






//29102024v {



export function typ_color_data() {
    this.ColorParts = [][new typ_color_part()]; //27012025
}


export function typ_mesh_colors() {
    this.num_spline_left = null;
    this.num_spline_right = null;
    this.color = null;
};


export var type_rotate_mode = {
    //None: 0,                // нет вращения
    stop: 0,                // остановка вращения
    clockwise: 1,           // вращение по часовой стрелке
    stop2: 2,               // остановка вращения
    counterclockwise: 3     // вращение по часовой стрелке

};

export function typ_progress_data() {
    this.client_id = "";
    this.task_id = "";
    this.path_result_file = "";
    this.common_outfilename_part = "";
    this.number_outfiles = "";

    this.progress_indicator = "";
    this.date_time_changed = "";

    this.names_part_files = [];//26012025
};



//----------------------------------------------------
export function typ_sides_data() {
    this.client_id = "0";
    this.task_id = "0";
    this.ColorParts = [][new typ_color_part()];
    this.data1 = new typ_side_data();
    this.data2 = new typ_side_data();
};


export function typ_color_part() {

    this.cell_color = "";
    this.right_top = new typ_2dcoord(); // new THREE.Vector2(0, 0);
    this.left_bottom = new typ_2dcoord(); // new THREE.Vector2(0,0) ;
    this.is_contour_visible = false;
    this.text_mesh = null;

};

export function typ_2dcoord() {
    this.x = null;
    this.y = null;
};


export function typ_side_data() {
    this.parameters = new typ_parameters();
    this.numCurves = 0;
    this.idMaterial = 0;
    this.idSize = 0;
    this.Lockedit = false;
    this.Fl_manual_parameters = false;
    this.M_Material = 0;
    this.M_Width = 0.0;
    this.M_Height = 0.0;
    this.M_Length = 0.0;
    this.M_Price_rub = 0.0;
    this.Part_gap = 0;
    this.CurveColors = []; //01112024  new Array();
    this.Segments_beg_points_numbers = []; //01112024  new Array();
    this.PointsCurves = []; // new Array();
    this.rectangle_scale_y = 0;
}


export function typ_parameters() {
    //this.is_space_adjust = false;
    //this.is_curve_width_adjust = false;
    //this.distance_bt_curves = 0;
    //this.distance_bt_curves_in_percent = 0;
    //this.shape_height = 0;
    //this.shape_width = 0;

    this.container_width = 0;
    this.container_height = 0;
    this.shape_width_beg = 0;
    this.shape_width = 0;
    this.shape_height_beg = 0;
    this.shape_height = 0;
    this.shape_amount_curves = 0;
    this.spline_amount_segments = 0;
    this.ajust_curves_by_shape = false;
    this.ajust_shape_by_curves = false;
    this.distance_between_curves_in_percent_of_width = 0;
    this.distance_bt_curves = 0;
    this.is_space_adjust = false;
    this.is_curve_width_adjust = false;
    this.color = +'#0000ff';//02052025
    this.rectangle_scale_y = 0;
}




export function typ_united_model_data() {
    this.model_name = "";
    this.sides_data = "";
    this.prev_model = "";
    this.screenshot = null;
    this.up_side_screenshot = null;//22012025
    this.lat_side_screenshot = null;//22012025
    this.end_side_screenshot = null;//22012025

}

/// <reference path="my_progress_dialog.js" />
/// <reference path="my_rectangle.js" />
import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"

import { Line2 } from 'three/addons/lines/Line2.js';
//import { Line2 } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/Line2.js';

import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineMaterial } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineMaterial.js';


import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
//import { LineGeometry } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineGeometry.js';


//import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';

import { STLExporter } from 'three/addons/exporters/STLExporter.js';
//import { STLExporter } from 'https://unpkg.com/three@v0.149.0/examples/jsm/exporters/STLExporter.js';

import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';



import { Text } from 'troika-three-text'; //06022025


import { Font } from 'three/addons/loaders/FontLoader.js';





import { Constants } from './my_common_const.js';

import {
    get_active_side_shape_generator,
    get_passive_side_shape_generator,

    gc_id_prefix_up,
    gc_id_prefix_lateral,
    gc_id_prefix_end,

    go_up_side_shape_generator,
    go_lateral_side_shape_generator,
    go_end_side_shape_generator,

    //Shape_generator
} from './my_shape_generator.js';//27072024


import { Shapes } from './my_shapes.js';//27072024

import {
    typ_united_model_data,
    type_rotate_mode
} from './my_common_types.js';//2409202



var go_this = null;



// Class CommonFunc
export function CommonFunc() {

    // Свойства
    //	this.container = po_container;


    go_this = this;

    this.$dialog_question = $("#id_div_dialog_question");

    this.$dialog_message = $("#id_div_dialog_message");

    this.message_timeout = 1500;

    this.downloaded_filename = "";


    //const lo_link = document.createElement('a');
    //lo_link.style.display = 'none';
    //document.body.appendChild(lo_link);

    //=====================================================================

    if (typeof this.create_commonFunc != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------



        ////CommonFunc.prototype.create_commonFunc = function () {


        ////	try {


        ////	}

        ////	catch (e) {

        ////		alert('error create_commonFunc: ' + e);

        ////	}


        ////}



        //------------------------------------------------------------------------
        CommonFunc.prototype.check_file_exist_on_server = function (pv_filename, pf_callback) {

            let lv_url = "/Index?handler=" + Constants.method_check_file_exist_on_server + "&filename=" + pv_filename;


            get_check_file_exist_on_server(lv_url, pf_callback);
            //--------------------------------------------------
            async function get_check_file_exist_on_server(pv_url, pf_callback) {

                try {

                    //await $.get(pv_url, "", go_this.oncomplete_check_file_exist_on_server);
                    await $.get(pv_url, "", pf_callback);

                }

                catch (e) {

                    alert('error get_read_model_from_server: ' + e.stack);

                }

            }

        }



        //------------------------------------------------------------------------
        CommonFunc.prototype.clear_group_childrens = function (po_group, pv_is_remove_geometry, pv_is_remove_material) {

            if (!po_group) {
                return;
            }

            try {

                for (var lv_i = po_group.children.length - 1; lv_i >= 0; lv_i--) {

                    if (pv_is_remove_geometry) {

                        if (po_group.children[lv_i].geometry) {
                            po_group.children[lv_i].geometry.dispose();
                        }
                    }


                    if (pv_is_remove_material) {
                        if (po_group.children[lv_i].material) {
                            po_group.children[lv_i].material.dispose();
                        }

                    }



                    this.removeObjectsWithChildren(po_group.children[lv_i], true);

                }

            }
            catch (e) {

                alert('error clear_group_childrens: ' + e.stack);

            }


        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.clearScene = function (po_scene, pv_nodelete_type) {

            // Очистка сцены

            let lv_beg = po_scene.children.length - 1;
            let lv_end = 0;

            for (let lv_i = lv_beg; lv_i >= 0; lv_i--) {

                if (pv_nodelete_type) {
                    //if (po_scene.children[lv_i].type !== pv_nodelete_type) {
                    if (!pv_nodelete_type.includes(po_scene.children[lv_i].type)) {
                        this.removeObjectsWithChildren(po_scene.children[lv_i], true);
                    }
                }
                else {
                    this.removeObjectsWithChildren(po_scene.children[lv_i], true);
                }
            }

        }

        //-----------------------------------------------------------------------------------
        // Функция преобразования цвета в RGB 
        CommonFunc.prototype.convertToRGB = function (pv_value) {

            if (typeof pv_value === "number") {
                // числовое значение
                let lv_str = this.decimalToHexColor(pv_value);
                return this.hexToRgb(lv_str);

                //return this.decimalToRGB(pv_value);

            }

            if (typeof pv_value === "string") {
                if (/^0x[0-9A-Fa-f]+$/.test(pv_value)) {
                    //return "Шестнадцатеричная строка";


                }
                if (/^[0-9]+$/.test(pv_value)) {
                    //return "Десятичная строка";
                    return this.decimalToRGB(pv_value);
                }

                return null; // "Обычная строка";
            }


        }


        //-----------------------------------------------------------------
        CommonFunc.prototype.create_text_mesh = function (
            //po_font,
            po_scene,
            pv_text,
            po_left_bottom,
            po_right_top
            //po_textmesh
        ) {

            //return;

            let lo_cell_text_geometry = null;
            let lo_cell_text_material = null;
            let lo_cell_text_mesh = null;


            try {

                //06022025 {

                //po_scene.remove(po_textmesh);
                if (!go_end_side_shape_generator) {
                    return null;
                }
                if (!go_end_side_shape_generator.end_shape.cell_text_geometry) {
                    return null;
                }




                //this.clear_group_childrens(go_end_side_shape_generator.group_cell_texts);

                //this.removeObjectsWithChildren(go_end_side_shape_generator.end_shape.cell_text_geometry, true);
                //po_scene.remove(go_end_side_shape_generator.end_shape.cell_text_geometry);
                //go_end_side_shape_generator.end_shape.cell_text_geometry = null;


                //lo_cell_text_geometry = go_end_side_shape_generator.cell_text_geometry.clone();





                //go_end_side_shape_generator.end_shape.cell_text_geometry.dispose();




                //08022025 go_end_side_shape_generator.end_shape.cell_text_geometry = new TextGeometry(
                let lo_text_geometry = new TextGeometry(  //08022025 
                    pv_text,
                    {
                        font: go_end_side_shape_generator.end_shape.cell_text_font,
                        size: Constants.cell_text_size,

                        //height: 0.5,
                        //curveSegments: 12,
                        ////bevelEnabled: true,
                        ////bevelThickness: 0.03,
                        ////bevelSize: 0.02,
                        ////bevelSegments: 5

                        //dept: 5, //20,
                        curveSegments: 6, //12,
                        //bevelEnabled: true,
                        //bevelThicknes: 0.01,
                        //bevelSize: 0.001,
                        //bevelSegments: 5


                        //size: 2,
                        height: 0.5,
                        bevelEnabled: true,
                        bevelThickness: 0.05,  //0.1  Увеличиваем толщину фаски
                        bevelSize: 0.02,      //0.05 Делаем фаску заметнее
                        bevelSegments: 3      //5 Добавляем больше сегментов для сглаживания


                    }
                );



                //lo_cell_text_geometry.text.set(pv_text);

                lo_cell_text_material = go_end_side_shape_generator.end_shape.cell_text_material.clone();


                //if (go_end_side_shape_generator.end_shape.cell_text_mesh) {
                //    go_end_side_shape_generator.end_shape.cell_text_mesh.dispose();
                //}



                //08022025 lo_cell_text_mesh = new THREE.Mesh(go_end_side_shape_generator.end_shape.cell_text_geometry, lo_cell_text_material);
                lo_cell_text_mesh = new THREE.Mesh(lo_text_geometry, lo_cell_text_material);//08022025


                //go_end_side_shape_generator.end_shape.cell_text_mesh = new THREE.Mesh(go_end_side_shape_generator.end_shape.cell_text_geometry, lo_cell_text_material);

                // позиция текста
                let lv_x = po_left_bottom.x + 2;
                let lv_y = po_right_top.y - 5;

                lo_cell_text_mesh.position.set(lv_x, lv_y, 0);
                //go_end_side_shape_generator.end_shape.cell_text_mesh.position.set(lv_x, lv_y, 0);




                //if (!po_font) {

                //    return null;
                //}

                ////if (po_textmesh) {
                ////    go_this.removeObjectsWithChildren(po_textmesh,true);
                ////    po_textmesh.geometry.dispose();
                ////}

                ////// Создаём новую геометрию с обновлённым текстом
                ////let lo_textGeometry = new TextGeometry(pv_text, {
                ////    font: po_font,  // Используем загруженный шрифт
                ////    size: 2, //1,
                ////    height: 0.2,
                ////    curveSegments: 12,
                ////    bevelEnabled: true,
                ////    bevelThickness: 0.03,
                ////    bevelSize: 0.02,
                ////    bevelSegments: 5
                ////});

                ////// Создаём материал и объект Mesh
                //////let lo_textMaterial = new THREE.MeshBasicMaterial({ color: Constants.color_text /*0xffffff*/ });
                ////let lo_textMaterial = go_up_side_shape_generator.text_material; //   new THREE.MeshBasicMaterial({ color: Constants.color_text /*0xffffff*/ });
                ////po_textmesh = new THREE.Mesh(lo_textGeometry, lo_textMaterial);

                ////// позиция текста
                ////let lv_x = (po_right_top.x + po_left_bottom.x) / 2;
                ////let lv_y = (po_right_top.y + po_left_bottom.y) / 2;

                ////po_textmesh.position.set(lv_x, lv_y, 0);

                ////// Добавляем в сцену
                //////scene.add(textMesh);



                //return;

                //if (po_textmesh) {
                //    go_this.removeObjectsWithChildren(po_textmesh, true);
                //    if (po_textmesh.geometry) {
                //        po_textmesh.geometry.dispose();
                //    }
                //}


                //let lo_color = new THREE.Color(+Constants.color_text);







                //////fetch("/fonts/OpenSans-Regular.ttf")
                //////    .then(response => console.log("Шрифт Ок " + response.status))
                //////    .catch(error => console.error("Ошибка загрузки шрифта", error));



                //////let po_textmesh = new Text();

                ////////po_textmesh.font = "../fonts/Roboto-Regular.ttf"; // po_font;
                ////////po_textmesh.font = "E:/MyProjects/jb_api_shg/JbShapeGenerator/wwwroot/fonts/Roboto-Regular.ttf";
                //////po_textmesh.font = "/fonts/OpenSans-Regular.ttf";
                ////////po_textmesh.font = "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff";
                ////////po_textmesh.font = "https://yourserver.com/fonts/Roboto-Regular.ttf";
                //////po_textmesh.text = "mytext";// pv_text;
                //////po_textmesh.fontSize = 4;
                //////po_textmesh.color = Constants.color_text; // 0x0000ff;//02052025
                //////po_textmesh.name = "text_" + pv_text;


                //////po_textmesh.maxWidth = 100;
                //////po_textmesh.clipRect = null;
                //////po_textmesh.scale.set(1, 1, 1);
                //////po_textmesh.whiteSpace = "normal";
                //////po_textmesh.overflowWrap = "break-word";
                //////po_textmesh.letterSpacing = 0;// 0.2;

                ////////po_textmesh.renderOrder = 5;

                //////// позиция текста
                //////let lv_x = po_left_bottom.x + 2;
                //////let lv_y = po_right_top.y - 2;

                //////po_textmesh.position.set(lv_x, lv_y, 0);

                //////////po_textmesh.sync(() => {
                //////////    //console.log("Текст успешно сгенерирован!");
                //////////    po_scene.add(po_textmesh);
                //////////});

                //06022025 }


                //08022025 go_end_side_shape_generator.group_cell_texts.add(lo_cell_text_mesh);//07022025

                //07022025 po_scene.add(lo_cell_text_mesh);

                return lo_cell_text_mesh;

            }

            catch (e) {

                alert('error create_text_mesh: ' + e.stack);

            }

        }




        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.Create2DArray = function (pv_rows, pv_cols, pv_init_value) {

            let lar_array;

            try {

                lar_array = new Array(pv_rows);
                for (let i = 0; i < pv_rows; i++) {
                    lar_array[i] = new Array(pv_cols).fill(pv_init_value); // Заполняем начальным значением
                }
            }

            catch (e) {

                alert('error Create2DArray: ' + e.stack);

            }

            return lar_array;
        }



        //-----------------------------------------------------------------
        CommonFunc.prototype.disposeTextMesh = function (po_textMesh) {


            if (!po_textMesh) return;

            // Удаление из родительской группы или сцены
            //if (po_textMesh.parent) {
            //    po_textMesh.parent.remove(po_textMesh);
            //}

            // Очистка геометрии
            if (po_textMesh.geometry) {


                if (Array.isArray(po_textMesh.geometry)) {
                    po_textMesh.geometry.forEach(mat => mat.dispose());
                } else {
                    po_textMesh.geometry.dispose();
                }

            }

            // Очистка материала (учитываем, что материал может быть массивом)
            if (po_textMesh.material) {
                if (Array.isArray(po_textMesh.material)) {
                    po_textMesh.material.forEach(mat => mat.dispose());
                } else {
                    po_textMesh.material.dispose();
                }
            }

            // Очистка ссылок
            po_textMesh = null;

        }

        //------------------------------------------------------------------------
        CommonFunc.prototype.get_delta_rotation = function (pv_rotate_status) {

            let lv_delta_rotation = 0;

            switch (pv_rotate_status) {
                //case type_rotate_mode.None:
                case type_rotate_mode.stop:
                case type_rotate_mode.stop2:
                    lv_delta_rotation = 0.0;
                    break;

                case type_rotate_mode.clockwise:
                    lv_delta_rotation = -0.01;
                    break;
                case type_rotate_mode.counterclockwise:
                    lv_delta_rotation = +0.01;
                    break;

            }

            return lv_delta_rotation;

        }


        //-----------------------------------------------------------------------------------
        // Функция для преобразования десятичного значения цвета в RGB 
        CommonFunc.prototype.decimalToRGB = function (pv_decimalColor) {

            const r = (pv_decimalColor >> 16) & 255; // Извлекаем красный (старший байт)
            const g = (pv_decimalColor >> 8) & 255;  // Извлекаем зелёный (средний байт)
            const b = pv_decimalColor & 255;         // Извлекаем синий (младший байт)

            //return `rgb(${r}, ${g}, ${b})`;
            let lv_str = `rgb(${r}, ${g}, ${b})`;

            return this.extractRGBComponents(lv_str);

        }


        //-----------------------------------------------------------------------------------
        // Извлечение трёх чисел из строки "rgb(a,b,c)"
        CommonFunc.prototype.extractRGBComponents = function (rgbString) {


            try {
                // Используем регулярное выражение для извлечения чисел
                const regex = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/;
                const result = rgbString.match(regex);

                if (result) {
                    // Преобразуем извлеченные строки в числа и возвращаем их
                    const r = parseInt(result[1], 10);
                    const g = parseInt(result[2], 10);
                    const b = parseInt(result[3], 10);
                    return { r, g, b };
                } else {

                    throw new Error("Invalid RGB string format");
                }


            }

            catch (e) {

                alert('error extractRGBComponents: ' + e.stack);

            }

        }


        //-----------------------------------------------------------------------------------

        // Функция для получения габаритных координат прямоугольника
        CommonFunc.prototype.getBoundingBox = function (mesh) {

            const boundingBox = new THREE.Box3().setFromObject(mesh);

            const min = boundingBox.min;
            const max = boundingBox.max;

            return {
                min: {
                    x: min.x,
                    y: min.y,
                    z: min.z
                },
                max: {
                    x: max.x,
                    y: max.y,
                    z: max.z
                }
            };
        }


        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_cell_text_label = function (pv_nrow, pv_ncol) {

            let lv_result = "";

            try {

                lv_result = (pv_nrow + 1).toString() + "_" + (pv_ncol + 1).toString();
            }

            catch (e) {

                alert('error get_cell_text_label: ' + e.stack);

            }

            return lv_result;
        }
        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_drawing_rectangle = function (pv_width, pv_height, po_color, po_material) {

            let lo_result = null;
            let lo_renderer = null;
            let lo_material = null;

            let lo_color = null;

            try {
                if (po_color) {
                    lo_color = po_color;//05022025
                }
                else {
                    //lv_color = +Constants.color_shape_countour_str; //05022025
                    lo_color = new THREE.Color(Constants.color_shape_countour); //05022025
                }

                if (po_material) {
                    lo_material = po_material;
                }
                else {

                    lo_material = new LineMaterial({
                        vertexColors: true, //30012025
                        linewidth: Constants.line_width_shape_contour, //30012025 0.7,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Обязательно 30012025 lo_resolution,
                    });
                }

                let lar_positions = [];
                lar_positions.push(0, 0, 0);
                lar_positions.push(0, pv_height, 0);
                lar_positions.push(pv_width, pv_height, 0);
                lar_positions.push(pv_width, 0, 0);
                lar_positions.push(0, 0, 0);


                //06022025 {
                //////05022025 let lo_rgb = CommonFunc.prototype.hexToRgb(lv_color);
                ////let lo_rgb = CommonFunc.prototype.decimalToRGB(lo_color);//02052025


                ////const clrs = [];
                ////lar_positions.forEach(() => {
                ////    clrs.push(lo_rgb.r, lo_rgb.g, lo_rgb.b);
                ////});


                const clrs = [];
                lar_positions.forEach(() => {
                    clrs.push(lo_color.r, lo_color.g, lo_color.b);
                });


                //06022025 }





                let lo_geometry = new LineGeometry();
                lo_geometry.setPositions(
                    lar_positions
                );

                lo_geometry.setColors(clrs);

                lo_result = new Line2(lo_geometry, lo_material);

                return lo_result;

            }

            catch (e) {
                alert('error get_drawing_rectangle: ' + e.stack);
            }
        }



        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_drawing_rectangle_by_points = function (po_left_bottom, po_right_top, pv_color, po_material,
            pv_delta
            //pv_delta_y

        ) {

            let lo_result = null;
            let lo_renderer = null;
            let lo_material = null;
            let lv_color = null;

            try {
                if (pv_color) {
                    lv_color = pv_color;//02052025
                }
                else {
                    lv_color = Constants.color_shape_countour; //02052025
                }


                if (po_material) {
                    lo_material = po_material;
                }
                else {

                    ////lo_renderer = new THREE.WebGLRenderer({ antialias: true });
                    ////let lo_resolution = new THREE.Vector2();
                    ////lo_renderer.getSize(lo_resolution);

                    lo_material = new LineMaterial({
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // Обязательно 30012025 lo_resolution,
                        linewidth: Constants.line_width_shape_contour, //7, //30012025 0.7,
                        color: lv_color
                    });
                }






                //////let lo_geometry = new LineGeometry();
                //////lo_geometry.setPositions([
                //////    //16122024 {
                ////////    po_left_bottom.y, po_left_bottom.x,  0,                                           //y0, x0, 0,
                ////////    po_left_bottom.y, po_right_top.x - po_left_bottom.x, 0,                        //y0, pv_width, 0,
                ////////    po_right_top.y - po_left_bottom.y, po_right_top.x - po_left_bottom.x, 0,   //pv_height, pv_width, 0,
                ////////    po_right_top.y - po_left_bottom.y, po_left_bottom.x, 0,                       //pv_height, x0, 0,
                //////    //    po_left_bottom.y, po_left_bottom.x, 0                                            //y0, x0, 0

                //////    po_left_bottom.x, po_left_bottom.y, 0,                                           //y0, x0, 0,
                //////    po_left_bottom.x, po_right_top.y - po_left_bottom.y, 0,                        //y0, pv_width, 0,
                //////    po_right_top.x - po_left_bottom.x, po_right_top.y - po_left_bottom.y, 0,   //pv_height, pv_width, 0,
                //////    po_right_top.x - po_left_bottom.x, po_left_bottom.y, 0                       //pv_height, x0, 0,
                //////    ///////////////////po_left_bottom.x, po_left_bottom.y, 0                                            //y0, x0, 0

                //////    // 16122024 }

                //////]);


                //po_left_bottom, po_right_top

                const squareVertices = new Float32Array([
                    //-2, 2, 0,  // Левая верхняя точка
                    //2, 2, 0,   // Правая верхняя точка
                    //2, 2, 0,   // Правая верхняя точка
                    //2, -2, 0,   // Правая нижняя точка
                    //2, -2, 0,   // Правая нижняя точка
                    //-2, -2, 0,  // Левая нижняя точка
                    //-2, -2, 0,  // Левая нижняя точка
                    //-2, 2, 0   // Левая верхняя точка (замкнем квадрат)


                    po_left_bottom.x + pv_delta, po_right_top.y - pv_delta, 0,    // Левая верхняя точка
                    po_right_top.x - pv_delta, po_right_top.y - pv_delta, 0,      // Правая верхняя точка
                    po_right_top.x - pv_delta, po_right_top.y - pv_delta, 0,      // Правая верхняя точка
                    po_right_top.x - pv_delta, po_left_bottom.y + pv_delta, 0,    // Правая нижняя точка
                    po_right_top.x - pv_delta, po_left_bottom.y + pv_delta, 0,    // Правая нижняя точка
                    po_left_bottom.x + pv_delta, po_left_bottom.y + pv_delta, 0,  // Левая нижняя точка
                    po_left_bottom.x + pv_delta, po_left_bottom.y + pv_delta, 0,  // Левая нижняя точка
                    po_left_bottom.x + pv_delta, po_right_top.y - pv_delta, 0     // Левая верхняя точка (замкнем квадрат)

                ]);

                let squareGeometry = new LineGeometry();

                squareGeometry.setPositions(squareVertices);

                let squareLine = new Line2(squareGeometry, lo_material);
                lo_result = new Line2(squareGeometry, lo_material);

                //lo_result = new Line2(lo_geometry, lo_material);

                return lo_result;

            }

            catch (e) {

                alert('error get_drawing_rectangle_by_points: ' + e.stack);

            }
        }
        //------------------------------------------------------------------------
        CommonFunc.prototype.get_guid = function () {

            // from https://stackoverflow.com/questions/105034/how-do-i-create-a-guid-uuid

            //return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            return 'xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.getLinePoints = function (po_line) {

            let lar_points = po_line.geometry.attributes.position.array;

            let lar_out_points = [];


            let lv_rest;

            let lv_point_x;
            let lv_point_y;
            let lo_point;

            for (let lv_i = 0; lv_i < lar_points.length; lv_i++) {

                lv_rest = lv_i % 3;

                switch (lv_rest) {
                    case 0:
                        lv_point_x = lar_points[lv_i];
                        break;
                    case 1:
                        lv_point_y = lar_points[lv_i];
                        break;

                    case 2:
                        let lo_point = new THREE.Vector2(lv_point_x, lv_point_y);
                        lar_out_points.push(lo_point);
                        break;
                }

            }

            return lar_out_points;
        }




        //-----------------------------------------------------------------

        CommonFunc.prototype.get_name_by_numrow_numcol = function (lv_cell_num_row, lv_cell_num_column) {


            let lv_result = null;

            try {
                if (lv_cell_num_row == null || lv_cell_num_row < 0
                    || lv_cell_num_column == null || lv_cell_num_column < 0) {

                    return lv_result;
                }

                return lv_cell_num_row.toString() + "_" + lv_cell_num_column.toString();
            }

            catch (e) {

                alert('error get_name_by_numrow_numcol: ' + e.stack);

            }

        }


        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_numspline_from_left_to_right = function (po_spline) {

            let lv_numspline = -1;

            try {

                let lo_active_side = get_active_side_shape_generator();

                let lar_sorted = lo_active_side.shapes.SortSplinesOrderFromLeftToRight();

                for (let lv_i = 0; lv_i < lar_sorted.length; lv_i++) {

                    if (lar_sorted[lv_i].spline == po_spline) {
                        lv_numspline = lv_i;
                        break;
                    }
                }

            }

            catch (e) {

                alert('error get_numspline_from_left_to_right: ' + e.stack);

            }

            return lv_numspline;
        }





        //-----------------------------------------------------------------------------------
        // Чтение номера сплайна в массиве 
        CommonFunc.prototype.getNumberBySpline = function (par_array, po_spline) {

            let pv_return = null;

            while (true) {
                if (!par_array || !po_spline) {
                    break;
                }


                for (let lv_i = 0; lv_i < par_array.length; ++lv_i) {

                    if (par_array[lv_i].spline == po_spline) {

                        pv_return = lv_i;
                        break;
                    }
                }


                break;
            }

            return pv_return;
        }


        //-----------------------------------------------------------------
        CommonFunc.prototype.get_points_from_geometry = function (po_geometry) {

            let lar_positions = null;
            let lar_vertices = null;

            try {

                if (!po_geometry) {
                    return null;
                }
                if (!po_geometry.attributes) {
                    return null;
                }
                if (!po_geometry.attributes.position) {
                    return null;
                }


                // Допустим, у нас есть объект Line
                lar_positions = po_geometry.attributes.position.array; // Получаем массив координат
                lar_vertices = []; // Массив для хранения Vector3

                // Проходим по массиву и создаём Vector3 для каждой вершины
                for (let i = 0; i < lar_positions.length; i += 3) {
                    lar_vertices.push(new THREE.Vector3(lar_positions[i], lar_positions[i + 1], lar_positions[i + 2]));
                }

            }

            catch (e) {

                alert('error get_points_from_geometry: ' + e.stack);

            }
            return lar_vertices;
        }



        //-----------------------------------------------------------------------------------
        // Чтение сплайна по номеру в массиве
        CommonFunc.prototype.getSplineByNumber = function (par_array, pv_elem_number) {

            let pv_return = null;

            while (true) {
                if (par_array == null || pv_elem_number == null) {
                    break;
                }
                if (pv_elem_number < 0 || pv_elem_number >= par_array.length) {
                    break;
                }

                pv_return = par_array[pv_elem_number].spline;

                break;
            }

            return pv_return;
        }



        //-----------------------------------------------------------------

        CommonFunc.prototype.GetTwoShapeIntersect = function (object1, object2) {
            // (example from https://stackoverflow.com/questions/49417007/how-to-find-intersection-of-objects-in-three-js)
            /**
             * This function check if two object3d intersect or not
             * @param {THREE.Object3D} object1
             * @param {THREE.Object3D} object2
             * @returns {Boolean} 
            */

            let lv_result = null;


            try {

                // Check for intersection using bounding box intersection test
                let bBox1 = new THREE.Box3().setFromObject(object1);
                bBox1.max.z = 0;
                bBox1.min.z = 0;

                object2.geometry.computeBoundingBox();

                let bBox2 = new THREE.Box3().setFromObject(object2);
                bBox2.max.z = 0;
                bBox2.min.z = 0;

                const intersection = bBox1.intersectsBox(bBox2);
                // const intersection = mesh1.geometry.boundingBox.intersectsBox(mesh2.geometry.boundingBox);

                if (intersection) { // The shape geometries intersect.

                    //let lv_nspline = this.get_nspline_by_name(object2.name);

                    lv_result = {
                        min_x: bBox2.min.x,
                        min_y: bBox2.min.y,
                        max_x: bBox2.max.x,
                        max_y: bBox2.max.y,
                        object: object2
                        //nspline: lv_nspline
                    };
                }
                //else
                //{ // The shape geometries do not intersect.
                //	return false
                //}



            }

            catch (e) {

                alert('error GetTwoShapeIntersect: ' + e.stack);

            }
            return lv_result;

        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.get_object_by_name_via_search_area = function (po_search_area_object, pv_object_name) {


            let lo_search_object = null;


            try {

                po_search_area_object.traverse((object) => {
                    if (object.name === pv_object_name) {
                        lo_search_object = object;
                    }
                });

            }

            catch (e) {

                alert('error get_object_by_name_via_search_area: ' + e.stack);

            }

            return lo_search_object;
        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.get_object_name = function (pv_prefix, po_group) {


            let lv_result = "";

            if (po_group) {

                if (po_group.id) {
                    lv_result = pv_prefix + "_" + po_group.id;
                }
                else {
                    if (po_group.mesh.id) {

                        lv_result = pv_prefix + "_" + po_group.mesh.id;

                    }

                }
            }

            return lv_result;
        }


        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_random_number_int = function (pv_min, pv_max) {

            let lv_number_dec = (pv_max - pv_min + 1) * Math.random() + pv_min;
            let lv_number_int = Math.floor(lv_number_dec);

            return lv_number_int;
        }



        //------------------------------------------------------------------------
        CommonFunc.prototype.get_screenshots = async function (pv_url, po_united_model_data) {

            try {

                // Заполнение массива экранными элементами
                //let lar_screenshot_elements = [];

                //lar_screenshot_elements.push($("#id_div_visual_model")[2]);
                //lar_screenshot_elements.push($("#id_shape")[2]);

                let lo_active_side = get_active_side_shape_generator();

                //23012025 {
                //////let lo_element1 = document.querySelector(lo_active_side.id_prefix + "id_div_visual_model");
                //////let lo_element2 = lo_element1.children[2];
                //////lar_screenshot_elements.push(lo_element2);

                //////let lo_element3 = document.querySelector(lo_active_side.id_prefix + "id_shape");
                //////let lo_element4 = lo_element3.children[2];
                //////lar_screenshot_elements.push(lo_element4);

                //lar_screenshot_elements.push(lo_active_side.id_prefix_wo_sharp + "id_div_visual_model");
                //lar_screenshot_elements.push("#up_id_div_visual_model canvas");
                //lar_screenshot_elements.push(lo_active_side.id_prefix_wo_sharp + "id_shape");
                //lar_screenshot_elements.push("#up_id_shg_common canvas");
                //lar_screenshot_elements.push("#up_id_shape canvas");
                //lar_screenshot_elements.push("#up_id_div_visual_model canvas");

                //23012025 }

                // массив данных screenshots
                //let lar_sreenshot_data = [/*lar_screenshot_elements.length*/];

                //let lv_nstep = 0;

                //while (par_elements.length > 0) {

                /////////////////////////////await this.get_one_screenshot(pv_url, po_united_model_data, lv_nstep, lar_screenshot_elements, lar_sreenshot_data);

                //}

                ////po_united_model_data.screenshot = lar_sreenshot_data[0];
                ////po_united_model_data.up_side_screenshot = lar_sreenshot_data[1];

                ////let lv_str_united_model_data = JSON.stringify(po_united_model_data);

                ////this.send(pv_url, lv_str_united_model_data);


                let lv_dataURL = null;
                go_up_side_shape_generator.renderer.render(go_up_side_shape_generator.scene, go_up_side_shape_generator.camera);
                lv_dataURL = go_up_side_shape_generator.renderer.domElement.toDataURL('image/png');
                po_united_model_data.up_side_screenshot = lv_dataURL;

                go_lateral_side_shape_generator.renderer.render(go_lateral_side_shape_generator.scene, go_lateral_side_shape_generator.camera);
                lv_dataURL = go_lateral_side_shape_generator.renderer.domElement.toDataURL('image/png');
                po_united_model_data.lat_side_screenshot = lv_dataURL;

                go_end_side_shape_generator.renderer.render(go_end_side_shape_generator.scene, go_end_side_shape_generator.camera);
                lv_dataURL = go_end_side_shape_generator.renderer.domElement.toDataURL('image/png');
                po_united_model_data.end_side_screenshot = lv_dataURL;

                go_up_side_shape_generator.renderer_mod.render(go_up_side_shape_generator.scene_mod, go_up_side_shape_generator.camera_mod);
                lv_dataURL = go_up_side_shape_generator.renderer_mod.domElement.toDataURL('image/png');
                po_united_model_data.screenshot = lv_dataURL;


                //po_united_model_data.screenshot = par_sreenshot_data[1];
                //po_united_model_data.up_side_screenshot = par_sreenshot_data[0];

                let lv_str_united_model_data = JSON.stringify(po_united_model_data);
                this.send(pv_url, lv_str_united_model_data);

            }

            catch (e) {
                this.hideWaitingIndicator();
                alert('error get_screenshots: ' + e.stack);

            }

        }



        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_textmesh_name = function (pv_nrow, pv_ncol) {

            let lv_result = "";

            try {

                lv_result = "text_mesh_" + this.get_cell_text_label(pv_nrow, pv_ncol);
            }

            catch (e) {

                alert('error get_textmesh_name: ' + e.stack);

            }

            return lv_result;
        }




        //------------------------------------------------------------------------
        CommonFunc.prototype.guiUpdateDisplay = function (po_gui) {

            for (var i in po_gui.controllers) {

                po_gui.controllers[i].updateDisplay();
            }

        }



        //-----------------------------------------------------------------------------------
        // Функция для обработки изменений
        CommonFunc.prototype.handleColorChange = function (par_mutationsList, po_observer/*, pf_callback*/) {

            //let a = 2;

            for (let mutation of par_mutationsList) {

                if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
                    const lo_targetElement = mutation.target;
                    const lv_newColor = window.getComputedStyle(lo_targetElement).backgroundColor;

                    //pf_callback(lv_newColor);
                    ///////alert('Color= ' + lv_newColor);

                    //if (pf_callback) {
                    //	pf_callback(lo_targetElement, lv_newColor);
                    //}

                    //console.log(`Цвет элемента изменен на: ${newColor}`);

                    let lo_active_side = get_active_side_shape_generator();
                    lo_active_side.onColorChange(lv_newColor);
                    break;

                }
            }
        }

        ////// Целевой элемент, за которым нужно следить
        ////const targetElement = document.getElementById('myElement');

        ////// Создание экземпляра MutationObserver
        ////const observer = new MutationObserver(this.handleColorChange);

        ////// Параметры наблюдения
        ////const config = { attributes: true, attributeFilter: ['style'] };

        ////// Начало наблюдения за целевым элементом
        ////observer.observe(targetElement, config);

        //// Пример изменения цвета элемента
        //targetElement.style.backgroundColor = 'red';
        //}




        //-----------------------------------------------------------------------------------
        // Функция для преобразования RGB в число
        CommonFunc.prototype.hexToRgb = function (pv_hex) {

            //function hexToRgb(hex) {
            // Удаляем #, если он есть
            pv_hex = pv_hex.replace(/^#/, '');

            // Разбираем 3-значные форматы (например, #f0c → #ff00cc)
            if (pv_hex.length === 3) {
                pv_hex = pv_hex.split('').map(c => c + c).join('');
            }

            // Получаем значения R, G, B
            let r = parseInt(pv_hex.substring(0, 2), 16);
            let g = parseInt(pv_hex.substring(2, 4), 16);
            let b = parseInt(pv_hex.substring(4, 6), 16);

            //return `rgb(${r}, ${g}, ${b})`;


            return { r, g, b };


        }


        //---------------------------------------------------------------------------------------------
        // Функция для удаления индикатора ожидания
        //function hideLoadingIndicator() {

        CommonFunc.prototype.hideWaitingIndicator = function () {
            const waitingIndicator = document.getElementById('id_waiting-indicator');
            if (waitingIndicator) {
                waitingIndicator.remove();
            }
        }

        //// Пример использования
        //document.getElementById('start-operation').addEventListener('click', () => {
        //    // Показать индикатор ожидания
        //    showLoadingIndicator();

        //    // Имитация асинхронной операции
        //    setTimeout(() => {
        //        // Убрать индикатор ожидания
        //        hideLoadingIndicator();
        //        alert('Operation completed!');
        //    }, 3000); // 3 секунды ожидания
        //});




        //-----------------------------------------------------------------------------
        CommonFunc.prototype.init = function () {

            //-----------------------------------------------------------------------------

            this.$dialog_message.dialog({
                title: "Attention!",
                autoOpen: false,
                height: "auto", //100,
                open: this.on_open_dialog_message,
                buttons: {
                    "Close": function () {
                        $(this).dialog("close");
                    }
                },
                modal: true,
                resizable: false,
            });




            this.$dialog_question.dialog({
                title: "Attention!",
                autoOpen: false,
                height: "auto",

                ////buttons:
                ////	[
                ////		{
                ////			text: "Yes",
                ////			click: function () {
                ////				do_cancel_editing_row();
                ////				$(this).dialog("close");
                ////			}
                ////		},

                ////		{
                ////			text: "No",
                ////			click: function () { $(this).dialog("close"); }
                ////		}
                ////	],

                modal: true,
                resizable: false

            });
            //-------------------------------------------------------------------------------------------

        }




        //-----------------------------------------------------------------------------------
        // Проверка нахождения точки от мыши внутри прямоугольника
        CommonFunc.prototype.IsInsideRectangle = function (po_event, po_rectangle) {

            let lv_result = false;


            let lo_line_to_right;
            let lo_line_to_left;
            let lo_line_to_up;
            let lo_line_to_down;

            try {

                let lo_active_side = get_active_side_shape_generator();

                let lo_container = lo_active_side.container;

                let lo_pos = this.recalc_coord_event2world(lo_active_side.camera, lo_container, po_event.clientX, po_event.clientY);

                const lc_endline_right_x = 1000;
                const lc_endline_left_x = -1000;
                const lc_endline_up_y = 1000;
                const lc_endline_down_y = -1000;


                let lo_pos_plane = new THREE.Vector2(lo_pos.x, lo_pos.y);

                const lo_material = new THREE.LineBasicMaterial();

                let lar_points = [];

                // Line from mouse point to right
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lc_endline_right_x, lo_pos.y));
                let lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_right = new THREE.Line(lo_geometry, lo_material);
                //lo_active_side.scene.add(lo_line_to_right);

                // Line from mouse point to left
                lar_points = [];
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lc_endline_left_x, lo_pos.y));
                lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_left = new THREE.Line(lo_geometry, lo_material);
                //lo_active_side.scene.add(lo_line_to_left);

                // Line from mouse point to up
                lar_points = [];
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lc_endline_up_y));
                lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_up = new THREE.Line(lo_geometry, lo_material);
                //lo_active_side.scene.add(lo_line_to_up);

                // Line from mouse point to down
                lar_points = [];
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lc_endline_down_y));
                lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_down = new THREE.Line(lo_geometry, lo_material);
                //lo_active_side.scene.add(lo_line_to_down);

                //13122024 {
                ////let lo_intersect_to_right_object = lo_active_side.shapes.GetTwoShapeIntersect(lo_line_to_right, po_rectangle.shape);
                ////let lo_intersect_to_left_object = lo_active_side.shapes.GetTwoShapeIntersect(lo_line_to_left, po_rectangle.shape);
                ////let lo_intersect_to_up_object = lo_active_side.shapes.GetTwoShapeIntersect(lo_line_to_up, po_rectangle.shape);
                ////let lo_intersect_to_down_object = lo_active_side.shapes.GetTwoShapeIntersect(lo_line_to_down, po_rectangle.shape);


                let lo_intersect_to_right_object = lo_active_side.common_func.GetTwoShapeIntersect(lo_line_to_right, po_rectangle);
                let lo_intersect_to_left_object = lo_active_side.common_func.GetTwoShapeIntersect(lo_line_to_left, po_rectangle);
                let lo_intersect_to_up_object = lo_active_side.common_func.GetTwoShapeIntersect(lo_line_to_up, po_rectangle);
                let lo_intersect_to_down_object = lo_active_side.common_func.GetTwoShapeIntersect(lo_line_to_down, po_rectangle);


                //13122024 }


                if (lo_intersect_to_right_object
                    && lo_intersect_to_left_object
                    && lo_intersect_to_up_object
                    && lo_intersect_to_down_object
                ) {

                    lv_result = true;
                }

            }

            catch (e) {
                alert('error IsInsideRectangle: ' + e.stack);
            }

            //alert(lv_result);

            return lv_result;
        }



        //------------------------------------------------------------------------
        CommonFunc.prototype.make_model = function (po_sides_data, po_scene_mod) {


            let lv_url = "/Index?handler=SaveModel";

            let lo_exporter = new STLExporter();
            let lv_str_scene_mod_data = lo_exporter.parse(po_scene_mod);


            ////lv_str_scene_mod_data = lv_str_scene_mod_data.replace(/\n/g, '')  // удаление переноса строк
            ////lv_str_scene_mod_data = lv_str_scene_mod_data.replace(/\t/g, '')  // удаление переноса строк

            ////////////this.saveString(lv_str_scene_mod_data, 'my_model.stl');

            let lv_str_sides_data = JSON.stringify(po_sides_data);
            //this.send(lv_url, lv_str_sides_data);


            let lo_united_model_data = new typ_united_model_data();

            lo_united_model_data.model_name = $("#id_model_name")[0].value;
            lo_united_model_data.sides_data = lv_str_sides_data;
            lo_united_model_data.prev_model = lv_str_scene_mod_data;

            let lv_str_united_model_data = JSON.stringify(lo_united_model_data);


            //let lo_str_united_model_data = '{"sides_data":' + lv_str_sides_data + ',"prev_model":{"' + lv_str_scene_mod_data + '"}}';
            //let lo_str_united_model_data = lv_str_sides_data + "__@@@@__" + lv_str_scene_mod_data;



            this.send(lv_url, lv_str_united_model_data);


        }



        //------------------------------------------------------------------------
        CommonFunc.prototype.model_rotation = function (po_group) {

            let lo_active_side = get_active_side_shape_generator();

            if (lo_active_side.my_prefix != gc_id_prefix_end) { // 06122024


                if (lo_active_side.rotate_status == type_rotate_mode.None) {
                    return;
                }

                var lv_delta_rotation = this.get_delta_rotation(lo_active_side.rotate_status);

                po_group.rotation.y += lv_delta_rotation;

            }

        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.move_details_from_to_center = function (po_group, pv_slider_value) {

            let lv_koef = 1;

            var Obj = null;
            //if (!po_group || pv_delta_slider_value == 0) {
            if (!po_group) {
                return;
            }


            try {

                let lo_active_side = get_active_side_shape_generator();


                for (var lv_i = 0; lv_i < po_group.children.length; lv_i++) {

                    Obj = po_group.children[lv_i];

                    if (Obj instanceof THREE.Mesh) {

                        let lo_part_box = new THREE.Box3().setFromObject(Obj);


                        let lo_gabarits_obj = lo_active_side.model_parts_positions[lv_i];


                        let posx = 0;
                        let posz = 0;

                        let lv_minx = lo_gabarits_obj.min.x;
                        let lv_center_x = (lo_gabarits_obj.max.x + lo_gabarits_obj.min.x) / 2;


                        let lv_minz = lo_gabarits_obj.min.z;
                        let lv_center_z = (lo_gabarits_obj.max.z + lo_gabarits_obj.min.z) / 2;


                        posx = (lv_center_x / 5) * pv_slider_value * lv_koef;
                        posz = (lv_center_z / 5) * pv_slider_value * lv_koef;


                        Obj.position.set(
                            posx,
                            0,
                            posz
                        );
                    }
                }


                ////this.set_group_to_center(po_group);

            }

            catch (e) {

                //alert('error extractRGBComponents: ' + e.stack);

            }


        }


        //---------------------------------------------------------------------------------------------

        CommonFunc.prototype.on_open_dialog_message = function () {

            //let lo_active_side = get_active_side_shape_generator();

            //var lv_timeout = lo_active_side.common_func.get_message_timeout();///
            var lv_timeout = go_this.get_message_timeout();///

            setTimeout(
                function () {
                    ///setTimeout(function () {
                    /// //lc_div_dialog_feedback.dialog("close");
                    Constants.div_dialog_message.dialog("close");
                    ///}, 1500)

                }, lv_timeout)

        }


        //-----------------------------------------------------------------------------------
        CommonFunc.prototype.parseRGBString = function (rgbString) {
            // Используем регулярное выражение для извлечения значений
            const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);

            if (match) {
                // Преобразуем извлечённые строки в числа и создаём объект
                const [_, r, g, b] = match;
                return {
                    r: parseInt(r),
                    g: parseInt(g),
                    b: parseInt(b)
                };
            } else {
                throw new Error('Invalid RGB format');
            }
        }





        //-----------------------------------------------------------------------------------
        // Функция для преобразования RGB в число
        CommonFunc.prototype.rgbToNumber = function (pv_rgb) {

            let lo_rgb = this.extractRGBComponents(pv_rgb);

            // Преобразование каждого значения в шестнадцатеричный формат и объединение в строку
            let lv_result = ((1 << 24) + (lo_rgb.r << 16) + (lo_rgb.g << 8) + lo_rgb.b).toString(16).slice(1).toUpperCase();

            // Перевод в десятичную систему
            lv_result = parseInt(lv_result, 16);

            return lv_result;
        }

        //-----------------------------------------------------------------
        CommonFunc.prototype.read_file_from_server = async function (pv_url, pv_is_download_to_downloads_folder, pv_filename,
            pv_is_save_to_server, po_callback) {

            try {

                go_this.downloaded_filename = pv_filename;


                let response = await fetch(pv_url);


                if (!response.ok) {

                    $("#id_order_loading_indicator").hide(); // скрывакм индикатор загрузки

                    //throw new Error(`HTTP error! Status: ${response.status}`);
                    go_this.Show_message("Error reading file!", 2000);
                    return;

                }
                let lar_data = await response.blob();

                //------------------------------------------------------------------


                if (pv_is_download_to_downloads_folder) {

                    let lv_url = URL.createObjectURL(lar_data);
                    let a = document.createElement('a');
                    a.href = lv_url;
                    a.download = pv_filename; // имя файла, под которым сохраняем 
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    URL.revokeObjectURL(lv_url);

                    $("#id_order_loading_indicator").hide(); // скрывакм индикатор загрузки

                    go_this.Show_message("Model file downloaded", 2000);
                }

                if (pv_is_save_to_server) {
                    // Сохраняем файл на сервере генератора

                    //let lv_filename_zip = lo_active_side.model_prefix_filename + Constants.file_model_zip;
                    let lv_filename_zip = pv_filename;// + Constants.file_model_zip;

                    let lv_url = "/Index?handler="
                        + Constants.method_save_model_parts_zip_file
                        + "&filename=" + $("#id_model_name").val() //  lv_filename_zip
                        + "&chdata=" + Math.random().toString();


                    const formData = new FormData();

                    formData.append('file', lar_data);


                    try {

                        let response = await fetch(lv_url,
                            {
                                method: 'POST',
                                body: formData //lar_data,
                            });

                        if (response.ok) {
                            //const result = await response.json();
                            //alert(`File uploaded successfully: ${result.filePath}`);
                        } else {
                            $("#id_order_loading_indicator").hide(); // скрывакм индикатор загрузки

                            //alert("File upload failed!");
                            go_this.Show_message("Error reading file!", 2000);

                        }
                    } catch (error) {
                        //console.error("Error uploading file:", error);
                        alert("An error occurred!");
                        go_this.Show_message("Error reading file!", 2000);
                    }


                    po_callback();  // Удаление временных файлов с api-сервера


                }



            } catch (e) {

                $("#id_order_loading_indicator").hide(); // скрывакм индикатор загрузки

                //alert('error read_file_from_server: ' + e.stack);

                go_this.Show_message("Error reading file!", 2000);
            }




        }





        //////////    try {


        //////////        go_this.downloaded_filename = pv_downloaded_filename;
        //////////        //get_read_result_refresh_premodel(lv_url);


        //////////        ////--------------------------------------------------
        //////////        //async function get_read_result_refresh_premodel(pv_url) {
        //////////        //--------------------------------------------------
        //////////        ///*await*/ $.get(pv_url, "", this.oncomplete_read_file_from_server);
        //////////        /*await*/ $.get(pv_url, "", go_this.oncomplete_read_file_from_server);
        //////////        //}


        //////////    }

        //////////    catch (e) {


        //////////        //lo_active_side.model_params_changed = false; //04102024
        //////////        //lo_passive_side.model_params_changed = false; //04102024

        //////////        //let lv_is_before = false;
        //////////        //lo_active_side.do_before_after_model_request(lv_is_before, false);
        //////////        //lo_passive_side.do_before_after_model_request(lv_is_before, false);

        //////////        alert('error read_file_from_server: ' + e.stack);

        //////////    }

        //////////}



        //////-------------------------------------------------------------------
        ////CommonFunc.prototype.oncomplete_read_file_from_server = function (po_data) {

        ////    try {

        ////        //let lv_data = new Blob([po_data], { type: "application/octet-stream" }); //{ type: "text/plain" });
        ////        let lv_data = new Blob([po_data], { type: "application/zip" }); //{ type: "text/plain" });
        ////        // let lv_data = new Blob([po_data], { type: "text/plain" });

        ////        let lv_url = URL.createObjectURL(lv_data);
        ////        //let lv_url = URL.createObjectURL(po_data);

        ////        const a = document.createElement("a");
        ////        a.href = lv_url;
        ////        a.download = go_this.downloaded_filename; // "downloaded_file.bin";
        ////        document.body.appendChild(a);
        ////        a.click();
        ////        document.body.removeChild(a);
        ////        URL.revokeObjectURL(lv_url);


        ////        document.body.removeChild(a); // Удаляем ссылку из DOM

        ////        // Освобождаем память, удаляя объект URL
        ////        URL.revokeObjectURL(lv_url);


        ////    }

        ////    catch (e) {

        ////        alert('error oncomplete_read_file_from_server: ' + e.stack);

        ////    }

        ////}



        //-----------------------------------------------------------------------------
        CommonFunc.prototype.recalc_coord_event2world = function (po_camera, po_container, pv_event_clientX, pv_event_clientY) {

            let lo_pos = null;

            let lv_moveMouse = new THREE.Vector2();

            try {

                const { top, left, width, height } = po_container.getBoundingClientRect();


                // пересчёт координат с учётом положения контейнера three.js
                lv_moveMouse.x = ((pv_event_clientX - left) / width) * 2 - 1;
                lv_moveMouse.y = - ((pv_event_clientY - top) / height) * 2 + 1;

                lo_pos = this.screenToWorld(

                    lv_moveMouse.x,
                    lv_moveMouse.y,

                    //20122024 {
                    //po_container.clientWidth,
                    //po_container.clientHeight,
                    //20122024 }

                    po_camera
                )




                return lo_pos;

            }

            catch (e) {

                alert('error screenToWorld: ' + e.stack);

            }


        }


        //----------------------------------------------------------------------------------
        // Remove all objects

        CommonFunc.prototype.removeObjectsWithChildren = function (po_obj, pv_is_removeFromParent, pv_is_removeGeometry, pv_is_removeMaterial) {

            //03022025 {
            if (po_obj == null) {
                return;
            }
            //03022025 }

            if (po_obj.children) { //03022025 

                if (po_obj.children.length > 0) {
                    for (var x = po_obj.children.length - 1; x >= 0; x--) {
                        //07032025 this.removeObjectsWithChildren(po_obj.children[x], true);
                        this.removeObjectsWithChildren(po_obj.children[x], pv_is_removeFromParent, pv_is_removeGeometry, pv_is_removeMaterial); //07032025
                    }
                }
            }

            if (pv_is_removeGeometry) {

                if (po_obj.geometry) {
                    po_obj.geometry.dispose();
                }
            }

            if (pv_is_removeMaterial) {

                if (po_obj.material) {

                    if (po_obj.material.length) {
                        for (let i = 0; i < po_obj.material.length; ++i) {

                            if (po_obj.material[i].map) po_obj.material[i].map.dispose();
                            if (po_obj.material[i].lightMap) po_obj.material[i].lightMap.dispose();
                            if (po_obj.material[i].bumpMap) po_obj.material[i].bumpMap.dispose();
                            if (po_obj.material[i].normalMap) po_obj.material[i].normalMap.dispose();
                            if (po_obj.material[i].specularMap) po_obj.material[i].specularMap.dispose();
                            if (po_obj.material[i].envMap) po_obj.material[i].envMap.dispose();

                            po_obj.material[i].dispose()
                        }
                    }
                    else {
                        if (po_obj.material.map) po_obj.material.map.dispose();
                        if (po_obj.material.lightMap) po_obj.material.lightMap.dispose();
                        if (po_obj.material.bumpMap) po_obj.material.bumpMap.dispose();
                        if (po_obj.material.normalMap) po_obj.material.normalMap.dispose();
                        if (po_obj.material.specularMap) po_obj.material.specularMap.dispose();
                        if (po_obj.material.envMap) po_obj.material.envMap.dispose();

                        po_obj.material.dispose();
                    }
                }
            }


            if (pv_is_removeFromParent) {

                if (po_obj.parent) {
                    po_obj.parent.remove(po_obj);
                    //if (po_obj.removeFromParent) {
                    //    po_obj.removeFromParent();
                    //}
                }

            }

            po_obj = null;

            return true;
        }


        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.show_question = function (pv_message, pv_callbackOk, pv_callbackNo, pv_callbackCancel) {

            var lv_dialog = this.$dialog_question;

            lv_dialog[0].innerText = pv_message;

            if (pv_callbackCancel == null) {

                lv_dialog.dialog("option", "buttons",
                    [
                        {
                            text: "Yes",
                            //icon: "ui-icon-check",
                            click: pv_callbackOk
                            //click: function () {
                            //    pv_callback_ok();
                            //    $(this).dialog("close");
                            //}
                        },
                        {
                            text: "No",
                            click: pv_callbackNo
                        }
                    ]
                );
            }
            else {

                lv_dialog.dialog("option", "buttons",
                    [
                        {
                            text: "Да",
                            //icon: "ui-icon-check",
                            click: pv_callbackOk
                            //click: function () {
                            //    pv_callback_ok();
                            //    $(this).dialog("close");
                            //}
                        },
                        {
                            text: "Нет",
                            click: pv_callbackNo
                        }
                        ,
                        {
                            text: "Отмена",
                            click: pv_callbackCancel
                        }
                    ]
                );
            }

            lv_dialog.dialog("open");

            return;
        }

        //------------------------------------------------------------------------
        CommonFunc.prototype.save_model = async function (po_sides_data, po_scene_mod) {


            try {
                this.showWaitingIndicator('Saving model..');

                let lo_active_side = get_active_side_shape_generator();

                ///////////////////23102024 let lv_url = "/Index?handler=SaveModel";

                let lo_exporter = new STLExporter();
                let lv_str_scene_mod_data = lo_exporter.parse(po_scene_mod);


                ////lv_str_scene_mod_data = lv_str_scene_mod_data.replace(/\n/g, '')  // удаление переноса строк
                ////lv_str_scene_mod_data = lv_str_scene_mod_data.replace(/\t/g, '')  // удаление переноса строк

                ////////////this.saveString(lv_str_scene_mod_data, 'my_model.stl');

                let lv_str_sides_data = JSON.stringify(po_sides_data);
                //this.send(lv_url, lv_str_sides_data);


                let lo_united_model_data = new typ_united_model_data();

                lo_united_model_data.model_name = $("#id_model_name")[0].value;
                lo_united_model_data.sides_data = lv_str_sides_data;
                lo_united_model_data.prev_model = lv_str_scene_mod_data;

                let lo_element1 = document.querySelector(lo_active_side.id_prefix + "id_div_visual_model");
                let lo_element2 = lo_element1.children[2];




                //this.get_screenshot(lo_element2, lo_united_model_data);

                let lv_url = "/Index?handler=SaveModel"; /*+ "&chdata=" + Math.random().toString();*/
                await this.get_screenshots(lv_url, lo_united_model_data);


            }

            catch (e) {

                alert('error save_model: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        CommonFunc.prototype.saveString = function (text, filename) {

            this.save(new Blob([text], { type: 'text/plain' }), filename);

        }


        //---------------------------------------------------------------------------
        CommonFunc.prototype.screenToWorld = function (pv_x, pv_y, /* 20122024 pv_canvasWidth, pv_canvasHeight,*/ po_camera) {

            try {
                let lv_coords = new THREE.Vector3(pv_x, pv_y, 0);
                let lo_worldPosition = new THREE.Vector3();
                let lo_plane = new THREE.Plane(new THREE.Vector3());
                let lo_raycaster = new THREE.Raycaster();
                lo_raycaster.setFromCamera(lv_coords, po_camera);

                return lo_raycaster.ray.intersectPlane(lo_plane, lo_worldPosition);

            }

            catch (e) {

                alert('error screenToWorld: ' + e.stack);

            }


        }




        //------------------------------------------------------------------------
        CommonFunc.prototype.send = async function (pv_url, po_data_to_send/*, po_this*/) {

            try {

                let response = await fetch(pv_url, {
                    method: "POST",
                    headers: {
                        //"Accept": "application/json"
                        "Content-Type": "application/json"
                    },

                    body: po_data_to_send

                });

                //const message = await response.json();
                const message = await response.text();


                this.hideWaitingIndicator();

                let lo_active_side = get_active_side_shape_generator();

                let lv_modelname = $("#id_model_name").val();
                let lv_message_text = 'Model "' + lv_modelname + '" saved';
                lo_active_side.common_func.Show_message(lv_message_text, 1500);

            }

            catch (e) {

                this.hideWaitingIndicator();

                alert('error send: ' + e.stack);
            }
        }







        //////------------------------------------------------------------------------
        ////CommonFunc.prototype.get_one_screenshot = async function (pv_url, po_united_model_data, pv_nstep, par_screenshot_elements, par_sreenshot_data) {

        ////    try {

        ////        //23012025 {


        ////        ////if (par_screenshot_elements.length > 0) {



        ////        ////let lv_element = par_screenshot_elements.pop();

        ////        ////html2canvas(lv_element).then((po_canvas) => {

        ////        ////    par_sreenshot_data[pv_nstep++] = po_canvas.toDataURL('image/png');

        ////        ////    this.on_fillsreenshot(
        ////        ////        this.get_one_screenshot(pv_url, po_united_model_data, pv_nstep, par_screenshot_elements, par_sreenshot_data));

        ////        ////});



        ////        ////////requestAnimationFrame(() => {
        ////        //////for (let id of par_screenshot_elements) {


        ////        //////    //let element = document.getElementById(id /*par_screenshot_elements.pop()*/);
        ////        //////    //let element = $("#up_id_shg_common canvas")[0];
        ////        //////    //let element = $("#up_id_shape canvas")[0];

        ////        //////    var element = $(id)[0];

        ////        //////    //let canvas = null;
        ////        //////    //await requestAnimationFrame(() => {
        ////        //////    //    canvas = /*await*/ html2canvas(element);
        ////        //////    //    par_sreenshot_data.push(canvas.toDataURL('image/png'));
        ////        //////    //});




        ////        //////    ////let canvas = null;
        ////        //////    //await new Promise(resolve => {
        ////        //////    //    requestAnimationFrame(async () => {
        ////        //////    //        let canvas = await html2canvas(element);
        ////        //////    //        par_sreenshot_data.push(canvas.toDataURL('image/png'));
        ////        //////    //        resolve();
        ////        //////    //    });
        ////        //////    //});


        ////        //////    //await new Promise(resolve => {
        ////        //////    //    //requestAnimationFrame(async () => {
        ////        //////    //    let canvas = await html2canvas(element);

        ////        //////    //    renderer.render(scene, camera);
        ////        //////    //    const dataURL = renderer.domElement.toDataURL('image/png');

        ////        //////    //        par_sreenshot_data.push(canvas.toDataURL('image/png'));
        ////        //////    //        resolve();
        ////        //////    //    //});
        ////        //////    //});


        ////        //////}

        ////        //});

        ////        ////}
        ////        ////else {

        ////        //23012025 }


        ////        // Конец чтения screenshots


        ////        let dataURL = null;
        ////        //requestAnimationFrame(/*async*/() => {
        ////            go_up_side_shape_generator.renderer.render(go_up_side_shape_generator.scene, go_up_side_shape_generator.camera);
        ////            dataURL = go_up_side_shape_generator.renderer.domElement.toDataURL('image/png');
        ////        //});
        ////        par_sreenshot_data.push(dataURL);

        ////        //requestAnimationFrame(/*async*/() => {
        ////            go_up_side_shape_generator.renderer_mod.render(go_up_side_shape_generator.scene_mod, go_up_side_shape_generator.camera_mod);
        ////            dataURL = go_up_side_shape_generator.renderer_mod.domElement.toDataURL('image/png');
        ////        //});
        ////        par_sreenshot_data.push(dataURL);



        ////        po_united_model_data.screenshot = par_sreenshot_data[1];
        ////        po_united_model_data.up_side_screenshot = par_sreenshot_data[0];



        ////        let lv_str_united_model_data = JSON.stringify(po_united_model_data);
        ////        this.send(pv_url, lv_str_united_model_data);



        ////        ////}
        ////    }
        ////    catch (e) {

        ////        alert('error get_one_screenshot: ' + e.stack);

        ////    }
        ////}



        //22012025 }










        ////////////------------------------------------------------------------------------
        //////////CommonFunc.prototype.get_screenshot = function ($pv_element, po_united_model_data) {

        //////////    // Select the element that you want to capture
        //////////    //let captureElement = $pv_element;


        //////////    try {

        //////////        //21012025 {
        //////////        let lv_url = null; //21012025
        //////////        let lv_str_united_model_data = null;//21012025
        //////////        //21012025 }



        //////////        html2canvas($pv_element).then((po_canvas) => {

        //////////            po_united_model_data.screenshot = po_canvas.toDataURL(/*"image/png"*/)

        //////////            //21012025 {
        //////////            //let lv_url = "/Index?handler=SaveModel"; //21012025
        //////////            //let lv_str_united_model_data = JSON.stringify(po_united_model_data);//21012025
        //////////            lv_url = "/Index?handler=SaveModel" + "&chdata=" + Math.random().toString();
        //////////            lv_str_united_model_data = JSON.stringify(po_united_model_data);//21012025
        //////////            this.on_fillsreenshot(lv_url, lv_str_united_model_data /*po_united_model_data*/);
        //////////            //21012025 }

        //////////        });


        //////////        ////////html2canvas(captureElement/*.children()*/,
        //////////        ////////    {
        //////////        ////////        onrendered: function (canvas) {

        //////////        ////////            var lv_image = canvas.toDataURL();
        //////////        ////////            //if (lv_image.length > cv_ModelImage_length)
        //////////        ////////            po_united_model_data.screenshot = lv_image;
        //////////        ////////            this.on_fillsreenshot(po_united_model_data);

        //////////        ////////        }

        //////////        ////////    }
        //////////        ////////);

        //////////    }

        //////////    catch (e) {

        //////////        alert('error screenshot: ' + e.stack);

        //////////    }

        //////////}
        ////////////------------------------------------------------------------------------
        //////////CommonFunc.prototype.on_fillsreenshot = function (pv_url, pv_str_data /*po_united_model_data*/) {

        //////////    //let lv_url = "/Index?handler=SaveModel";
        //////////    //21012025 let lv_str_united_model_data = JSON.stringify(po_united_model_data);
        //////////    //21012025 this.send(lv_url, lv_str_united_model_data);

        //////////    this.send(pv_url, pv_str_data);

        //////////}





        //22012025 {



        //////------------------------------------------------------------------------
        ////    CommonFunc.prototype.OnComple_save_model = function (po_data) {

        ////    let lo_active_side = get_active_side_shape_generator();


        ////    }

        //------------------------------------------------------------------------
        CommonFunc.prototype.onSuccessSaveModel = function (text, filename) {

            //alert("onSuccessSaveModel");

        }
        //------------------------------------------------------------------------
        CommonFunc.prototype.onErrorSaveModel = function (text, filename) {

            //alert("onErrorSaveModel");

        }

        //------------------------------------------------------------------------

        CommonFunc.prototype.save = function (blob, filename) {

            //let lo_link = $("#id_anch_for_save_model");

            lo_link.href = URL.createObjectURL(blob);
            lo_link.download = filename;
            lo_link.click();




        }

        //	this.init();




        //-----------------------------------------------------------------------------------
        // преобразование десятичного числа цвета в строку - три группы по два шестнадцатиричных числа (#aabbcc)
        CommonFunc.prototype.decimalToHexColor = function (decimalColor) {

            return '#' + decimalColor.toString(16).padStart(6, '0');

        }



        //------------------------------------------------------------------------

        //======================================================================================
        CommonFunc.prototype.set_group_to_center = function (po_group) {

            // from http://stackoverflow.com/questions/28848863/threejs-how-to-rotate-around-objects-own-center-instead-of-world-center

            let objBbox = new THREE.Box3().setFromObject(po_group);

            // Geometry vertices centering to world axis
            ///////var bboxCenter = objBbox.getCenter().clone();


            let lo_center = new THREE.Vector3(0, 0, 0);

            objBbox.getCenter(lo_center);//
            var bboxCenter = lo_center.clone();//

            bboxCenter.multiplyScalar(-1);

            po_group.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.geometry.translate(bboxCenter.x, bboxCenter.y, bboxCenter.z);
                }
            });

            ///////////////////////objBbox.setFromObject(po_group); // Update the bounding box


        }


        //////------------------------------------------------------------------------------------------
        ////GridSelectModels.prototype.oncomplete_check_file_exist_on_server = function (po_data) {

        ////    try {

        ////        let lo_active_side = get_active_side_shape_generator();


        ////    }

        ////    catch (e) {

        ////        alert('error oncomplete_check_file_exist_on_server: ' + e.stack);

        ////    }


        ////}





















        //============================================================================================

        ////CommonFunc.prototype.fitCameraToObject = function (scene, camera, object, offset, controls) {

        ////	offset = offset || 1.25;

        ////	const boundingBox = new THREE.Box3();

        ////	// get bounding box of object - this will be used to setup controls and camera
        ////	boundingBox.setFromObject(object);

        ////	let center = new THREE.Vector3(/*0, 1, 0*/);

        ////	//const center = boundingBox.getCenter();
        ////	boundingBox.getCenter(center);

        ////	let size = new THREE.Vector3();
        ////	//const size = boundingBox.getSize();
        ////	boundingBox.getSize(size);

        ////	// get the max side of the bounding box (fits to width OR height as needed )
        ////	const maxDim = Math.max(size.x, size.y, size.z);
        ////	const fov = camera.fov * (Math.PI / 180);
        ////	let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2)); //Applied fifonik correction

        ////	cameraZ *= offset; // zoom out a little so that objects don't fill the screen

        ////	// <--- NEW CODE
        ////	//Method 1 to get object's world position
        ////	scene.updateMatrixWorld(); //Update world positions
        ////	var objectWorldPosition = new THREE.Vector3();
        ////	objectWorldPosition.setFromMatrixPosition(object.matrixWorld);

        ////	//Method 2 to get object's world position
        ////	//objectWorldPosition = object.getWorldPosition();

        ////	const directionVector = camera.position.sub(objectWorldPosition); 	//Get vector from camera to object
        ////	const unitDirectionVector = directionVector.normalize(); // Convert to unit vector

        ////	// bvi {
        ////	var lv_pos = new THREE.Vector3();

        ////	lv_pos = unitDirectionVector.multiplyScalar(cameraZ); //Multiply unit vector times cameraZ distance
        ////	//camera.position = unitDirectionVector.multiplyScalar(cameraZ); //Multiply unit vector times cameraZ distance
        ////	camera.position.x = lv_pos.x;
        ////	camera.position.y = lv_pos.y;
        ////	camera.position.z = lv_pos.z;
        ////	// bvi }


        ////	camera.lookAt(objectWorldPosition); //Look at object
        ////	// --->

        ////	const minZ = boundingBox.min.z;
        ////	const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;

        ////	camera.far = cameraToFarEdge * 3;
        ////	camera.updateProjectionMatrix();

        ////	if (controls) {

        ////		// set camera to rotate around center of loaded object
        ////		controls.target = center;

        ////		// prevent camera from zooming out far enough to create far plane cutoff
        ////		controls.maxDistance = cameraToFarEdge * 2;

        ////		controls.saveState();

        ////	} else {

        ////		camera.lookAt(center)

        ////	}
        ////}


        //--------------------------------------------------------------------------------------

        ////CommonFunc.prototype.fitCameraToCenteredObject = function (camera, object, offset, orbitControls) {
        ////	const boundingBox = new THREE.Box3();
        ////	boundingBox.setFromObject(object);

        ////	var middle = new THREE.Vector3();
        ////	var size = new THREE.Vector3();
        ////	boundingBox.getSize(size);

        ////	// figure out how to fit the box in the view:
        ////	// 1. figure out horizontal FOV (on non-1.0 aspects)
        ////	// 2. figure out distance from the object in X and Y planes
        ////	// 3. select the max distance (to fit both sides in)
        ////	//
        ////	// The reason is as follows:
        ////	//
        ////	// Imagine a bounding box (BB) is centered at (0,0,0).
        ////	// Camera has vertical FOV (camera.fov) and horizontal FOV
        ////	// (camera.fov scaled by aspect, see fovh below)
        ////	//
        ////	// Therefore if you want to put the entire object into the field of view,
        ////	// you have to compute the distance as: z/2 (half of Z size of the BB
        ////	// protruding towards us) plus for both X and Y size of BB you have to
        ////	// figure out the distance created by the appropriate FOV.
        ////	//
        ////	// The FOV is always a triangle:
        ////	//
        ////	//  (size/2)
        ////	// +--------+
        ////	// |       /
        ////	// |      /
        ////	// |     /
        ////	// | F° /
        ////	// |   /
        ////	// |  /
        ////	// | /
        ////	// |/
        ////	//
        ////	// F° is half of respective FOV, so to compute the distance (the length
        ////	// of the straight line) one has to: `size/2 / Math.tan(F)`.
        ////	//
        ////	// FTR, from https://threejs.org/docs/#api/en/cameras/PerspectiveCamera
        ////	// the camera.fov is the vertical FOV.

        ////	const fov = camera.fov * (Math.PI / 180);
        ////	const fovh = 2 * Math.atan(Math.tan(fov / 2) * camera.aspect);
        ////	let dx = size.z / 2 + Math.abs(size.x / 2 / Math.tan(fovh / 2));
        ////	let dy = size.z / 2 + Math.abs(size.y / 2 / Math.tan(fov / 2));
        ////	let cameraZ = Math.max(dx, dy);

        ////	// offset the camera, if desired (to avoid filling the whole canvas)
        ////	if (offset !== undefined && offset !== 0) cameraZ *= offset;

        ////	camera.position.set(0, 0, cameraZ);

        ////	// set the far plane of the camera so that it easily encompasses the whole object
        ////	const minZ = boundingBox.min.z;
        ////	const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;

        ////	camera.far = cameraToFarEdge * 3;
        ////	camera.updateProjectionMatrix();

        ////	////if (orbitControls !== undefined) {
        ////	////	// set camera to rotate around the center
        ////	////	orbitControls.target = new THREE.Vector3(0, 0, 0);

        ////	////	// prevent camera from zooming out far enough to create far plane cutoff
        ////	////	orbitControls.maxDistance = cameraToFarEdge * 2;
        ////	////}
        ////};


        //////CommonFunc.prototype.fitCameraToObject = function (camera, object, offset, controls) {

        //////	offset = offset || 1.25;

        //////	const boundingBox = new THREE.Box3();

        //////	// get bounding box of object - this will be used to setup controls and camera
        //////	boundingBox.setFromObject(object);

        //////	//const center = boundingBox.getCenter();
        //////	let center = new THREE.Vector3();
        //////	boundingBox.getCenter(center);

        //////	//const size = boundingBox.getSize();
        //////	let size = new THREE.Vector3();
        //////	//const size = boundingBox.getSize();
        //////	boundingBox.getSize(size);

        //////	// get the max side of the bounding box (fits to width OR height as needed )
        //////	const maxDim = Math.max(size.x, size.y, size.z);
        //////	const fov = camera.fov * (Math.PI / 180);
        //////	let cameraZ = Math.abs(maxDim / 4 * Math.tan(fov * 2));


        //////	cameraZ = 100;// bvi



        //////	////////////////cameraZ *= offset; // zoom out a little so that objects don't fill the screen

        //////	////////////////camera.position.z = cameraZ;

        //////	const minZ = boundingBox.min.z;
        //////	const cameraToFarEdge = (minZ < 0) ? -minZ + cameraZ : cameraZ - minZ;

        //////	//bvi camera.far = cameraToFarEdge * 3;

        //////	camera.far = cameraToFarEdge * 10;// bvi


        //////	camera.updateProjectionMatrix();

        //////	if (controls) {

        //////		// set camera to rotate around center of loaded object
        //////		controls.target = center;

        //////		// prevent camera from zooming out far enough to create far plane cutoff
        //////		controls.maxDistance = cameraToFarEdge * 2;

        //////		controls.saveState();

        //////	} else {

        //////		camera.lookAt(center)

        //////	}
        //////}



        //------------------------------------------------------------------------
        CommonFunc.prototype.build_scenes_by_sides_data = function (po_sides_data) {

            //---------------------------------------------------------------------------
            // test data {
            //let lo_active_side_shape_generator = get_active_side_shape_generator();
            //let lo_passive_side_shape_generator = get_passive_side_shape_generator();

            //let lo_sides_data = lo_active_side_shape_generator.read_model_sides_data();
            // test data }
            //---------------------------------------------------------------------------


            ////this.clearScene(lo_active_side_shape_generator.scene);
            ////this.clearScene(lo_passive_side_shape_generator.scene);


        }




        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.Show_message = function (pv_message, pv_timeout) {

            var lv_message_timeout;

            if (typeof (pv_timeout) == "undefined") {

                lv_message_timeout = Constants.timeout_dialog_message_ms;
            }
            else {
                lv_message_timeout = pv_timeout;

            }

            this.set_message_timeout(lv_message_timeout);

            Constants.div_dialog_message[0].innerText = pv_message;
            Constants.div_dialog_message.dialog("open");

        }
        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.set_message_timeout = function (pv_timeout) {
            //14012025 this.message_timeout = pv_timeout;
            go_this.message_timeout = pv_timeout;//14012025 
        }

        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.get_message_timeout = function () {
            //14012025 return this.message_timeout;
            return go_this.message_timeout; //14012025
        }




        //---------------------------------------------------------------------------------------------
        CommonFunc.prototype.showWaitingIndicator = function (pv_message) {
            //function showLoadingIndicator() {
            let waitingIndicator = document.createElement('div');
            waitingIndicator.id = 'id_waiting-indicator';

            const spinner = document.createElement('div');
            spinner.className = 'my_spinner';
            const text = document.createElement('span');
            //text.textContent = 'Loading...';
            text.textContent = pv_message;

            waitingIndicator.appendChild(spinner);
            waitingIndicator.appendChild(text);

            document.body.appendChild(waitingIndicator);
        }




        //-----------------------------------------------------------------------------------
        // Сортировка массива по указанному свойству
        CommonFunc.prototype.sortByProperty = function (par_array, pv_property) {

            return par_array.sort((a, b) => {
                if (a[pv_property] < b[pv_property]) {
                    return -1;
                }
                else {
                    if (a[pv_property] > b[pv_property]) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            }
            );
        }





        //======================================================================================
        //======================================================================================
        //======================================================================================



        //---------------------------------------------------------------------------
        //---------------------------------------------------------------------------


    }  // if (typeof this.create_rectangle !== "function")

    //====================================================================


    this.init();

    //this.create_commonFunc();


}

// end Class CommonFunc
//=====================================================================

import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"


////import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
////import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
////import { TransformControls } from 'three/addons/controls/TransformControls.js';

import {
    get_active_side_shape_generator,
    get_passive_side_shape_generator
} from './my_shape_generator.js';

//import {
//    struc_gabarits,
//    struc_segment_transform_data,
//    cv_spline_name_prefix,
//    cv_segment_name_prefix
//} from "./my_common_types.js";


import {
    struc_gabarits,
    struc_segment_transform_data,
    cv_spline_group_name_prefix,
    cv_spline_name_prefix,
    cv_segment_group_name_prefix,
    cv_segment_name_prefix,
    typ_mesh_colors

} from "./my_common_types.js";




import { CommonFunc } from './my_common_func.js';

//11062024 {
//var cv_node_diameter = 0.7;
//var cv_node_size = 2;
//11062024 }

//=============================================================================================

// Class Segment
export function Segments(
    po_main
    //pv_count_allsplines,
    //pv_count_allsegments,
    //pv_nspline,
    //pv_nsegment,
    //po_beg_point,
    //po_segment_transform_data
    //pv_is_move_mode
    /*, pv_kx, pv_ky*/
    //po_params
) {

    var cv_node_diameter = 0.7;// 1.2;//04082024  0.9; // 0.7; размер точки выделенного сегмента
    var cv_node_size = 2; // 3; // 04082024 3; // 2;


    // Свойства
    //--------------------------------------------------------------------------------------------------

    this.main = po_main;
    this.params = po_main.params;

    this.circle_geometry = new THREE.CircleGeometry(cv_node_diameter);
    //09092024 this.square_geometry = new THREE.BoxGeometry(cv_node_size, cv_node_size*2, 0);
    this.square_geometry = new THREE.BoxGeometry(cv_node_size, cv_node_size * 1.5, 0);// 09092024
    this.material = new THREE.MeshLambertMaterial({ color: 0x0000ff	/*//visible: true //false*/ });




    ////this.nspline = pv_nspline;
    ////this.nsegment = pv_nsegment;
    this.count_allsplines = null;// pv_count_allsplines;
    this.count_allsegments = null;// pv_count_allsegments;

    this.beg_point = null;// po_beg_point;
    //this.pv_kx = pv_kx;
    //this.pv_ky = pv_ky;

    ////this.ar_segment_points = [];
    ////this.ar_indices_segment_points = [];//  {nspline, nsegment_in_spline, npoint_in_segment, point }

    this.segment_transform_data = null; // po_segment_transform_data;

    /*//this.pv_is_move_mode = pv_is_move_mode;*/

    this.ar_initial_segment_points = [
        new THREE.Vector3(0, 0, 0),				// 0
        new THREE.Vector3(-1.08, 3.11, 0),		// 1
        new THREE.Vector3(-2.97, 4.59, 0), 		// 2
        new THREE.Vector3(-5.68, 3.51, 0),		// 3
        new THREE.Vector3(-6.76, 6.76, 0),		// 4
        new THREE.Vector3(-5.27, 9.59, 0),		// 5
        new THREE.Vector3(-1.62, 9.86, 0),		// 6
        new THREE.Vector3(3.11, 5.27, 0),		// 7
        new THREE.Vector3(5.81, 4.59, 0),		// 8
        new THREE.Vector3(6.62, 7.16, 0),		// 9
        new THREE.Vector3(3.51, 14.05, 0),		// 10
        new THREE.Vector3(6.08, 21.22, 0),		// 11
        new THREE.Vector3(5.54, 25.68, 0),		// 12
        new THREE.Vector3(2.3, 25.14, 0),		// 13
        new THREE.Vector3(-0.27, 17.16, 0),		// 14
        new THREE.Vector3(-2.43, 16.22, 0),		// 15
        new THREE.Vector3(-4.19, 18.11, 0),		// 16
        new THREE.Vector3(-3.78, 22.7, 0),		// 17
        new THREE.Vector3(-6.76, 27.03, 0),		// 18
        new THREE.Vector3(-5.14, 29.46, 0),		// 19
        new THREE.Vector3(-0.81, 27.57, 0),		// 20
        new THREE.Vector3(0.81, 29.73, 0),		// 21

        //11022025 new THREE.Vector3(-0.68, 31.76, 0),		// 22
        new THREE.Vector3(0.68, 31.76, 0),					// 22 11022025

        new THREE.Vector3(0, 33.78, 0)			// 23		

    ];
    //this.name_prefix = "segment";

    //=====================================================================

    if (typeof this.redraw_segment != "function") {
        //	return;
        //}

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------

        //////Segment.prototype.recalc_segment_points = function () {

        //////	this.ar_segment_points.splice(0, this.ar_segment_points.length)
        //////	for (let i = 0; i < this.ar_initial_segment_points.length; i++) {
        //////		this.ar_segment_points.push(new THREE.Vector2(
        //////			(this.ar_initial_segment_points[i].x + this.beg_point.x) /** this.pv_kx*/,
        //////			(this.ar_initial_segment_points[i].y + this.beg_point.y) /** this.pv_ky*/
        //////		)
        //////		)

        //////	}

        /*//}*/



        ////////----------------------------------------------------------
        //////Segments.prototype.create_segment_group_points_curve = function (pv_is_first_segment, pv_is_last_segment, po_segment_beg_point) {


        //////    let lo_segment_beg_point = null;

        //////    try {

        //////        let lo_segment_group = new THREE.Group();
        //////        lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

        //////        let lv_segment_id = this.main.common_func.get_guid();

        //////        //let lv_is_firs_segment;
        //////        //if (lv_i == 0) {
        //////        //    lv_is_firs_segment = true;
        //////        //}
        //////        //else {
        //////        //    lv_is_firs_segment = false;
        //////        //}

        //////        //let lv_is_last_segment;
        //////        //if (lv_i == this.main.params.spline_amount_segments - 1) {
        //////        //    lv_is_last_segment = true;
        //////        //}
        //////        //else {
        //////        //    lv_is_last_segment = false;
        //////        //}


        //////        let lo_segment_data = this.main.segments.create_segment(
        //////            lo_segment_group,
        //////            this.main.segment_transform_data,
        //////            //26022025 lv_segment_id,// номер сегмента
        //////            po_segment_beg_point,
        //////            pv_is_first_segment, // признак первого сегмента
        //////            pv_is_last_segment  // признак последнего сегмента
        //////        );

        //////        lo_segment_beg_point = lo_segment_data.segment_beg_point;
        //////        this.main.splines.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);

        //////        //22022025 {
        //////        ////lar_spline_points.push(...lo_segment_data.points);
        //////        ////lo_spline_group.add(lo_segment_group);
        //////        //22022025 }

        //////    }

        //////    catch (e) {

        //////        alert('error create_segment_group_points_curve: ' + e.stack);

        //////    }

        //////    return {
        //////        segment_group: lo_segment_group,
        //////        points: lo_segment_data.points,
        //////        segment_beg_point: lo_segment_beg_point,
        //////        segment_data: lo_segment_data
        //////    }
        //////}



        //----------------------------------------------------------
        Segments.prototype.create_segment = function (
            po_parent,
            po_transform_data,
            //26022025 pv_segment_id,
            po_beg_point,
            pv_is_first_segment, // признак первого сегмента
            pv_is_last_segment // признак последнего сегмента
            //09062024 pv_height_koef

        ) {

            let lo_segment_beg_point;
            let lar_points = [];

            try {

                // Пропускаем формирование первого узла у не первых сегментов для предотвращения
                // дублирования
                ////let lv_k_beg = 0;
                ////if (pv_segment_number > 0) {
                ////	lv_k_beg = 1;
                ////}

                let lv_k_beg;

                if (pv_is_first_segment) {
                    lv_k_beg = 0;
                }
                else {
                    lv_k_beg = 1;
                }


                let lv_segment_id = this.main.common_func.get_guid();//26022025 

                let lv_k_end = this.ar_initial_segment_points.length;

                for (let lv_k = lv_k_beg; lv_k < lv_k_end; lv_k++) { //22042024

                    ////lo_point.draggable = true;

                    let lo_node; // = new THREE.Vector2();

                    ////if ((pv_segment_number == 0 && lv_k == 0) || (pv_segment_number == this.main.params.spline_amount_segments - 1 && lv_k == this.ar_initial_segment_points.length - 1)) {
                    ////	lo_node = new THREE.Mesh(this.square_geometry, this.material);
                    ////}
                    ////else {
                    ////	lo_node = new THREE.Mesh(this.circle_geometry, this.material);
                    ////}

                    if ((pv_is_first_segment == true && lv_k == 0) || (pv_is_last_segment == true && lv_k == this.ar_initial_segment_points.length - 1)) {
                        lo_node = new THREE.Mesh(this.square_geometry, this.material);
                    }
                    else {
                        lo_node = new THREE.Mesh(this.circle_geometry, this.material);
                    }

                    lo_node.position.x = this.ar_initial_segment_points[lv_k].x * po_transform_data.kx + po_beg_point.x;
                    lo_node.position.y = this.ar_initial_segment_points[lv_k].y * po_transform_data.ky + po_beg_point.y;
                    //lo_node.position.y = (this.ar_initial_segment_points[lv_k].y * po_transform_data.ky + po_beg_point.y) * pv_height_koef; //09062024

                    //////03112024 {
                    ////// Запись максимальной координаты y сплайнов (длина модели)
                    ////if (lo_node.position.y > this.main.current_spline_max_y) {

                    ////	this.main.current_spline_max_y = lo_node.position.y;
                    ////}
                    //////03112024 }



                    lo_node.castShadow = true;
                    lo_node.receiveShadow = true;

                    lo_node.visible = false; // true;

                    lo_node.userData = {
                        nspline: po_parent.id, //lv_i,
                        nsegment: lv_segment_id, //26022025 pv_segment_id, //lv_j,
                        npoint: lv_k
                    };



                    ////this.splines_nodes.push(lo_node);

                    //this.scene.add(lo_node);


                    lo_segment_beg_point = new THREE.Vector2();
                    if (lv_k == lv_k_end - 1) {

                        lo_segment_beg_point.x = lo_node.position.x;
                        lo_segment_beg_point.y = lo_node.position.y;

                    }

                    lo_node.renderOrder = 3;//04082024


                    po_parent.add(lo_node);
                    //17042024 lar_points.push(new THREE.Vector2(lo_node.position.x, lo_node.position.y));
                    lar_points.push(new THREE.Vector3(lo_node.position.x, lo_node.position.y, 0));
                }// nodes


            }

            catch (e) {

                alert('error create_segment: ' + e.stack);

            }

            return {
                segment_beg_point: lo_segment_beg_point,
                points: lar_points
            }
        }



        //----------------------------------------------------------
        Segments.prototype.create_segment_by_data = function (
            po_parent,
            po_side_data,
            pv_curr_spline_number,
            /*po_transform_data,*/
            pv_segment_id,
            po_beg_point,
            pv_is_first_segment, // признак первого сегмента
            pv_is_last_segment, // признак последнего сегмента
            pv_beg_segment_node_numb,
            pv_end_segment_node_numb

        ) {

            let lo_segment_beg_point;
            let lar_points = [];

            //let lo_active_side = get_active_side_shape_generator();

            try {

                let lv_k_beg;

                if (pv_is_first_segment) {
                    lv_k_beg = pv_beg_segment_node_numb;

                }
                else {
                    lv_k_beg = pv_beg_segment_node_numb + 1;
                }

                let lv_k_end = pv_end_segment_node_numb;

                for (let lv_k = lv_k_beg; lv_k <= lv_k_end; lv_k++) { //22042024

                    let lo_node; // = new THREE.Vector2();

                    //04112024 if ((pv_is_first_segment == true && lv_k == 0) || (pv_is_last_segment == true && lv_k == lv_k_end - 1)) {
                    if ((pv_is_first_segment == true && lv_k == 0) || (pv_is_last_segment == true && lv_k == lv_k_end)) {  //04112024
                        lo_node = new THREE.Mesh(this.square_geometry, this.material);
                    }
                    else {
                        lo_node = new THREE.Mesh(this.circle_geometry, this.material);
                    }

                    //lo_node.position.x = this.ar_initial_segment_points[lv_k].x * po_transform_data.kx + po_beg_point.x;
                    //lo_node.position.y = this.ar_initial_segment_points[lv_k].y * po_transform_data.ky + po_beg_point.y;

                    //28012025 {
                    //lo_node.position.x = po_side_data.PointsCurves[pv_curr_spline_number][lv_k][0] + po_beg_point.x;
                    //lo_node.position.y = po_side_data.PointsCurves[pv_curr_spline_number][lv_k][1] + po_beg_point.y;
                    lo_node.position.x = po_side_data.PointsCurves[pv_curr_spline_number][lv_k][0];
                    lo_node.position.y = po_side_data.PointsCurves[pv_curr_spline_number][lv_k][1];

                    //28012025 }





                    //////03112024 {
                    ////// Запись максимальной координаты y сплайнов (длина модели)
                    ////if (lo_node.position.y > this.main.current_spline_max_y) {

                    ////	this.main.current_spline_max_y = lo_node.position.y;
                    ////}
                    //////03112024 }


                    lo_node.castShadow = true;
                    lo_node.receiveShadow = true;

                    lo_node.visible = false; // true;

                    lo_node.userData = {
                        nspline: po_parent.id,
                        nsegment: pv_segment_id,
                        npoint: lv_k
                    };



                    lo_segment_beg_point = new THREE.Vector2();
                    if (lv_k == lv_k_end - 1) {

                        lo_segment_beg_point.x = lo_node.position.x;
                        lo_segment_beg_point.y = lo_node.position.y;

                    }

                    lo_node.renderOrder = 3;

                    po_parent.add(lo_node);
                    lar_points.push(new THREE.Vector3(lo_node.position.x, lo_node.position.y, 0));
                }// nodes


            }

            catch (e) {

                alert('error create_segment: ' + e.stack);

            }

            return {
                segment_beg_point: lo_segment_beg_point,
                points: lar_points
            }
        }


        //-----------------------------------------------------------------

        Segments.prototype.create_segment_nodes = function (
            po_parent,
            po_beg_point,
            po_transform_data) {

            ////const lo_circle_geometry = new THREE.CircleGeometry(cv_node_diameter);
            ////const lo_square_geometry = new THREE.BoxGeometry(cv_node_size, cv_node_size, 0);
            ////const lo_material = new THREE.MeshLambertMaterial({
            ////	color: 0x0000ff
            ////	//visible: true //false
            ////});


            ////for (let lv_i = 0; lv_i < this.splines.length; lv_i++) {

            ////	let lo_spline = this.splines[lv_i];

            /*//for (let lv_j = 0; lv_j < lo_spline.segments.length; lv_j++) {*/

            //let lo_segment = lo_spline.segments[lv_j];

            //for (let lv_k = 0; lv_k < lo_segment.ar_segment_points.length; lv_k++) {





            // Пропускаем формирование первого узла у не первых сегментов для предотвращения
            // дублирования
            let lv_k_beg = 0;
            if (this.nsegment > 0) {
                lv_k_beg = 1;
            }

            let lv_k_end = this.ar_initial_segment_points.length;

            for (let lv_k = 0; lv_k < this.ar_initial_segment_points.length; lv_k++) {

                //let lo_point = lo_segment.ar_segment_points[lv_k];

                let lo_node;

                //if ((lv_j == 0 && lv_k == 0) || (lv_j == lo_spline.segments.length - 1 && lv_k == lo_segment.ar_segment_points.length - 1)) {
                if ((lv_j == 0 && lv_k == 0) || (lv_j == this.main.params.spline_amount_segments - 1 && lv_k == this.ar_initial_segment_points.length - 1)) {
                    lo_node = new THREE.Mesh(this.square_geometry, this.material);
                }
                else {
                    lo_node = new THREE.Mesh(this.circle_geometry, this.material);
                }


                ////lo_node.position.x = lo_point.x;
                ////lo_node.position.y = lo_point.y;
                lo_node.position.x = this.ar_initial_segment_points.x;
                lo_node.position.y = this.ar_initial_segment_points.y;

                lo_node.castShadow = true;
                lo_node.receiveShadow = true;

                lo_node.visible = false;

                lo_node.userData = {
                    nspline: po_parent.id, //lv_i,
                    nsegment: lv_j,
                    npoint: lv_k,
                    point: lo_point,
                    count_all_splines: this.shape_amount_curves,
                    count_allsegments: this.spline_amount_segments,
                    count_allpoints: lo_segment.ar_segment_points.length
                };



                ////this.splines_nodes.push(lo_node);

                //this.scene.add(lo_node);

                lo_node.renderOrder = 3; //04082024
                //07032025 this.parent.add(lo_node);
                po_parent.add(lo_node);//07032025 

            }// nodes








            /*//}// segments*/

            /*//} // splines*/


        }



        //----------------------------------------------------------
        Segments.prototype.get_segment_size = function () {


            let lo_segment_size = new struc_gabarits();

            try {
                for (let lv_i = 0; lv_i < this.ar_initial_segment_points.length; lv_i++) {

                    if (this.ar_initial_segment_points[lv_i].x < lo_segment_size.min.x) {
                        lo_segment_size.min.x = this.ar_initial_segment_points[lv_i].x;
                    }
                    if (this.ar_initial_segment_points[lv_i].x > lo_segment_size.max.x) {
                        lo_segment_size.max.x = this.ar_initial_segment_points[lv_i].x;
                    }

                    if (this.ar_initial_segment_points[lv_i].y < lo_segment_size.min.y) {
                        lo_segment_size.min.y = this.ar_initial_segment_points[lv_i].y;
                    }
                    if (this.ar_initial_segment_points[lv_i].y > lo_segment_size.max.y) {
                        lo_segment_size.max.y = this.ar_initial_segment_points[lv_i].y;
                    }

                }

                lo_segment_size.width = lo_segment_size.max.x - lo_segment_size.min.x;
                lo_segment_size.height = lo_segment_size.max.y - lo_segment_size.min.y;

            }

            catch (e) {

                alert('error get_segment_size: ' + e.stack);

                return null;
            }


            return lo_segment_size;

        }

        //------------------------------------------------------------------------
        Segments.prototype.get_segment_points = function (po_segment_group) {


            let lar_points = [];

            try {

                for (let lv_i = 0; lv_i < po_segment_group.children.length; lv_i++) {

                    if (po_segment_group.children[lv_i] instanceof THREE.Mesh) {

                        lar_points.push(po_segment_group.children[lv_i].position);
                    }

                }

            }

            catch (e) {

                alert('error get_segment_points: ' + e.stack);

                return null;
            }

            return lar_points;
        }
        //------------------------------------------------------------------------
        //13022025 Segments.prototype.get_segment_transform_data = function (pv_ajust_curves_by_shape) {
        Segments.prototype.get_segment_transform_data = function (pv_ajust_curves_by_shape, pv_spline_amount_segments) //13022025
        {

            let lo_segment_size;
            let lo_segment;
            let lo_segment_transform_data;

            try {
                lo_segment_size = this.get_segment_size();

                lo_segment_transform_data = new struc_segment_transform_data();

                if (pv_ajust_curves_by_shape) {

                    // x
                    lo_segment_transform_data.kx = this.params.shape_width / ((lo_segment_size.width + this.params.shape_width * this.params.distance_between_curves_in_percent_of_width / 100) * this.params.shape_amount_curves);

                    // y
                    //13022025 lo_segment_transform_data.ky = this.params.shape_height / (lo_segment_size.height * this.params.spline_amount_segments);
                    lo_segment_transform_data.ky = this.params.shape_height / (lo_segment_size.height * pv_spline_amount_segments);//13022025


                    // distance
                    let lv_total_curves_width = lo_segment_size.width * lo_segment_transform_data.kx * this.params.shape_amount_curves;
                    lo_segment_transform_data.distance_bt_x = this.params.distance_bt_curves;

                    if (lo_segment_transform_data.distance_bt_x < 0) {
                        lo_segment_transform_data.distance_bt_x = 0;
                    }

                }

            }

            catch (e) {

                alert('error get_segment_transform_data: ' + e.stack);

            }

            return lo_segment_transform_data;
        }

        //----------------------------------------------------------
        Segments.prototype.redefine_spline_nodes_types = function (po_spline_group) {

            return;

            // Переопределение типа узлов сплайна в зависимости от положения узла
            // - на краю сплайна - квадрат, внутри сплайна - кружок

            let lo_new_spline_group = new THREE.Group();

            lo_new_spline_group.name = po_spline_group.name;
            let lo_main_curves_group = po_spline_group.parent;


            let lv_is_first_node = false;
            let lv_is_last_node = false;
            let lar_spline_points = [];

            let lo_segment_data = null;

            let lar_selected_segments = [];

            try {

                // удаление прежней линии сплайна
                let lv_line_index = po_spline_group.children.findIndex(object => object.type === "Line");
                if (lv_line_index !== -1) {
                    po_spline_group.children.splice(lv_line_index, 1);
                }


                for (let lv_i = 0; lv_i < po_spline_group.children.length; lv_i++) {

                    if (po_spline_group.children[lv_i] instanceof THREE.Group) {

                        if (lv_i == 0) {
                            lv_is_first_node = true;
                        }
                        else {
                            lv_is_first_node = false;
                        }

                        if (lv_i == po_spline_group.children.length - 1) {
                            lv_is_last_node = true;
                        }
                        else {
                            lv_is_last_node = false;
                        }


                        lo_segment_data = this.redefine_segment_nodes_types(po_spline_group.children[lv_i], lv_is_first_node, lv_is_last_node);

                        lo_new_spline_group.add(lo_segment_data.segment_group);
                        lar_spline_points.push(...lo_segment_data.points);

                        if (lo_segment_data.selected) {
                            // Запоминание сегмента в списке выделенных
                            lar_selected_segments.push(lo_segment_data.segment_line);
                        }
                    }

                }

                this.main.splines.draw_curve(lo_new_spline_group, lar_spline_points, cv_spline_name_prefix, true);


                // Вставляем сплан-группу на своё место

                let lv_index_spline_group = lo_main_curves_group.children.findIndex(spline_group => spline_group.name === lo_new_spline_group.name);
                if (lv_index_spline_group !== -1) {
                    lo_main_curves_group.children.splice(lv_index_spline_group, 1, lo_new_spline_group);

                }


                // удаление прежней группы сплайна
                this.main.common_func.removeObjectsWithChildren(po_spline_group, true, false, false);


                // Замена массива выделенных сегментов
                //this.main.shapes.ar_selected_segments.splice(0, this.main.shapes.ar_selected_segments.length);
                this.main.shapes.ar_selected_segments = [];
                this.main.shapes.ar_selected_segments.push(...lar_selected_segments);
            }

            catch (e) {

                alert('error redefine_spline_nodes_types: ' + e.stack);

            }

            return lar_spline_points;
        }
        //----------------------------------------------------------
        Segments.prototype.redefine_segment_nodes_types = function (po_segment_group, pv_is_first_node, pv_is_last_node) {

            // Переопределение типа узлов сегмента в зависимости от положения узла
            // - на краю сплайна - квадрат, внутри сплайна - кружок

            let lar_points = [];
            let lo_node = null;

            let lo_new_segment_line = null;
            let lo_new_segment_group = new THREE.Group();

            lo_new_segment_group.name = po_segment_group.name;

            let lo_segment_group_parent = po_segment_group.parent;

            let lv_visible = false;

            // чтение имени прежней линии сегмента
            let lv_prev_segment_line_name = "";
            let lv_line_index = po_segment_group.children.findIndex(object => object.type === "Line");
            if (lv_line_index !== -1) {
                lv_prev_segment_line_name = po_segment_group.children[lv_line_index].name;
            }




            try {

                for (let lv_i = 0; lv_i < po_segment_group.children.length; lv_i++) {

                    if (po_segment_group.children[lv_i] instanceof THREE.Mesh) {

                        //lar_points.push(po_segment_group.children[lv_i].position);


                        if ((lv_i === 0 && pv_is_first_node)
                            || (lv_i == (po_segment_group.children.length - 2) && pv_is_last_node)) {

                            lo_node = new THREE.Mesh(this.square_geometry, this.material);
                        }
                        else {
                            lo_node = new THREE.Mesh(this.circle_geometry, this.material);
                        }


                        lo_node.position.x = po_segment_group.children[lv_i].position.x;
                        lo_node.position.y = po_segment_group.children[lv_i].position.y;

                        lo_node.castShadow = true;
                        lo_node.receiveShadow = true;
                        lo_node.renderOrder = 3;
                        lo_node.visible = po_segment_group.children[lv_i].visible;

                        lo_node.userData = {
                            nspline: po_segment_group.children[lv_i].nspline,               // po_parent.id, //lv_i,
                            nsegment: po_segment_group.children[lv_i].nsegment,              // lv_j,
                            npoint: po_segment_group.children[lv_i].npoint,                // lv_k,
                            point: po_segment_group.children[lv_i].point,                 // lo_point,
                            count_all_splines: po_segment_group.children[lv_i].count_all_splines,     // this.shape_amount_curves,
                            count_allsegments: po_segment_group.children[lv_i].count_allsegments,     // this.spline_amount_segments,
                            count_allpoints: po_segment_group.children[lv_i].count_allpoints        // lo_segment.ar_segment_points.length
                        };



                        lo_new_segment_group.add(lo_node);

                        let lo_point = new THREE.Vector3(lo_node.position.x, lo_node.position.y, 0);
                        lar_points.push(lo_point);


                        if (lv_i == 0) {
                            lv_visible = lo_node.visible;
                        }

                    }

                }


                lo_new_segment_line = this.main.splines.draw_curve(lo_new_segment_group, lar_points, cv_segment_name_prefix, false);

                //11032025 {
                ////if (lv_visible) {

                ////    // занесение сегмента в массив выделенных сегментов
                ////    let lv_sel_index = this.main.shapes.ar_selected_segments.findIndex(obj => obj.name === lv_prev_segment_line_name);
                ////    if (lv_sel_index !== -1) {
                ////        this.main.shapes.ar_selected_segments.splice(lv_sel_index, 1);
                ////    }
                ////    this.main.shapes.ar_selected_segments.push(lo_new_segment_line);

                ////}
                //11032025 }
            }

            catch (e) {

                alert('error redefine_segment_nodes_types: ' + e.stack);

            }

            return {
                points: lar_points,
                segment_line: lo_new_segment_line,
                segment_group: lo_new_segment_group,
                selected: lv_visible
            }
        }


        //------------------------------------------------------------------------



    } //if (typeof this.redraw_segment !== "function")

    //----------------------------------------------------------

    ////////this.create_segment();

}
// end Class Segment
//=====================================================================


import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"


import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { Line2 } from 'three/addons/lines/Line2.js';
import { LineGeometry } from 'three/addons/lines/LineGeometry.js';


//import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
//import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
//import { TransformControls } from 'three/addons/controls/TransformControls.js';

import { Constants } from './my_common_const.js';

import {
    struc_gabarits,
    struc_segment_transform_data,
    cv_spline_group_name_prefix,
    cv_spline_name_prefix,
    cv_segment_group_name_prefix,
    cv_segment_name_prefix
} from "./my_common_types.js";

import { CommonFunc } from './my_common_func.js';
//import { Segments } from "./my_segments.js";


// Class Segment

const gc_ARC_SEGMENTS = 400;//31102024 

//const parent.nsegments = 3;

export function Splines(po_main, /*, pv_count_allsplines, pv_nspline, pv_spline_offset_x, po_segment_transform_data, pv_is_move_mode*/) {

    //var ARC_SEGMENTS = 400;//11062024


    // Свойства
    this.main = po_main;

    //this.count_allsplines = pv_count_allsplines;
    //this.nspline = pv_nspline;
    this.spline_offset_x = null; // pv_spline_offset_x;
    this.segment_transform_data = null; // po_segment_transform_data;

    //this.beg_point = po_beg_point;
    //this.pv_kx = pv_kx;
    //this.pv_ky = pv_ky;
    //this.ar_segment_points = [{}];

    //this.nsegments = pv_nsegments;

    //this.all_segments_points = [];
    //this.segments = [];
    //this.ar_indices_spline_segment_points = [];

    //this.spline = {};
    //this.is_move_mode = pv_is_move_mode; // true - режим смещения кривой
    this.name_prefix = "spline";

    //this.renderer = new THREE.WebGLRenderer({});
    //=====================================================================

    if (typeof this.create_spline != "function") {
        //	return;
        //}

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------

        ////Spline.prototype.redraw_spline = function () {

        ////	for (let i = 0; i < this.segments.length; i++) {
        ////		//////////this.segments[i].redraw_segment();
        ////	}

        ////}


        //----------------------------------------------------------
        //Spline.prototype.redraw_segment = function () {
        //	alert('redraw_segment');
        //}




        //----------------------------------------------------------

        Splines.prototype.create_spline = function (po_parent, pv_spline_offset_x, ps_segment_transform_data /*, pv_height_koef*/, pv_segments_in_spline) {

            //31102024 var ARC_SEGMENTS = 400;//11062024

            try {
                //16022025 {
                //////////const lo_spline_geometry = new THREE.BufferGeometry();
                //////////lo_spline_geometry.setAttribute('position',
                //////////    new THREE.BufferAttribute(new Float32Array(gc_ARC_SEGMENTS * 2), 2));
                //16022025 }


                let lo_segment_beg_point = new THREE.Vector2(pv_spline_offset_x, 0);

                let lo_spline_group = new THREE.Group();
                lo_spline_group.name = this.main.common_func.get_object_name(cv_spline_group_name_prefix, lo_spline_group);

                let lo_segment_data;
                let lar_spline_points = [];


                //12022025 for (let lv_i = 0; lv_i < this.main.params.spline_amount_segments; lv_i++) {
                for (let lv_i = 0; lv_i < pv_segments_in_spline; lv_i++) {


                    //17022025 {


                    let lo_segment_group = new THREE.Group();
                    lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

                    //26022025 let lv_segment_id = this.main.common_func.get_guid();

                    let lv_is_firs_segment;
                    if (lv_i == 0) {
                        lv_is_firs_segment = true;
                    }
                    else {
                        lv_is_firs_segment = false;
                    }

                    let lv_is_last_segment;
                    if (lv_i == this.main.params.spline_amount_segments - 1) {
                        lv_is_last_segment = true;
                    }
                    else {
                        lv_is_last_segment = false;
                    }


                    lo_segment_data = this.main.segments.create_segment(
                        lo_segment_group,
                        this.main.segment_transform_data,
                        //26022025 lv_segment_id,// номер сегмента
                        lo_segment_beg_point,
                        lv_is_firs_segment, // признак первого сегмента
                        lv_is_last_segment  // признак последнего сегмента
                        /*pv_height_koef*/
                    );

                    lo_segment_beg_point = lo_segment_data.segment_beg_point;
                    this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);


                    lar_spline_points.push(...lo_segment_data.points);
                    lo_spline_group.add(lo_segment_group);



                    //this.create_segment_group_and_points_and_curve(lv_is_firs_segment, lv_is_last_segment, lo_segment_beg_point);//1022025

                    //17022025 }

                }


                this.draw_curve(lo_spline_group, lar_spline_points, cv_spline_name_prefix, true);



                po_parent.add(lo_spline_group);


            }

            catch (e) {

                alert('error create_spline: ' + e.stack);

            }


        }



        //2402202 {
        ////////----------------------------------------------------------

        ////////Splines.prototype.create_spline = function (po_parent, pv_spline_offset_x, ps_segment_transform_data /*, pv_height_koef*/, pv_segments_in_spline) {
        //////Splines.prototype.insert_segment_before_selected = function (/*po_parent,*/ po_selected_segment) {

        //////    try {

        //////        ////let lo_segment_beg_point = new THREE.Vector2(pv_spline_offset_x, 0);

        //////        ////let lo_spline_group = new THREE.Group();
        //////        ////lo_spline_group.name = this.main.common_func.get_object_name(cv_spline_group_name_prefix, lo_spline_group);

        //////        ////let lo_segment_data;
        //////        ////let lar_spline_points = [];


        //////        // группа групп сегментов сплайна с выделенным сегментом
        //////        let lo_segments_group = po_selected_segment.parent.parent;

        //////        let lv_index_of_selected_segment = this.main.shapes.get_spline_group_index_of_selected_segment(po_selected_segment);

        //////        let lo_new_segments_group = new THREE.Group();
        //////        lo_new_segments_group.name = lo_segments_group.name;
        //////        let lar_new_spline_points = [];

        //////        let lar_points = [];
        //////        let lv_is_after = false;
        //////        //for (let lv_i = 0; lv_i < pv_segments_in_spline; lv_i++) {
        //////        for (let lv_i = 0; lv_i < lo_segments_group.children.length - 1/*??*/; lv_i++) {



        //////            if (!lo_segments_group.children[lv_i] instanceof THREE.Group) {
        //////                continue;
        //////            }




        //////            //if (lo_segments_group.children[lv_i] !== po_selected_segment.parent) {

        //////            //    continue;
        //////            //}


        //////            ////lar_points = this.main.segments.get_segment_points(lo_segments_group.children[lv_i]);

        //////            if (lv_i == lv_index_of_selected_segment) {

        //////                // вставка нового сегмента






        //////                let lo_beg_point_position = po_selected_segment.parent.parent.children[lv_segment_index].children[0].position;
        //////                let lo_segment_beg_point = new THREE.Vector2(lo_beg_point_position.x, lo_beg_point_position.y);

        //////                let lv_is_first_segment;
        //////                let lv_is_last_segment;

        //////                if (lv_segment_index == 0) {
        //////                    lv_is_first_segment = true;
        //////                }
        //////                else {
        //////                    lv_is_first_segment = false;
        //////                }

        //////                if (lv_segment_index == lo_spline_group.length - 2) {
        //////                    lv_is_last_segment = true;
        //////                }
        //////                else {
        //////                    lv_is_last_segment = false;
        //////                }



        //////                let lo_new_segment_data = this.main.segments.create_segment_group_points_curve(lv_is_first_segment, lv_is_last_segment, lo_segment_beg_point);

        //////                lo_segment_beg_point = lo_new_segment_data.segment_beg_point;
        //////                this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);


        //////                //lar_spline_points.push(...lo_segment_data.points);
        //////                //lo_spline_group.add(lo_segment_group);


        //////                // 22022025 {
        //////                lar_new_spline_points.push(...lo_new_segment_data.points);
        //////                lo_new_segments_group.add(lo_new_segment_data.segment_group);

        //////                // 22022025 }













        //////                lv_is_after = true;
        //////            }

        //////            else {

        //////                if (lv_is_after) {

        //////                    if (lo_new_segment_data.y_max > 0) {
        //////                        // коррекция смещения по y на величину y_max нового сегмента

        //////                        for (let lv_j = 0; lv_j < lar_points.lesngth; lv_J++) {
        //////                            lar_points.y = lar_points.y + lo_new_segment_data.y_max;
        //////                        }

        //////                    }
        //////                }
        //////                //else {

        //////                //}

        //////                // копирование существующих сегментов


        //////                //lar_new_spline_points.push(...lar_points);
        //////                lo_new_segments_group.add(lo_segments_group.children[lv_i]);


        //////            }









        //////            ////if (!lo_segments_group.children[lv_i] instanceof THREE.Group) {
        //////            ////    continue;
        //////            ////}



        //////            ////let lo_segment_group = new THREE.Group();
        //////            ////lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

        //////            ////let lv_segment_id = this.main.common_func.get_guid();

        //////            ////let lv_is_firs_segment;
        //////            ////if (lv_i == 0) {
        //////            ////    lv_is_firs_segment = true;
        //////            ////}
        //////            ////else {
        //////            ////    lv_is_firs_segment = false;
        //////            ////}

        //////            ////let lv_is_last_segment;
        //////            ////if (lv_i == this.main.params.spline_amount_segments - 1) {
        //////            ////    lv_is_last_segment = true;
        //////            ////}
        //////            ////else {
        //////            ////    lv_is_last_segment = false;
        //////            ////}


        //////            ////lo_segment_data = this.main.segments.create_segment(
        //////            ////    lo_segment_group,
        //////            ////    this.main.segment_transform_data,
        //////            ////    lv_segment_id,// номер сегмента
        //////            ////    lo_segment_beg_point,
        //////            ////    lv_is_firs_segment, // признак первого сегмента
        //////            ////    lv_is_last_segment  // признак последнего сегмента
        //////            ////    /*pv_height_koef*/
        //////            ////);

        //////            //////lo_segment_beg_point = lo_segment_data.segment_beg_point;
        //////            //////this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);


        //////            //////lar_spline_points.push(...lo_segment_data.points);
        //////            //////lo_spline_group.add(lo_segment_group);

        //////        }





        //////        this.draw_curve(lo_spline_group, lar_spline_points, cv_spline_name_prefix, true);



        //////        po_parent.add(lo_spline_group);


        //////    }

        //////    catch (e) {

        //////        alert('error insert_segment_before_selected: ' + e.stack);

        //////    }


        //////}

        //2402202 }











        //////----------------------------------------------------------

        ////Splines.prototype.create_segment_group_and_points_and_curve = function (pv_is_firs_segment, pv_is_last_segment, po_segment_beg_point) {

        ////    try {

        ////        let lo_segment_group = new THREE.Group();
        ////        lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

        ////        let lv_segment_id = this.main.common_func.get_guid();

        ////        //let lv_is_firs_segment;
        ////        //if (lv_i == 0) {
        ////        //    lv_is_firs_segment = true;
        ////        //}
        ////        //else {
        ////        //    lv_is_firs_segment = false;
        ////        //}

        ////        //let lv_is_last_segment;
        ////        //if (lv_i == this.main.params.spline_amount_segments - 1) {
        ////        //    lv_is_last_segment = true;
        ////        //}
        ////        //else {
        ////        //    lv_is_last_segment = false;
        ////        //}


        ////        lo_segment_data = this.main.segments.create_segment(
        ////            lo_segment_group,
        ////            this.main.segment_transform_data,
        ////            lv_segment_id,// номер сегмента
        ////            po_segment_beg_point,
        ////            pv_is_firs_segment, // признак первого сегмента
        ////            pv_is_last_segment  // признак последнего сегмента
        ////        );

        ////        lo_segment_beg_point = lo_segment_data.segment_beg_point;


        ////        this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);


        ////        lar_spline_points.push(...lo_segment_data.points);
        ////        lo_spline_group.add(lo_segment_group);
        ////    }

        ////    catch (e) {

        ////        alert('error create_segment_group_and_points_and_curve: ' + e.stack);

        ////    }

        ////    return
        ////    {
        ////        po_segment_group: lo_segment_group;
        ////        par_spline_points: lar_spline_points;
        ////        po_segment_beg_point: lo_segment_beg_point

        ////    }
        ////}


        //----------------------------------------------------------

        Splines.prototype.create_spline_by_data = function (po_parent, pv_curr_spline_number, /*, pv_spline_offset_x, ps_segment_transform_data */ /*pv_is_use_data,*/
            po_side_data) {

            //31102024 var ARC_SEGMENTS = 400;

            try {
                const lo_spline_geometry = new THREE.BufferGeometry();
                lo_spline_geometry.setAttribute('position',
                    new THREE.BufferAttribute(new Float32Array(gc_ARC_SEGMENTS * 2), 2));

                //let lo_segment_beg_point = new THREE.Vector2(pv_spline_offset_x, 0);
                let lo_segment_beg_point = new THREE.Vector2(po_side_data.PointsCurves[pv_curr_spline_number][0][0], 0);//01112024
                let lo_spline_group = new THREE.Group();
                lo_spline_group.name = this.main.common_func.get_object_name(cv_spline_group_name_prefix, lo_spline_group);

                let lo_segment_data;
                let lar_spline_points = [];

                let lv_beg_segment_node_numb = 0; // po_side_data.Segments_beg_points_numbers[pv_curr_spline_number]
                let lv_end_segment_node_numb = 0;


                //let lv_nsegments = po_side_data.PointsCurves.length;
                let lv_nsegments = po_side_data.Segments_beg_points_numbers[pv_curr_spline_number].length;



                //for (let lv_i = 0; lv_i < this.main.params.spline_amount_segments; lv_i++) {
                for (let lv_i = 0; lv_i < lv_nsegments; lv_i++) {

                    lv_beg_segment_node_numb = po_side_data.Segments_beg_points_numbers[pv_curr_spline_number][lv_i];
                    if (lv_i > 0) {
                        lv_beg_segment_node_numb = lv_beg_segment_node_numb - 1;
                    }


                    if (lv_i < lv_nsegments - 1) {
                        //014112024 lv_end_segment_node_numb = po_side_data.Segments_beg_points_numbers[pv_curr_spline_number][lv_i + 1];
                        lv_end_segment_node_numb = po_side_data.Segments_beg_points_numbers[pv_curr_spline_number][lv_i + 1] - 1;
                    }
                    else {
                        lv_end_segment_node_numb
                            = po_side_data.PointsCurves[pv_curr_spline_number].length - 1;
                    }



                    let lo_segment_group = new THREE.Group();
                    lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

                    let lv_segment_id = this.main.common_func.get_guid();

                    let lv_is_firs_segment;
                    if (lv_i == 0) {
                        lv_is_firs_segment = true;
                    }
                    else {
                        lv_is_firs_segment = false;
                    }

                    let lv_is_last_segment;
                    //01112024 if (lv_i == this.main.params.spline_amount_segments - 1) {
                    if (lv_i == lv_nsegments - 1) {
                        lv_is_last_segment = true;
                    }
                    else {
                        lv_is_last_segment = false;
                    }


                    lo_segment_data = this.main.segments.create_segment_by_data(
                        lo_segment_group,
                        po_side_data,
                        pv_curr_spline_number,
                        /*this.main.segment_transform_data,*/
                        lv_segment_id,// номер сегмента
                        lo_segment_beg_point,
                        lv_is_firs_segment, // признак первого сегмента
                        lv_is_last_segment,  // признак последнего сегмента
                        /*pv_height_koef*/
                        lv_beg_segment_node_numb,
                        lv_end_segment_node_numb

                    );

                    lo_segment_beg_point = lo_segment_data.segment_beg_point;



                    this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);//25042022


                    lar_spline_points.push(...lo_segment_data.points);
                    lo_spline_group.add(lo_segment_group);
                    //po_parent.add(lo_segment_group);//30042024

                }

                this.draw_curve(lo_spline_group, lar_spline_points, cv_spline_name_prefix, true);

                po_parent.add(lo_spline_group);


            }

            catch (e) {

                alert('error create_spline_by_data: ' + e.stack);

            }


        }

        //------------------------------------------------------------------------
        Splines.prototype.draw_curve = function (po_parent_group, par_points, pv_curve_name_prefix, pv_visible) {

            let lo_curve;
            let lo_curve_points;
            let lo_geometry;
            let lo_material;
            let lo_result_curve;

            try {



                lo_curve = new THREE.CatmullRomCurve3(par_points, false);
                lo_curve_points = lo_curve.getPoints(400);//07112024



                //let lo_curve2 = new THREE.CatmullRomCurve3(lo_curve_points, false);//!



                ////// Преобразование из Vector3 в массив по 3 числа

                //let lo_curve_points2 = [];
                //let lv_j = 0;
                //for (let lv_i = 0; lv_i < lo_curve_points.length; lv_i++) {

                //    lo_curve_points2[lv_j++] = lo_curve_points[lv_i].x;
                //    lo_curve_points2[lv_j++] = lo_curve_points[lv_i].y;
                //    lo_curve_points2[lv_j++] = lo_curve_points[lv_i].z;
                //}




                //////////-----------!! {

                lo_geometry = new THREE.BufferGeometry().setFromPoints(lo_curve_points);
                lo_material = new THREE.LineBasicMaterial({ color: 0xff0000 });
                lo_result_curve = new THREE.Line(lo_geometry, lo_material);

                //////////-----------!! }



                //--!! {
                //let clrs = [];
                //lo_curve_points2.forEach(() => {
                //    //clrs.push(0, 0, 255);//!! цвет линии
                //    clrs.push(0, 255, 0);//!! цвет линии
                //});
                //lo_geometry = new LineGeometry();
                //lo_geometry.setPositions(lo_curve_points2 );
                //lo_geometry.setColors(clrs);
                //lo_material = new LineMaterial({
                //    vertexColors: true, //0x001, //0x0f0,//0x00f, //VertexColors,
                //    linewidth: 5,     // Толщина линии
                //    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Обязательно
                //});
                //lo_result_curve = new Line2(lo_geometry, lo_material);
                //--!! }






                ////////////////////////lo_geometry = new LineGeometry().setFromPoints(lo_curve_points);
                ////////////////////lo_geometry = new THREE.BufferGeometry().setFromPoints(lo_curve_points);
                ////////////////////lo_material = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Синий цвет
                ////////////////////lo_result_curve = new THREE.Line(lo_geometry, lo_material);


                //////////lo_geometry = new THREE.TubeGeometry(lo_curve_points, 64, 0.2, 8, false); // 0.2 - толщина
                ////lo_geometry = new THREE.TubeGeometry(lo_curve2, 64, 0.2, 8, false); // 0.2 - толщина
                ////lo_material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                ////lo_result_curve = new THREE.Mesh(lo_geometry, lo_material);



                //!! {
                //////////lo_material = new LineMaterial({
                //////////    //color: new THREE.Color("#f00").getHex(),
                //////////    vertexColors: 0x001, //0x0f0,//0x00f, //VertexColors,
                //////////    linewidth: 8, //2, //0.6,  // толщина линии
                //////////    //resolution: lo_resolution
                //////////    //resolution: this.main.resolution //30072024
                //////////    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                //////////});
                ////////////20012025 }

                //////////let clrs = [];
                ////////////lar_positions.forEach(() => {
                ////////////lo_curve_points.forEach(() => {
                ////////////    clrs.push(0, 0, 255);//!! цвет линии
                ////////////});

                ////////////par_points.forEach(() => {
                ////////////    clrs.push(0, 0, 255);//!! цвет линии
                ////////////});

                //////////lo_curve_points2.forEach(() => {
                //////////    //clrs.push(0, 0, 255);//!! цвет линии
                //////////    clrs.push(0, 255, 0);//!! цвет линии
                //////////});

                //////////lo_geometry = new LineGeometry();
                //////////lo_geometry.setPositions(lo_curve_points2 /*par_points *//*lo_curve_points*/);
                //////////lo_geometry.setColors(clrs);


                //////////lo_result_curve = new Line2(lo_geometry, lo_material);//20012025
                ////////////29012025 lo_countour_line = new Line2(lo_geometry, this.material_for_countours); //20012025
                /////////////lo_result_curve.renderOrder = 3;// 2;

                //!! }




                lo_result_curve.name = this.main.common_func.get_object_name(pv_curve_name_prefix, lo_result_curve);
                lo_result_curve.visible = pv_visible; //true;//29012025 

                //lo_result_curve.renderOrder = 3;

                po_parent_group.add(lo_result_curve);


            }

            catch (e) {

                alert('error draw_curve: ' + e.stack);

            }

            return lo_result_curve; //2304204
        }


        //////----------------------------------------------------------

        ////Splines.prototype.insert_spline = function (po_parent, pv_spline_offset_x, ps_segment_transform_data /*, pv_height_koef*/, pv_segments_in_spline) {

        ////    //31102024 var ARC_SEGMENTS = 400;//11062024

        ////    try {
        ////        //16022025 {
        ////        //////////const lo_spline_geometry = new THREE.BufferGeometry();
        ////        //////////lo_spline_geometry.setAttribute('position',
        ////        //////////    new THREE.BufferAttribute(new Float32Array(gc_ARC_SEGMENTS * 2), 2));
        ////        //16022025 }


        ////        let lo_segment_beg_point = new THREE.Vector2(pv_spline_offset_x, 0);

        ////        let lo_spline_group = new THREE.Group();
        ////        lo_spline_group.name = this.main.common_func.get_object_name(cv_spline_group_name_prefix, lo_spline_group);

        ////        let lo_segment_data;
        ////        let lar_spline_points = [];


        ////        //12022025 for (let lv_i = 0; lv_i < this.main.params.spline_amount_segments; lv_i++) {
        ////        for (let lv_i = 0; lv_i < pv_segments_in_spline; lv_i++) {

        ////            let lo_segment_group = new THREE.Group();
        ////            lo_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_segment_group);

        ////            let lv_segment_id = this.main.common_func.get_guid();

        ////            let lv_is_firs_segment;
        ////            if (lv_i == 0) {
        ////                lv_is_firs_segment = true;
        ////            }
        ////            else {
        ////                lv_is_firs_segment = false;
        ////            }

        ////            let lv_is_last_segment;
        ////            if (lv_i == this.main.params.spline_amount_segments - 1) {
        ////                lv_is_last_segment = true;
        ////            }
        ////            else {
        ////                lv_is_last_segment = false;
        ////            }


        ////            lo_segment_data = this.main.segments.create_segment(
        ////                lo_segment_group,
        ////                this.main.segment_transform_data,
        ////                lv_segment_id,// номер сегмента
        ////                lo_segment_beg_point,
        ////                lv_is_firs_segment, // признак первого сегмента
        ////                lv_is_last_segment  // признак последнего сегмента
        ////                /*pv_height_koef*/
        ////            );

        ////            lo_segment_beg_point = lo_segment_data.segment_beg_point;


        ////            this.draw_curve(lo_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);


        ////            lar_spline_points.push(...lo_segment_data.points);
        ////            lo_spline_group.add(lo_segment_group);

        ////        }


        ////        this.draw_curve(lo_spline_group, lar_spline_points, cv_spline_name_prefix, true);

        ////        po_parent.add(lo_spline_group);


        ////    }

        ////    catch (e) {

        ////        alert('error create_spline: ' + e.stack);

        ////    }


        ////}



        //------------------------------------------------------------------------

        Splines.prototype.updateSplineOutline = function (po_spline) {

            //11062024 {
            //const ARC_SEGMENTS = 400;
            //const point = new THREE.Vector2();
            //31102024 var ARC_SEGMENTS = 400;
            var point = new THREE.Vector2();
            //11062024 }

            try {

                //for (const k in par_spline_poits) {

                ////const spline = par_spline_poits[k].spline;//@@@
                //////spline.closed = true;
                ////const splineMesh = spline.catmullrom.mesh;
                //const splineMesh = spline.QuadraticBezier.mesh;//08022024
                let position = po_spline.mesh.geometry.attributes.position;


                let lv_j = 0;

                for (let i = 0; i < gc_ARC_SEGMENTS; i++) {

                    const t = i / (gc_ARC_SEGMENTS - 1);
                    po_spline.getPoint(t, point);
                    //po_spline.catmullrom.getPoint(t, point);
                    //spline.QuadraticBezier.getPoint(t, point);//08022024
                    ////let lar_points = spline.QuadraticBezier.getPoints(ARC_SEGMENTS);

                    if (isNaN(point.x) || isNaN(point.y)) {
                        continue;
                    }

                    position.setXYZ(lv_j++, point.x, point.y, 0);

                }


                // Заполнеие последних элементов массива значением последней точки
                for (let i = lv_j; i < gc_ARC_SEGMENTS; i++) {
                    position.setXYZ(i, point.x, point.y, 0);
                }


                position.needsUpdate = true;

                //}
            }

            catch (e) {

                alert('error updateSplineOutline: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------

        Splines.prototype.updateSplineOutline2 = function (po_object) {

            //11062024 {
            //const ARC_SEGMENTS = 400;
            //const point = new THREE.Vector2();
            //31102024 var ARC_SEGMENTS = 400;
            var point = new THREE.Vector2();
            //11062024 }

            try {



                //let position = po_object.mesh.geometry.attributes.position;
                let position = po_object.geometry.attributes.position;


                let lv_j = 0;

                for (let i = 0; i < gc_ARC_SEGMENTS; i++) {

                    const t = i / (gc_ARC_SEGMENTS - 1);
                    po_object.getPoint(t, point);
                    //po_spline.catmullrom.getPoint(t, point);
                    //spline.QuadraticBezier.getPoint(t, point);//08022024
                    ////let lar_points = spline.QuadraticBezier.getPoints(ARC_SEGMENTS);

                    if (isNaN(point.x) || isNaN(point.y)) {
                        continue;
                    }

                    position.setXYZ(lv_j++, point.x, point.y, 0);

                }


                // Заполнеие последних элементов массива значением последней точки
                for (let i = lv_j; i < gc_ARC_SEGMENTS; i++) {
                    position.setXYZ(i, point.x, point.y, 0);
                }


                position.needsUpdate = true;

                //}
            }

            catch (e) {

                alert('error updateSplineOutline: ' + e.stack);

            }

        }

        //-----------------------------------------------------------------

    } // (typeof this.create_spline !== "function")



    //---------------------------------------------------------------------

    ////////////////////////////////////this.create_spline();

}

// end Class Spline
//=====================================================================


import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"


import { Line2 } from 'three/addons/lines/Line2.js';
//import { Line2 } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/Line2.js';

import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineMaterial } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineMaterial.js';

import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
//import { LineGeometry } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineGeometry.js';

import { Constants } from './my_common_const.js';

import {
    struc_gabarits,
    struc_segment_transform_data,
    cv_spline_group_name_prefix,
    cv_spline_name_prefix,
    cv_segment_group_name_prefix,
    cv_segment_name_prefix,
    typ_mesh_colors

} from "./my_common_types.js";


import { CommonFunc } from './my_common_func.js';

import {
    gc_id_prefix_up,
    gc_id_prefix_lateral,
    gc_id_prefix_end,

    go_up_side_shape_generator,
    go_lateral_side_shape_generator,
    go_end_side_shape_generator,

    get_active_side_shape_generator

} from './my_shape_generator.js';



//15012025 import * as GeometryUtils from './three/addons/utils/GeometryUtils.js';
import { EndShape } from './my_end_shape.js';

//--------------------------------------------------------------------------

var my_object;
// Class Shapes
export function Shapes(po_main, po_scene, po_params, pv_is_use_data, po_side_data) {

    my_object = this;

    this.main_curves_group_prefix = "main_curves_group";

    ////const cv_node_diameter = 0.7;
    ////const cv_node_size = 2;


    // Свойства
    this.main = po_main;
    ////this.container = po_container;
    ////this.camera = po_camera;
    this.scene = po_scene;

    this.params = po_params;


    ////export function typ_side_data() {
    ////    this.numCurves = 0;
    ////    this.idMaterial = 0;
    ////    this.idSize = 0;
    ////    this.Lockedit = false;
    ////    this.Fl_manual_parameters = false;
    ////    this.M_Material = 0;
    ////    this.M_Width = 0.0;
    ////    this.M_Height = 0.0;
    ////    this.M_Length = 0.0;
    ////    this.M_Price_rub = 0.0;
    ////    this.Part_gap = 0;
    ////    this.CurveColors = new Array();
    ////    this.PointsCurves = new Array();
    ////}

    //03112024 {
    //////if (pv_is_use_data) {

    //////    po_params.shape_amount_curves = po_side_data.numCurves;
    //////    //this.shape_amount_curves = po_params.shape_amount_curves;

    //////    po_params.shape_width = po_side_data.M_Width;
    //////    po_params.shape_width_beg = po_params.shape_width;//02112024
    //////   //this.shape_width = po_params.shape_width;

    //////    po_params.shape_height = po_side_data.M_Height;
    //////    po_params.shape_height_beg = po_params.shape_height_beg; // po_params.shape_height;//02112024
    //////    //this.shape_height = po_params.shape_height;

    //////    po_params.ajust_shape_by_curves = po_side_data.parameters.is_space_adjust;
    //////    po_params.distance_bt_curves = po_side_data.parameters.distance_bt_curves;
    //////    po_params.distance_between_curves_in_percent_of_width = po_side_data.parameters.distance_bt_curves_in_percent;
    //////}
    //////else {

    //////    //this.shape_amount_curves = po_params.shape_amount_curves;

    //////    this.spline_amount_segments = po_params.spline_amount_segments;

    //////    //this.shape_width = po_params.shape_width;
    //////    //this.shape_height = po_params.shape_height;

    //////    //this.ajust_shape_by_curves = po_params.ajust_shape_by_curves;
    //////    //this.ajust_curves_by_shape = po_params.ajust_curves_by_shape;

    //////    //this.distance_between_curves_in_percent_of_width = po_params.distance_between_curves_in_percent_of_width;
    //////    //this.distance_between_curves = po_params.distance_bt_curves;


    //////}
    //03112024 }



    this.shape_amount_curves = po_params.shape_amount_curves;
    //this.spline_amount_segments = po_params.spline_amount_segments;

    this.shape_width = po_params.shape_width;
    this.shape_height = po_params.shape_height;

    this.ajust_shape_by_curves = po_params.ajust_shape_by_curves;
    this.ajust_curves_by_shape = po_params.ajust_curves_by_shape;

    this.distance_between_curves_in_percent_of_width = po_params.distance_between_curves_in_percent_of_width;
    this.distance_between_curves = po_params.distance_bt_curves;


    ////this.splines = [];
    ////this.splines_nodes = [];

    ////this.ar_indices_shape_spline_segment_points = [];


    this.group_rect = null;

    this.segment_gabarits = new struc_gabarits();
    this.segment_transform_data = new struc_segment_transform_data();

    //this.is_move_mode = pv_is_move_mode; // true - режим смещения кривой


    //this.shape_name_group_prefix = "shape_group";
    this.ar_splines = [];// Список group - сплайнов кривых в сцене
    this.ar_splines_nodes = [];// Список узлов всех сплайнов

    this.ar_selected_segments = []; // список выбранных сегментов 

    //this.previous_splines_count = 0;


    ///this.height_koef_previous = 1;

    this.ar_shapes_colors = []; // список объектов со сплайнами и цветами фигур, упорядоченных слева направо

    //20012025 {

    //29012025 {   

    //////let lo_resolution = new THREE.Vector2();
    //////this.main.renderer.getSize(lo_resolution);


    //////this.material_for_countours = new LineMaterial({
    //////    //color: new THREE.Color("#f00").getHex(),
    //////    vertexColors: 0x001, //0x0f0,//0x00f, //VertexColors,
    //////    linewidth: 0.8, //2, //0.6,  // толщина линии
    //////    resolution: lo_resolution
    //////    //resolution: this.main.resolution //30072024
    //////});
    //29012025 }

    //20012025 }

    //=====================================================================

    if (typeof this.redraw_shapes != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------


        //-----------------------------------------------------------------

        //2602202 {
        //////-----------------------------------------------------------------
        ////// Добавление сегмента над выделенным сегментом
        ////////Shapes.prototype.make_mirror_segment = function (po_segment) {

        ////Shapes.prototype.insert_segment_above_selected = function (po_selected_segment) {


        ////    if (!po_selected_segment) {

        ////        return;
        ////    }

        ////    if (!po_selected_segment.parent) {

        ////        return;

        ////    }



        ////    //22022025 {
        ////    //let lo_spline_group = new THREE.Group();
        ////    //lo_spline_group.name = this.main.common_func.get_object_name(cv_spline_group_name_prefix, lo_spline_group);

        ////    //let lo_segment_data;
        ////    let lar_spline_points = [];
        ////    //22022025 ]











        ////    let lo_parent_parent = null;

        ////    // группа, включающая группу сегментов сплайна с выделенным сегментом
        ////    let lo_spline_group = po_selected_segment.parent.parent;

        ////    let lv_segment_index = -1; // индекс выделенного сегмента

        ////    lv_segment_index = this.get_spline_group_index_of_selected_segment(po_selected_segment);



        ////    let lo_beg_point_position = po_selected_segment.parent.parent.children[lv_segment_index].children[0].position;

        ////    let lo_segment_beg_point = new THREE.Vector2(lo_beg_point_position.x, lo_beg_point_position.y);



        ////    let lv_is_first_segment;
        ////    let lv_is_last_segment;

        ////    if (lv_segment_index == 0) {
        ////        lv_is_first_segment = true;
        ////    }
        ////    else {
        ////        lv_is_first_segment = false;
        ////    }

        ////    if (lv_segment_index == lo_spline_group.length - 2) {
        ////        lv_is_last_segment = true;
        ////    }
        ////    else {
        ////        lv_is_last_segment = false;
        ////    }



        ////    let lo_new_segment_data = this.main.segments.create_segment_group_points_curve(lv_is_first_segment, lv_is_last_segment, lo_segment_beg_point);


        ////    //segment_group: lo_segment_group,
        ////    //points: lo_segment_data.points,
        ////    //segment_beg_point: lo_segment_beg_point,
        ////    //segment_data: lo_segment_data




        ////    // 22022025 {
        ////    lar_spline_points.push(...lo_new_segment_data.points);
        ////    lo_spline_group.add(lo_new_segment_data.segment_group);

        ////    // 22022025 }







        ////    let lar_new_segment_points = [];

        ////    let lo_segment_point;

        ////    let lv_base_x = 0;

        ////    let lo_segment;

        ////    try {

        ////        for (let lv_i = 0; lv_i < po_segment.parent.children.length - 1; lv_i++) {

        ////            //lo_segment_point = po_segment.parent.children[lv_i];

        ////            //if (lv_i == 0) {
        ////            //    lv_base_x = lo_segment_point.position.x;
        ////            //}

        ////            //let lv_delta = lv_base_x - lo_segment_point.position.x;

        ////            //lo_segment_point.position.x = lv_base_x + lv_delta;


        ////            //lar_new_segment_points.push(lo_segment_point.position);


        ////        }


        ////        // Удаление предыдущих линий
        ////        let lo_parent = po_segment.parent;
        ////        let lar_lines = this.main.shapes.get_lines_in_group(po_segment.parent);
        ////        for (let lv_i = 0; lv_i < lar_lines.length; lv_i++) {
        ////            this.main.common_func.removeObjectsWithChildren(lar_lines[lv_i], true);
        ////        }

        ////        lo_segment = this.main.splines.draw_curve(lo_parent, lar_new_segment_points, cv_segment_name_prefix, false);

        ////    }

        ////    catch (e) {

        ////        alert('error insert_segment_above_selected: ' + e.stack);

        ////    }

        ////    return lo_segment;

        ////}
        //2602202 }


        //------------------------------------------------------------------------------------------------------------------
        Shapes.prototype.addShape = function (po_shape,/* extrudeSettings,*/ pv_color/*, x, y, z, rx, ry, rz, s*/) {

            // flat shape with texture
            // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

            let lo_geometry = new THREE.ShapeGeometry(po_shape);

            ////let mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture }));
            ////mesh.position.set(x, y, z - 175);
            ////mesh.rotation.set(rx, ry, rz);
            ////mesh.scale.set(s, s, s);
            ////group.add(mesh);

            // flat shape

            ////geometry = new THREE.ShapeGeometry(shape);

            let lo_mesh = new THREE.Mesh(lo_geometry, new THREE.MeshPhongMaterial({ color: pv_color/*, side: THREE.DoubleSide */ }));
            ////mesh.position.set(x, y, z - 125);
            ////mesh.rotation.set(rx, ry, rz);
            ////mesh.scale.set(s, s, s);
            ////group.add(mesh);
            this.scene.add(lo_mesh);
            //this.plane.add(lo_mesh);//31012025


            // extruded shape

            ////geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            ////mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: color }));
            ////mesh.position.set(x, y, z - 75);
            ////mesh.rotation.set(rx, ry, rz);
            ////mesh.scale.set(s, s, s);
            ////group.add(mesh);

            //////addLineShape(shape, color, x, y, z, rx, ry, rz, s);

        }

        //------------------------------------------------------------------------
        Shapes.prototype.add_spline = function (po_segment_transform_data, pv_spline_offset_x, pv_nsegments, pv_is_random_segmets) //13022025 
        {

            let lv_spline_distance = 0;
            let lv_spline_offset_x = 0;
            let lv_segments_in_spline = 0;


            //13022025 {
            ////if (typeof pv_spline_offset_x == "undefined") {

            ////    lv_spline_distance = this.segment_transform_data.distance_bt_x;
            ////    lv_spline_offset_x = (lv_spline_distance / 2) + Math.abs(this.segment_gabarits.min.x)
            ////        + lv_spline_distance * this.ar_splines.length;

            ////    lv_segments_in_spline = this.main.params.spline_amount_segments;
            ////}
            ////else {

            ////    lv_spline_offset_x = pv_spline_offset_x;
            ////    lv_segments_in_spline = pv_nsegments;
            ////}


            if (typeof pv_spline_offset_x == "undefined") {

                lv_spline_distance = po_segment_transform_data.distance_bt_x;
                lv_spline_offset_x = (lv_spline_distance / 2) + Math.abs(this.segment_gabarits.min.x)
                    + lv_spline_distance * this.ar_splines.length;

                lv_segments_in_spline = this.main.params.spline_amount_segments;
            }
            else {

                lv_spline_offset_x = pv_spline_offset_x;
                lv_segments_in_spline = pv_nsegments;
            }

            //13022025 }





            // группа всех кривых
            let lo_main_curves_group = this.main.scene.getObjectByName(this.main_curves_group_prefix);
            if (!lo_main_curves_group) {
                return;
            }


            //13022025 this.main.splines.create_spline(lo_main_curves_group, lv_spline_offset_x, /*this.height_koef_previous,*/ this.segment_transform_data, lv_segments_in_spline);
            this.main.splines.create_spline(lo_main_curves_group, lv_spline_offset_x, /*this.height_koef_previous,*/ po_segment_transform_data, lv_segments_in_spline);//13022025






            this.shape_amount_curves++; //06122024

            this.ar_splines = this.get_splines();
            this.ar_splines_nodes = this.get_splines_points();


            if (this.params.is_space_adjust) {

                this.adjust_splines_by_external_shape();
            }

        }


        //------------------------------------------------------------------------
        Shapes.prototype.adjust_segments_nodes_by_external_shape = function (po_spline_group, pv_spline_offset_x/*pv_delta_x*/, pv_height_koef_relative) {

            //06032025 let lar_segments_points = [];

            try {

                let lo_segment_group;
                let lv_delta_x;

                //13022025 {

                //let lv_height_koef_relative = 0;

                //let lar_spline_positions_array = po_spline_group.children[po_spline_group.children.length - 1].geometry.attributes.position.array;
                //let lv_spline_height = lar_spline_positions_array[lar_spline_positions_array.length - 2]; // наибольшая координата y

                //let lv_spline_height = this.get_splines_height_max(po_spline_group);//14022025


                let lv_spline_height = this.get_spline_height(po_spline_group);//14022025

                //13022025 }





                for (let lv_i = 0; lv_i < po_spline_group.children.length; lv_i++) {

                    if (po_spline_group.children[lv_i] instanceof THREE.Group) {

                        let lo_segment_points = po_spline_group.children[lv_i];

                        if (lo_segment_points instanceof THREE.Group) {

                            let lar_segment_points = [];//

                            for (let lv_k = 0; lv_k < lo_segment_points.children.length; lv_k++) {

                                if (lo_segment_points.children[lv_k] instanceof THREE.Mesh) {

                                    if (lv_k == 0) {
                                        lv_delta_x = pv_spline_offset_x - lo_segment_points.children[lv_k].position.x;
                                    }


                                    //lar_segment_points.push(lo_segment_points_group.children[lv_k].position);



                                    // двигаем всю кривую (сплайн)
                                    lo_segment_points.children[lv_k].position.x = lo_segment_points.children[lv_k].position.x + lv_delta_x;


                                    // растягиваем кривые по высоте

                                    //13022025 {

                                    //////////let lv_splines_height = this.get_current_splines_height();

                                    //if (lv_splines_height !== 0) {
                                    //    lv_height_koef_relative = this.params.shape_height / lv_splines_height;
                                    //}
                                    //else {
                                    //    lv_height_koef_relative = 1;

                                    //}

                                    ////////if (lv_spline_height !== 0) {
                                    ////////    lv_height_koef_relative = this.params.shape_height / lv_spline_height;
                                    ////////}
                                    ////////else {
                                    ////////    lv_height_koef_relative = 1;

                                    ////////}
                                    //13022025 }


                                    lo_segment_points.children[lv_k].position.y = lo_segment_points.children[lv_k].position.y * pv_height_koef_relative;


                                    //03112024 {
                                    ////// Запись максимальной координаты y сплайнов (длина модели)
                                    ////if (lo_segment_points.children[lv_k].position.y > this.main.current_spline_max_y) {

                                    ////    this.main.current_spline_max_y = lo_segment_points.children[lv_k].position.y;
                                    ////}
                                    //////03112024 }

                                    //06032025 lar_segment_points.push(lo_segment_points.children[lv_k].position);

                                }



                            }









                            //06032025 {
                            //////////// Удаление предыдущих линий сегментов
                            //////////let lar_lines = this.main.shapes.get_lines_in_group(lo_segment_points);//16062024

                            //////////for (let lv_k = 0; lv_k < lar_lines.length; lv_k++) {
                            //////////    this.main.common_func.removeObjectsWithChildren(lar_lines[lv_k], true);

                            //////////    // Создание нового сегмента
                            //////////    let lo_segment = this.main.splines.draw_curve(lo_segment_points, lar_segment_points, cv_segment_name_prefix, false);


                            //////////    //05032025 {
                            //////////    //if (this.clear_selected_segments_with_null_parents()) {
                            //////////    //    this.ar_selected_segments.push(lo_segment);
                            //////////    //}

                            //////////    this.clear_selected_segments_with_null_parents();

                            //////////    //05032025 }
                            //////////}
                            //06032025 }



                            //lar_segments_points.push({
                            //	points: lar_segment_points,
                            //	parent: lo_segment_points
                            //});


                        }
                        else {

                            continue;
                        }
                    }
                }

            }

            catch (e) {

                alert('error get_segments_points: ' + e.stack);

            }

            //return lar_segments_points;//14022025 

        }


        //------------------------------------------------------------------------
        Shapes.prototype.adjust_splines_by_external_shape = function (pv_height_new) {


            try {

                this.clear_group_contours();//27072024 
                this.clear_group_color_mesh();//27072024 


                let lv_height_koef_relative;
                let lv_height_koef;

                //03112024 {

                //////lv_height_koef = this.params.shape_height / (this.main.params.shape_height_beg);
                //////if (this.height_koef_previous !== 0) {
                //////    lv_height_koef_relative = lv_height_koef / this.height_koef_previous;
                //////}
                //////else {
                //////    lv_height_koef_relative = 1;
                //////}

                //14022025 let lv_splines_height = this.get_current_splines_height();
                //let lv_splines_height = this.get_splines_height_max();

                //if (lv_splines_height !== 0) {
                //    lv_height_koef_relative = this.params.shape_height / lv_splines_height;
                //}
                //else {
                //    lv_height_koef_relative = 1;

                //}


                let lv_spline_distance = this.params.shape_width / this.ar_splines.length;


                ////// сортировка групп сплайнов по возрастанию x начальной точки
                ////this.ar_splines = this.SortGroupsSplinesFromLeftToRight();

                this.ar_splines = this.get_splines();//07032025
                this.ar_splines_nodes = this.get_splines_points();//07032025

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    let lv_spline_offset_x;

                    lv_spline_offset_x = lv_spline_distance * (0.5 + lv_i);

                    //let lv_splines_height = this.get_spline_height_max(this.ar_splines[lv_i]);//14022025
                    let lv_spline_height = this.get_spline_height(this.ar_splines[lv_i]);//14022025
                    if (lv_spline_height !== 0) {
                        lv_height_koef_relative = this.params.shape_height / lv_spline_height;
                    }
                    else {
                        lv_height_koef_relative = 1;
                    }

                    this.adjust_segments_nodes_by_external_shape(this.ar_splines[lv_i], lv_spline_offset_x, lv_height_koef_relative);


                    // чтение модифицированных позиций узлов
                    let lar_spline_points = this.main.shapes.get_spline_points(this.ar_splines[lv_i]);

                    // Удаление предыдущих линий
                    let lar_lines = this.main.shapes.get_lines_in_group(this.ar_splines[lv_i]);
                    for (let lv_k = lar_lines.length - 1; lv_k >= 0; lv_k--) {
                        //07032025 this.main.common_func.removeObjectsWithChildren(lar_lines[lv_k], true);
                        //08032025 this.main.common_func.removeObjectsWithChildren(lar_lines[lv_k], true, true, true); //07032025
                        this.main.common_func.removeObjectsWithChildren(lar_lines[lv_k], true, false, false); //08032025
                    }

                    // Перерисовка сегментов
                    ///@@@@@ 08062024 this.main.shapes.redraw_segments(this.ar_splines[lv_i]);


                    if (lar_spline_points.length > 0) {  //16032025
                        // создание новой линии
                        this.main.splines.draw_curve(this.ar_splines[lv_i], lar_spline_points, this.main.splines.name_prefix, true);

                    } //16032025


                    //	 Запоминание новой кривой
                    //	this.set_spline_points(this.ar_splines[lv_i], lar_spline_points);//13062024
                }

                //04112024 this.height_koef_previous = lv_height_koef;






                // Восстановление выделенного контура
                let lar_splines_order = []; //03082024


                lar_splines_order = this.SortSplinesOrderFromLeftToRight(); //20012025


                if (this.main.group_contours) {

                    if (this.main.group_contours.userData) {

                        if (this.main.group_contours.userData.num_spline_left != null || this.main.group_contours.userData.num_spline_right != null) {

                            //20012025 lar_splines_order = this.SortSplinesOrderFromLeftToRight();

                            let lv_num_spline_left = this.main.group_contours.userData.num_spline_left;
                            let lv_num_spline_right = this.main.group_contours.userData.num_spline_right;


                            let lo_spline_left = this.main.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_left);
                            let lo_spline_right = this.main.common_func.getSplineByNumber(lar_splines_order, lv_num_spline_right);

                            //03022025 this.draw_contour_and_shape(0x0f0, lo_spline_left, lo_spline_right, true, false, true, false/*, true*/);
                            this.draw_contour_and_shape(0x0f0, lo_spline_left, lo_spline_right, true, false, true, false/*, true*/);//03022025 
                        }
                    }
                    //298072024 }
                }


                this.redraw_meshes_color(lar_splines_order);


                // Перерисовка сегментов
                this.redraw_segments();//07032025 


            }

            catch (e) {

                alert('error adjust_splines_by_external_shape: ' + e.stack);

            }


        }


        //-----------------------------------------------------------------
        Shapes.prototype.clear_group_color_mesh = function () {
            try {


                if (this.main.group_color_mesh) { //03122024 
                    if (this.main.group_color_mesh.children) { //03122024 
                        if (this.main.group_color_mesh.children.length > 0) { //03122024 
                            for (let lv_i = this.main.group_color_mesh.children.length - 1; lv_i >= 0; lv_i--) {
                                this.main.common_func.removeObjectsWithChildren(this.main.group_color_mesh.children[lv_i], true);
                            }
                        }
                    }
                }
            }

            catch (e) {

                alert('error clear_group_color_mesh: ' + e.stack);

            }
        }


        //-----------------------------------------------------------------
        Shapes.prototype.clear_group_contours = function () {

            try {

                if (this.main.group_contours) {
                    if (this.main.group_contours.children) {
                        if (this.main.group_contours.children.length > 0) {
                            //for (let lv_i = 0; lv_i < this.main.group_contours.children.length; lv_i++) {
                            for (let lv_i = this.main.group_contours.children.length - 1; lv_i >= 0; lv_i--) {
                                this.main.common_func.removeObjectsWithChildren(this.main.group_contours.children[lv_i], true);
                            }
                        }
                    }
                }

            }

            catch (e) {

                alert('error clear_group_contours: ' + e.stack);

            }
        }


        //--------------------------------------------------------------------------------------

        Shapes.prototype.create_shapes = function (pv_is_use_data, po_side_data) {

            //if (this.main.my_prefix == gc_id_prefix_end) {
            //    create_end_shape(pv_is_use_data, po_side_data);
            //}



            let lv_spline_distance = 0;

            try {

                let lo_shape_splines_group = new THREE.Group();
                lo_shape_splines_group.name = this.main_curves_group_prefix;

                //let lv_shape_amount_curves = 0;

                if (pv_is_use_data) {
                    //lv_shape_amount_curves = po_side_data.numCurves;
                    this.shape_amount_curves = po_side_data.numCurves;
                }
                //04112024 {
                ////else {
                ////    ////this.segment_gabarits = this.main.segment_gabarits;
                ////    ////this.segment_transform_data = this.main.segment_transform_data;
                ////    ////lv_spline_distance = this.segment_transform_data.distance_bt_x;
                ////    //lv_shape_amount_curves = this.shape_amount_curves;
                ////}
                // 04112024 }


                this.segment_gabarits = this.main.segment_gabarits; //!!!!!!!!!!!!1111
                this.segment_transform_data = this.main.segment_transform_data; //!!!!!!!!!!!!1111
                lv_spline_distance = this.segment_transform_data.distance_bt_x; //!!!!!!!!!!!!1111





                //let lo_shape_splines_group = new THREE.Group();
                //lo_shape_splines_group.name = this.main_curves_group_prefix;


                // Сброс максимальной текущей координаты сплайнов y (длина модели)
                //let lo_active_side = get_active_side_shape_generator();

                ////this.main.current_spline_max_y = 0;


                for (let lv_i = 0; lv_i < this.shape_amount_curves; lv_i++) {

                    if (pv_is_use_data) {

                        this.main.splines.create_spline_by_data(lo_shape_splines_group, lv_i, /*lv_spline_offset_x, this.segment_transform_data,*/ /*pv_is_use_data, */ po_side_data);

                    }
                    else {
                        let lv_spline_offset_x;

                        lv_spline_offset_x = (lv_spline_distance / 2) + Math.abs(this.segment_gabarits.min.x)
                            + lv_spline_distance * lv_i;

                        this.main.splines.create_spline(lo_shape_splines_group, lv_spline_offset_x, this.segment_transform_data, this.main.params.spline_amount_segments);

                    }

                }

                this.main.scene.add(lo_shape_splines_group);
                //this.main.plane.add(lo_shape_splines_group);//31012025

                this.ar_splines = this.get_splines();
                this.ar_splines_nodes = this.get_splines_points();

            }

            catch (e) {

                alert('error create_shapes: ' + e.stack);

            }


        }



        //------------------------------------------------------------------------
        Shapes.prototype.clear_selected_segments_with_null_parents = function () {

            let lv_result = false;
            try {

                for (let lv_i = this.ar_selected_segments.length - 1; lv_i >= 0; lv_i--) {

                    if (this.ar_selected_segments[lv_i].parent === null) {
                        this.ar_selected_segments.splice(lv_i, 1);
                        lv_result = true;
                    }
                }


            }

            catch (e) {

                alert('error clear_selected_segments_with_null_parents: ' + e.stack);

            }

            return lv_result;
        }



        //------------------------------------------------------------------------
        Shapes.prototype.delete_from_selected_segments = function (po_segment) {

            // удаление элемента из массива выбранных сегментов
            for (let lv_i = this.ar_selected_segments.length - 1; lv_i >= 0; lv_i--) {

                if (this.ar_selected_segments[lv_i] == po_segment) {

                    this.ar_selected_segments.splice(lv_i, 1);
                }

            }

        }


        //------------------------------------------------------------------------
        Shapes.prototype.delete_splines = function () {

            if (this.ar_selected_segments.length == 0) {

                this.main.common_func.Show_message("Right click to select curves to delete", 2500);

                return;
            }


            let lv_question;
            if (this.ar_selected_segments.length == 1) {
                lv_question = "Delete curve?";
            }
            else {

                lv_question = "Delete curves?";

            }


            this.main.common_func.show_question(lv_question,
                function () {

                    let lo_active_side = get_active_side_shape_generator();

                    lo_active_side.shapes.do_delete_splines();
                    lo_active_side.render();//11022025 

                    $(this).dialog("close");
                },
                function () { $(this).dialog("close"); }, null);

        }


        //------------------------------------------------------------------------
        Shapes.prototype.do_delete_spline = function (po_spline_group) {


            //let lv_deleted_splines_beg_x = null; //12022025  начальная координата x удаляемого сплайна

            for (let lv_i = po_spline_group.children.length - 1; lv_i >= 0; lv_i--) {

                let lo_object = po_spline_group.children[lv_i];

                if (lo_object.type == "Line") {

                    //lv_deleted_splines_beg_x = lo_object[0];


                    let lv_deleting_numspline = this.main.common_func.get_numspline_from_left_to_right(lo_object);//11122024
                    //go_end_side_shape_generator.prototype.redefine_arr_color_parts(
                    //    go_up_side_shape_generator.shapes.shape_amount_curves,
                    //    go_lateral_side_shape_generator.shapes.shape_amount_curves,
                    //    null, lv_numspline
                    //);

                    //02082025 EndShape.prototype.redefine_arr_color_parts(

                    go_end_side_shape_generator.end_shape.redefine_arr_color_parts( //02082025
                        this.main, //12122024
                        //07022025 {
                        //go_up_side_shape_generator.shapes.shape_amount_curves,
                        //go_lateral_side_shape_generator.shapes.shape_amount_curves,
                        go_up_side_shape_generator.shapes.ar_splines.length,
                        go_lateral_side_shape_generator.shapes.ar_splines.length,
                        //07022025 }
                        null, lv_deleting_numspline


                    );
                }

                this.main.common_func.removeObjectsWithChildren(lo_object, true, true, true);

            }


            //this.main.common_func.removeObjectsWithChildren(po_spline_group);//07032025

            //return lv_deleted_splines_beg_x; // начальная координата x удаляемого сплайна
        }

        //------------------------------------------------------------------------
        Shapes.prototype.do_delete_splines = function () {

            let lo_parent;
            let lo_parent_parent;
            let lv_deleted_splines_beg_x = null;
            let lv_deleted_spline_num = null;


            let lar_deleted_splines_beg_x = []; //12022025  начальные координаты x удалённых сплайнов

            //let lv_was_action = false;

            for (let lv_i = this.ar_selected_segments.length - 1; lv_i >= 0; lv_i--) {

                if (this.ar_selected_segments[lv_i].parent) {

                    if (this.ar_selected_segments[lv_i].parent.parent) {

                        let lo_segment_group = this.ar_selected_segments[lv_i].parent;
                        let lo_spline_group = this.ar_selected_segments[lv_i].parent.parent;


                        ////08022025 {
                        //// Удаление сплайна из списка
                        //for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {
                        //    //for (let lv_i = this.ar_splines.length-1; lv_i >= 0; lv_i--) { //11122024

                        //    if (this.ar_splines[lv_i] == lo_parent_parent) {

                        //        this.ar_splines.splice(lv_i, 1);
                        //        lv_deleted_spline_num = lv_i; //07022025
                        //    }

                        //}
                        ////08022025 }

                        if (lo_segment_group.children[0].position) {

                            lv_deleted_splines_beg_x = lo_segment_group.children[0].position.x;
                            lar_deleted_splines_beg_x.push(lv_deleted_splines_beg_x);
                        }

                        //lv_deleted_splines_beg_x = this.do_delete_spline(lo_parent_parent);
                        this.do_delete_spline(lo_spline_group);



                        if (this.shape_amount_curves > 0) {
                            this.shape_amount_curves--; //06122024
                        }

                        //08022025 {
                        // Удаление сплайна из списка
                        for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {
                            //for (let lv_i = this.ar_splines.length-1; lv_i >= 0; lv_i--) { //11122024

                            if (this.ar_splines[lv_i] == lo_spline_group) {

                                this.ar_splines.splice(lv_i, 1);
                                lv_deleted_spline_num = lv_i; //07022025
                            }

                        }
                        //08022025 }

                        // удаление удалённых узлов из списка
                        for (let lv_i = this.ar_splines_nodes.length - 1; lv_i >= 0; lv_i--) {

                            if (this.ar_splines_nodes[lv_i].parent == null) {
                                this.ar_splines_nodes.splice(lv_i, 1);
                            }
                        }


                        //03072025 lo_spline_group.removeFromParent();

                        this.main.common_func.removeObjectsWithChildren(lo_spline_group, true, true, true); //07032025
                        this.main.scene.remove(lo_spline_group);//07032025
                        //lv_was_action = true;
                    }


                }


            }

            //14012025 {
            if (this.params.is_space_adjust) {
                this.adjust_splines_by_external_shape();
            }

            //14012025 }



            go_end_side_shape_generator.end_shape.redraw_end_shape(
                null, //this.main, //07022025 null,       //this.main,
                null, lv_deleted_spline_num, //08022025 pv_added_spline_num, pv_deleted_spline_num,
                null, null  //po_is_use_data, po_sides_data
            );



            // очистка списка выделенных сегментов
            this.ar_selected_segments = [];

            ////11022025 this.main.render();

            //14022025 
            // Оставляем в массиве смещений сплайнов только неповторяющиеся (уникальные) значения
            lar_deleted_splines_beg_x = [...new Set(lar_deleted_splines_beg_x)];

            return lar_deleted_splines_beg_x;
        }



        //------------------------------------------------------------------------
        Shapes.prototype.draw_contour_and_shape = function (po_color_rgb, po_spline_left, po_spline_right, pv_remember_contour, pv_remember_color, pv_draw_contour, pv_draw_shape) {


            try {


                if (!po_spline_left && !po_spline_right) {
                    return;
                }


                let lar_positions = [];

                let lar_shape_positions = [];

                let lar_left_points = null;
                let lar_right_points = null;




                let lo_geometry = new LineGeometry();
                let clrs = [];


                //20012025 {
                ////let lo_resolution = new THREE.Vector2();
                ////this.main.renderer.getSize(lo_resolution);


                let lo_material = new LineMaterial({
                    vertexColors: true, //0x001, //0x0f0,//0x00f, //VertexColors,
                    linewidth: Constants.line_width_shape_contour, //7, //30012025 2, //0.6,  // толщина линии
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // Обязательно 30012025 lo_resolution,
                    //resolution: this.main.resolution //30072024
                });
                //20012025 }





                let lo_shape2 = null;
                let lo_geometry2 = null;
                let lo_mesh2 = null;




                let lo_rectangle_coordinates = this.main.get_rectangle_coordinates_by_name(this.main.rectangle.cv_rectangle_name);


                if (po_spline_left && po_spline_right) {

                    // Два сплайна
                    lar_left_points = this.main.common_func.getLinePoints(po_spline_left);
                    lar_right_points = this.main.common_func.getLinePoints(po_spline_right);


                    lar_positions.push(lar_right_points[0].x, lar_right_points[0].y, 0);
                    lar_shape_positions.push(new THREE.Vector2(lar_right_points[0].x, lar_right_points[0].y, 0));

                    for (let lv_i = 0; lv_i < lar_left_points.length; lv_i++) {
                        lar_positions.push(lar_left_points[lv_i].x, lar_left_points[lv_i].y, 0);
                        lar_shape_positions.push(new THREE.Vector2(lar_left_points[lv_i].x, lar_left_points[lv_i].y, 0));
                    }

                    for (let lv_i = lar_right_points.length - 1; lv_i >= 0; lv_i--) {
                        lar_positions.push(lar_right_points[lv_i].x, lar_right_points[lv_i].y, 0);
                        lar_shape_positions.push(new THREE.Vector2(lar_right_points[lv_i].x, lar_right_points[lv_i].y, 0));
                    }



                }
                if (po_spline_left && !po_spline_right) {

                    // Сплайн слева
                    lar_left_points = this.main.common_func.getLinePoints(po_spline_left);

                    for (let lv_i = 0; lv_i < lar_left_points.length; lv_i++) {
                        lar_positions.push(lar_left_points[lv_i].x, lar_left_points[lv_i].y, 0);
                        lar_shape_positions.push(new THREE.Vector2(lar_left_points[lv_i].x, lar_left_points[lv_i].y, 0));
                    }

                    lar_positions.push(lo_rectangle_coordinates.max_x, lo_rectangle_coordinates.max_y, 0);
                    lar_positions.push(lo_rectangle_coordinates.max_x, lo_rectangle_coordinates.min_y, 0);
                    lar_positions.push(lar_left_points[0].x, lo_rectangle_coordinates.min_y, 0);

                    lar_shape_positions.push(new THREE.Vector2(lo_rectangle_coordinates.max_x, lo_rectangle_coordinates.max_y, 0));
                    lar_shape_positions.push(new THREE.Vector2(lo_rectangle_coordinates.max_x, lo_rectangle_coordinates.min_y, 0));
                    lar_shape_positions.push(new THREE.Vector2(lar_left_points[0].x, lo_rectangle_coordinates.min_y, 0));

                }

                if (!po_spline_left && po_spline_right) {

                    // Сплайн справа
                    lar_right_points = this.main.common_func.getLinePoints(po_spline_right);

                    for (let lv_i = 0; lv_i < lar_right_points.length; lv_i++) {
                        lar_positions.push(lar_right_points[lv_i].x, lar_right_points[lv_i].y, 0);
                        lar_shape_positions.push(new THREE.Vector2(lar_right_points[lv_i].x, lar_right_points[lv_i].y, 0));
                    }

                    lar_positions.push(lo_rectangle_coordinates.min_x, lo_rectangle_coordinates.max_y, 0);
                    lar_positions.push(lo_rectangle_coordinates.min_x, lo_rectangle_coordinates.min_y, 0);
                    lar_positions.push(lar_right_points[0].x, lo_rectangle_coordinates.min_y, 0);

                    lar_shape_positions.push(new THREE.Vector2(lo_rectangle_coordinates.min_x, lo_rectangle_coordinates.max_y, 0));
                    lar_shape_positions.push(new THREE.Vector2(lo_rectangle_coordinates.min_x, lo_rectangle_coordinates.min_y, 0));
                    lar_shape_positions.push(new THREE.Vector2(lar_right_points[0].x, lo_rectangle_coordinates.min_y, 0));

                }

                // Определение номеров выделенных сплайнов слева направо
                let lar_splines_order = [];
                lar_splines_order = this.SortSplinesOrderFromLeftToRight();//28072024

                let lv_num_spline_left = this.main.common_func.getNumberBySpline(lar_splines_order, po_spline_left);
                let lv_num_spline_right = this.main.common_func.getNumberBySpline(lar_splines_order, po_spline_right);

                let lo_userData = null;

                if (pv_remember_contour) {

                    lo_userData = {
                        spline_left: po_spline_left,
                        spline_right: po_spline_right,
                        num_spline_left: lv_num_spline_left,
                        num_spline_right: lv_num_spline_right

                    };

                    this.main.group_contours.userData = lo_userData;

                }

                //20012025 }

                let lo_countour_line = null;

                if (pv_draw_contour) {

                    lar_positions.forEach(() => {
                        clrs.push(0, 0, 255);//!! цвет линии
                    });

                    lo_geometry.setPositions(lar_positions);
                    lo_geometry.setColors(clrs);


                    lo_countour_line = new Line2(lo_geometry, lo_material);//20012025 
                    //29012025 lo_countour_line = new Line2(lo_geometry, this.material_for_countours); //20012025
                    lo_countour_line.renderOrder = 2;

                    this.main.group_contours.add(lo_countour_line);

                }



                if (pv_draw_shape) {

                    lo_shape2 = new THREE.Shape(lar_shape_positions);
                    lo_geometry2 = new THREE.ShapeGeometry(lo_shape2);
                    lo_mesh2 = new THREE.Mesh(lo_geometry2, new THREE.MeshBasicMaterial(/*{ color: pv_color  , side: THREE.DoubleSide  }*/));
                    //////let lv_hex = this.main.common_func.decimalToHexColor(+pv_color); // "плюс" - перевод аргумента в числовой тип
                    //////lo_mesh2.material.color.set(lv_hex);

                    //05022025 lo_mesh2.material.color.set(+po_color_rgb);//05022025 "плюс" - перевод аргумента из строкового в числовой тип


                    //17032025 {
                    //////////let lo_rgb = this.main.common_func.parseRGBString(po_color_rgb);

                    ////////////16032025 lo_mesh2.material.color.setRGB(po_color_rgb.r, po_color_rgb.g, po_color_rgb.b); //05022025
                    /////////////lo_mesh2.material.color.setRGB(lo_rgb.r, lo_rgb.g, lo_rgb.b); //16032025

                    //////////lo_mesh2.material.color.r = lo_rgb.r;
                    //////////lo_mesh2.material.color.g = lo_rgb.g;
                    //////////lo_mesh2.material.color.b = lo_rgb.b;

                    lo_mesh2.material.color.set(po_color_rgb);

                    //17032025 }







                    //04022025 if (pv_remember_color) {
                    //04022025 // Запоминание в массиве цвета фигуры

                    let lo_mesh_color_data = new typ_mesh_colors();

                    lo_mesh_color_data.num_spline_left = lv_num_spline_left;
                    lo_mesh_color_data.num_spline_right = lv_num_spline_right;
                    //02052025 lo_mesh_color_data.color = pv_color.toString();//310123025
                    lo_mesh_color_data.color = po_color_rgb;// 02052025


                    let lv_mesh_color_name = "mesh_color_";
                    let lv_name_left_part = "|";
                    let lv_name_right_part = "|";

                    // Определение индекса в массиве для сохранения
                    let lv_ar_shapes_colors_idx;

                    if (lo_mesh_color_data.num_spline_left == null && lo_mesh_color_data.num_spline_right !== null) {
                        // крайняя левая фигура
                        lv_ar_shapes_colors_idx = 0;
                        lv_name_right_part = lo_mesh_color_data.num_spline_right.toString();
                    }

                    if (lo_mesh_color_data.num_spline_left !== null && lo_mesh_color_data.num_spline_right !== null) {
                        //средняя фигура
                        lv_ar_shapes_colors_idx = lo_mesh_color_data.num_spline_left + 1;
                        lv_name_left_part = lo_mesh_color_data.num_spline_left.toString();
                        lv_name_right_part = lo_mesh_color_data.num_spline_right.toString();
                    }

                    if (lo_mesh_color_data.num_spline_left !== null && lo_mesh_color_data.num_spline_right == null) {
                        // крайняя правая фигура
                        lv_ar_shapes_colors_idx = lo_mesh_color_data.num_spline_left + 2;
                        lv_name_left_part = lo_mesh_color_data.num_spline_left.toString();

                    }

                    if (pv_remember_color) { //04022025
                        // Запоминание в массиве цвета фигуры //04022025
                        this.ar_shapes_colors[lv_ar_shapes_colors_idx] = lo_mesh_color_data;
                    }

                    lo_mesh2.renderOrder = 1;

                    //04022025 {
                    lv_mesh_color_name = lv_mesh_color_name + lv_name_left_part + "_" + lv_name_right_part;
                    lo_mesh2.name = lv_mesh_color_name;

                    let lo_found_object = this.main.group_color_mesh.getObjectByName(lo_mesh2.name);
                    if (lo_found_object) {
                        this.main.common_func.removeObjectsWithChildren(lo_found_object, true);
                    }
                    //04022025 }

                    this.main.group_color_mesh.add(lo_mesh2);

                }


                //30072024 leaks {
                //==========================================

                lar_positions = null;
                lar_left_points = null;
                lar_right_points = null;
                lo_geometry = null;
                clrs = null;
                //20012025 lo_material = null;
                lo_rectangle_coordinates = null;
                lo_userData = null;
                lo_countour_line = null;
                lar_splines_order = null;
                lar_splines_order = null;
                lv_num_spline_left = null;
                lv_num_spline_right = null;

                lar_shape_positions = null;
                lo_shape2 = null;
                lo_mesh2 = null;
                lo_geometry2 = null;

                //==========================================
                //30072024 leaks }

            }

            catch (e) {

                alert('error draw_contour_and_shape: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        Shapes.prototype.draw_rectangle = function (pv_distance_bt_curves) {


            const cv_rect_width = this.shape_width; // 100;// mm figure width
            const cv_rect_height = this.shape_height; // 200; // mm figure height

            try {

                let lo_group = new THREE.Group();


                const positions = [];
                positions.push(0, 0, 0);
                positions.push(0, cv_rect_height, 0);
                positions.push(cv_rect_width, cv_rect_height, 0);
                positions.push(cv_rect_width, 0, 0);
                positions.push(0, 0, 0);


                let lv_color = 0x0040f0;
                ////let lv_x = 0; //13032024  pv_distance_bt_curves/2;// / 2; // 0;
                ////let lv_y = 0;

                const clrs = [];
                positions.forEach(() => {
                    clrs.push(255, 0, 255);
                });


                let geometry = new LineGeometry();

                //let lo_points = rectangleShape.getPoints();

                geometry.setPositions(positions);/////
                geometry.setColors(clrs);

                ////let resolution = new THREE.Vector2();
                ////let renderer = new THREE.WebGLRenderer({ antialias: true });
                ////renderer.getSize(resolution);

                let material = new LineMaterial({
                    vertexColors: true, //0xf0f, //VertexColors,
                    linewidth: Constants.line_width_shape_contour, //7, //30012025  0.5, //1, //2,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // 30012025 Обязательно
                });

                material.needsUpdate = true;

                let lo_line = new Line2(geometry, material);
                lo_line.computeLineDistances();
                //lo_line.scale.set(1, 1, 1);

                //lo_line.name = cv_rectangle_name;

                ////30012025 lo_line.position.set(lv_x, lv_y);//, 0 pv_z - 25);

                //lo_group.add(lo_line);


                lo_group.renderOrder = 3;
                this.group_rect = lo_group;

                this.scene.add(lo_group);
                //this.plane.add(lo_group);//31012025

            }

            catch (e) {

                alert('error draw_rectangle: ' + e.stack);

            }

        }



        //-----------------------------------------------------------------
        // получение текущей высоты (длины) кривых
        Shapes.prototype.get_current_splines_height = function () {

            let lv_result = 1;

            try {

                if (this.ar_splines_nodes.length > 0) {

                    lv_result = this.ar_splines_nodes[this.ar_splines_nodes.length - 1].position.y;
                }
            }

            catch (e) {

                alert('error get_current_splines_height: ' + e.stack);

            }

            return lv_result;

        }


        //------------------------------------------------------------------------
        Shapes.prototype.get_nspline_by_name = function (pv_name) {

            const lc_spline_name = "spline_";

            let lv_result = -1;

            try {

                let lv_index = pv_name.indexOf(lc_spline_name);

                if (lv_index < 0) {
                    return lv_result;
                }
                lv_index = lv_index + pv_name.length - 1;
                lv_result = pv_name.substr(lv_index);



            }

            catch (e) {

                alert('error get_nspline_by_name: ' + e.stack);

            }

            return lv_result;

        }


        //-----------------------------------------------------------------
        Shapes.prototype.get_left_and_right_splines_of_clicked_figure = function (po_event) {

            let lo_spline_result = null;
            let lo_segment_result = null;
            let lo_prev_intersect_object = null;

            let lo_line;

            try {

                let lo_container = $('#' + po_event.currentTarget.id)[0];

                //06052024 let lo_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, this.main.container, po_event.clientX, po_event.clientY);
                let lo_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, lo_container, po_event.clientX, po_event.clientY); //06052024

                const lc_endline_x = 500;


                let lo_active_side_shape_generator = get_active_side_shape_generator();

                lo_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, lo_container, po_event.clientX, po_event.clientY); //06052024
                let lo_pos_plane = new THREE.Vector2(lo_pos.x, lo_pos.y);

                const lo_material = new THREE.LineBasicMaterial({ color: 0x0000ff });

                const lar_points = [];
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lc_endline_x, lo_pos.y));
                const lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line = new THREE.Line(lo_geometry, lo_material);

                lo_prev_intersect_object = null;


                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {
                    //let lv_spline_name = this.get_spline_name_by_number(lv_i);
                    //let lo_spl = po_scene.getObjectByName(lv_spline_name);

                    let lv_line_index = this.ar_splines[lv_i].children.length - 1; //последний член массива - line

                    let lo_spl = this.ar_splines[lv_i].children[lv_line_index];

                    //13122024 let lo_intersect_object = this.GetTwoShapeIntersect(lo_line, lo_spl)
                    let lo_intersect_object = this.main.common_func.GetTwoShapeIntersect(lo_line, lo_spl); //13122024
                    if (lo_intersect_object) {

                        if (lo_prev_intersect_object) {
                            if (lo_intersect_object.min_x < lo_prev_intersect_object.min_x) {
                                lo_spline_result = lo_intersect_object.object;
                                lo_prev_intersect_object = lo_intersect_object;
                            }
                        }
                        else {
                            lo_prev_intersect_object = lo_intersect_object;
                            lo_spline_result = lo_intersect_object.object;

                        }


                    }
                }

            }

            catch (e) {

                alert('error get_splines_and_segment_of_clicked_figure: ' + e.stack);

            }


            // Поиск выбранного сегмента сплайна
            lo_prev_intersect_object = null;

            if (lo_spline_result) {

                for (let lv_i = 0; lv_i < lo_spline_result.parent.children.length - 1; lv_i++) {

                    if (lo_spline_result.parent.children[lv_i].type == "Group") {

                        let lv_line_index = lo_spline_result.parent.children[lv_i].children.length - 1;

                        let lo_segment_line = lo_spline_result.parent.children[lv_i].children[lv_line_index];

                        //13122024 let lo_intersect_object = this.GetTwoShapeIntersect(lo_line, lo_segment_line)
                        let lo_intersect_object = this.main.common_func.GetTwoShapeIntersect(lo_line, lo_segment_line); //13122024 

                        if (lo_intersect_object) {

                            if (lo_prev_intersect_object) {
                                if (lo_intersect_object.min_y < lo_prev_intersect_object.min_y) {
                                    lo_segment_result = lo_intersect_object.nspline;
                                    lo_prev_intersect_object = lo_intersect_object;
                                }
                            }
                            else {
                                lo_prev_intersect_object = lo_intersect_object;
                                //lv_result = lo_intersect_object.nspline;
                                lo_segment_result = lo_intersect_object.object;

                            }
                        }
                    }
                }

            }

            return {
                //spline: lo_spline_result,
                segment: lo_segment_result
            }
        }




        //-----------------------------------------------------------------

        Shapes.prototype.get_lines_in_group = function (po_group) {

            let lar_objects = [];

            for (let lv_i = 0; lv_i < po_group.children.length; lv_i++) {

                if (po_group.children[lv_i].type == "Line") {
                    lar_objects.push(po_group.children[lv_i]);
                }
            }


            return lar_objects;

        }




        //------------------------------------------------------------------------
        Shapes.prototype.get_splines = function () {

            let lar_out = [];

            try {

                let lar = this.main.scene.getObjectsByProperty("type", "Group");

                for (let lv_i = 0; lv_i < lar.length; lv_i++) {
                    if (lar[lv_i].name.indexOf(cv_spline_group_name_prefix) >= 0) { //30042024
                        if (lar[lv_i].parent != null) { //16032025 
                            if (lar[lv_i].children.length > 0) { //07032025 
                                lar_out.push(lar[lv_i]);
                            }
                        } //1602025
                    }
                }


                ////// удаляем элементы, у которых число детей меньше 2 
                ////lar_out = lar_out.filter(item => (item.type === "Group" && item.children.length > 0) 
                ////                                        || (item.type === "Line")  );


            }

            catch (e) {

                alert('error get_splines: ' + e.stack);

            }


            return lar_out;
        }


        //------------------------------------------------------------------------------------------------------------------
        Shapes.prototype.get_spline_group_index_of_selected_segment = function (/*par_selected_segments,*/ po_selected_segment) {

            let lv_result = -1;
            let lv_ar_splines_index = -1;

            try {

                if (!po_selected_segment) {
                    return lv_result;
                }

                let lo_lineElement = null;
                let lv_is_founded = false;








                ////for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {


                ////    //04032025 if (po_selected_segment.parent.parent == this.ar_splines[lv_i]) {
                ////    if (po_selected_segment.parent.parent.name == this.ar_splines[lv_i].name) {

                ////        for (let lv_j = 0; lv_j < this.ar_splines[lv_i].children.length; lv_j++) {

                ////            if (this.ar_splines[lv_i].children[lv_j] instanceof THREE.Group) {

                ////                lo_lineElement = this.ar_splines[lv_i].children[lv_j].children.find(item => item instanceof THREE.Line);
                ////                //04032025 if (po_selected_segment == lo_lineElement) {
                ////                if (po_selected_segment.name == lo_lineElement.name) {
                ////                    lv_result = lv_j;
                ////                    break;
                ////                }
                ////            }

                ////            //lineElement = this.ar_splines[lv_i].children[lv_j].find(item => item instanceof THREE.Line);
                ////            //if (po_selected_segment == lineElement) {
                ////            //    lv_result = lv_i;
                ////            //}

                ////        }
                ////    }

                ////    if (lv_result >= 0) {
                ////        break;
                ////    }
                ////}



                // поиск сплайна с выделенным сегментом
                //13032025 let lv_index = this.ar_splines.findIndex(obj => obj === po_selected_segment.parent.parent);

                lv_ar_splines_index = this.ar_splines.findIndex(obj => obj.name === po_selected_segment.parent.parent.name); //13032025
                if (lv_ar_splines_index < 0) {
                    return lv_result;
                }
                let lo_spline_group = this.ar_splines[lv_ar_splines_index];


                for (let lv_i = 0; lv_i < lo_spline_group.children.length; lv_i++) {


                    //13032025 {
                    ////let lv_line_index = lo_spline_group.children[lv_i].children.findIndex(obj => obj.type === "Line");

                    ////if (lv_line_index >= 0) {

                    ////    //12032025 if (lo_spline_group.children[lv_i].children[lv_line_index] == po_selected_segment) {
                    ////    if (lo_spline_group.children[lv_i].children[lv_line_index].name == po_selected_segment.name) { //12032025
                    ////        lv_result = lv_i;
                    ////        return lv_result;
                    ////    }

                    ////}


                    let lv_line_index = lo_spline_group.children[lv_i].children.findIndex(obj => obj.name === po_selected_segment.name);

                    if (lv_line_index >= 0) {

                        ////12032025 if (lo_spline_group.children[lv_i].children[lv_line_index] == po_selected_segment) {
                        //if (lo_spline_group.children[lv_i].children[lv_line_index].name == po_selected_segment.name) { //12032025
                        lv_result = lv_i;
                        //13032025 return lv_result;
                        break; //13032025
                        //}

                    }
                    //13032025 }




                }





            }

            catch (e) {

                alert('error get_spline_group_index_of_selected_segment: ' + e.stack);

            }

            //return lv_result;

            return {
                ar_splines_index: lv_ar_splines_index,
                segment_index: lv_result
            };
        }



        //------------------------------------------------------------------------
        Shapes.prototype.get_spline_points = function (po_spline_group) {

            let lar_points = [];

            try {

                let lo_spline_group;

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    if (lo_spline_group != po_spline_group) {

                        continue;
                    }


                    for (let lv_j = 0; lv_j < lo_spline_group.children.length; lv_j++) {

                        let lo_segment_group = lo_spline_group.children[lv_j];

                        if (lo_segment_group instanceof THREE.Group) {

                            for (let lv_k = 0; lv_k < lo_segment_group.children.length; lv_k++) {

                                if (lo_segment_group.children[lv_k] instanceof THREE.Mesh) {

                                    //lo_segment_group.children[lv_k].visible = pv_visible;

                                    lar_points.push(lo_segment_group.children[lv_k].position);

                                }

                            }
                        }

                    }

                }

            }

            catch (e) {

                alert('error get_spline_points: ' + e.stack);

            }

            return lar_points;

        }


        //------------------------------------------------------------------------
        Shapes.prototype.get_splines_points_for_model = function () {

            let lar_splines_points = [];


            let lar_segments_beg_points_numbers;//01112024
            let lar_segment_beg_points_number;//01112024 


            try {

                let lo_spline_group;

                let lar_spline_points = [];

                lar_segments_beg_points_numbers = [];//01112024

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    let lar_spline_points = [];
                    //lar_segments_beg_points_numbers = [];//01112024

                    lar_segment_beg_points_number = [];//01112024 

                    for (let lv_j = 0; lv_j < lo_spline_group.children.length; lv_j++) {

                        let lo_segment_group = lo_spline_group.children[lv_j];

                        if (lo_segment_group instanceof THREE.Group) {

                            //lar_segment_beg_points_number = [];//01112024 
                            for (let lv_k = 0; lv_k < lo_segment_group.children.length; lv_k++) {

                                if (lo_segment_group.children[lv_k] instanceof THREE.Mesh) {

                                    lar_spline_points.push(
                                        [lo_segment_group.children[lv_k].position.x, lo_segment_group.children[lv_k].position.y]);

                                    if (lv_k == 0) // первый узел сегмента
                                    {
                                        lar_segment_beg_points_number.push(lar_spline_points.length - 1);

                                    }

                                }

                            }

                            //lar_segments_beg_points_numbers.push(lar_segment_beg_points_number);
                        }

                    }

                    lar_segments_beg_points_numbers.push(lar_segment_beg_points_number);

                    lar_splines_points.push(lar_spline_points);

                }

            }

            catch (e) {

                alert('error get_spline_points: ' + e.stack);

            }



            //01112024 {

            //return lar_splines_points;

            return {
                Segments_beg_points_numbers: lar_segments_beg_points_numbers,
                PointsCurves: lar_splines_points

            }

            //01112024 }
        }


        //-----------------------------------------------------------------
        Shapes.prototype.get_splines_and_segment_of_clicked_figure = function (po_event) {

            let lo_spline_result_right = null;
            let lo_segment_result_right = null;
            let lo_prev_spline_right;
            let lo_prev_segment_right;

            //12072024 {
            let lo_spline_result_left = null;
            let lo_segment_result_left = null;
            let lo_prev_spline_left;
            let lo_prev_segment_left;
            //12072024 }

            let lo_line_to_right;
            let lo_line_to_left; //12072024

            try {

                let lo_active_side_shape_generator = get_active_side_shape_generator();//14072024 

                //14072024 let lo_container = $('#' + po_event.currentTarget.id)[0];
                let lo_container = lo_active_side_shape_generator.container; //14072024




                let lo_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, lo_container, po_event.clientX, po_event.clientY); //06052024

                const lc_endline_right_x = 500;
                const lc_endline_left_x = -500;// 12072024


                lo_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, lo_container, po_event.clientX, po_event.clientY); //06052024
                let lo_pos_plane = new THREE.Vector2(lo_pos.x, lo_pos.y);

                const lo_material = new THREE.LineBasicMaterial({});

                let lar_points = [];

                // Line from mouse point to right
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lc_endline_right_x, lo_pos.y));
                let lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_right = new THREE.Line(lo_geometry, lo_material);

                // Line from mouse point to left

                lar_points = [];
                lar_points.push(new THREE.Vector2(lo_pos_plane.x, lo_pos_plane.y));
                lar_points.push(new THREE.Vector2(lc_endline_left_x, lo_pos.y));
                lo_geometry = new THREE.BufferGeometry().setFromPoints(lar_points);
                lo_line_to_left = new THREE.Line(lo_geometry, lo_material);

                lo_active_side_shape_generator.scene.add(lo_line_to_left);/////15072024
                //lo_active_side_shape_generator.plane.add(lo_line_to_left);/////31012025



                lo_prev_spline_right = null;
                lo_prev_spline_left = null;


                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    let lv_line_index = this.ar_splines[lv_i].children.length - 1; //последний член массива - line
                    let lo_spl = this.ar_splines[lv_i].children[lv_line_index];

                    let lo_intersect_to_right_object = this.main.common_func.GetTwoShapeIntersect(lo_line_to_right, lo_spl);
                    let lo_intersect_to_left_object = this.main.common_func.GetTwoShapeIntersect(lo_line_to_left, lo_spl);

                    if (lo_intersect_to_right_object) {

                        if (lo_prev_spline_right) {
                            if (lo_intersect_to_right_object.min_x < lo_prev_spline_right.min_x) {
                                lo_prev_spline_right = lo_spline_result_right;
                                lo_spline_result_right = lo_intersect_to_right_object;
                            }
                        }
                        else {
                            lo_prev_spline_right = lo_intersect_to_right_object;
                            lo_spline_result_right = lo_intersect_to_right_object;

                        }
                    }


                    if (lo_intersect_to_left_object) {

                        if (lo_prev_spline_left) {
                            if (lo_intersect_to_left_object.min_x > lo_prev_spline_left.min_x) {
                                lo_prev_spline_left = lo_spline_result_left;
                                lo_spline_result_left = lo_intersect_to_left_object;
                            }
                        }
                        else {
                            lo_prev_spline_left = lo_intersect_to_left_object;
                            lo_spline_result_left = lo_intersect_to_left_object;

                        }
                    }

                }


                // Поиск выбранного сегмента сплайна

                lo_prev_segment_left = null;
                lo_prev_segment_right = null;

                if (lo_spline_result_right) {

                    ////for (let lv_i = 0; lv_i < lo_spline_result_right.parent.children.length - 1; lv_i++) {

                    ////	if (lo_spline_result_right.parent.children[lv_i].type == "Group") {

                    ////		let lv_line_index = lo_spline_result_right.parent.children[lv_i].children.length - 1;

                    ////		let lo_segment_line = lo_spline_result_right.parent.children[lv_i].children[lv_line_index];

                    ////		let lo_intersect_object = this.GetTwoShapeIntersect(lo_line_to_right, lo_segment_line)

                    ////		if (lo_intersect_object) {

                    ////			if (lo_prev_intersect_segment_right) {
                    ////				if (lo_intersect_object.min_y < lo_prev_intersect_segment_right.min_y) {
                    ////					//16082024 lo_segment_result_right = lo_intersect_object.nspline;
                    ////					lo_segment_result_right = lo_intersect_object.object; //16082024
                    ////					lo_prev_intersect_segment_right = lo_intersect_object;
                    ////				}
                    ////			}
                    ////			else {
                    ////				lo_prev_intersect_segment_right = lo_intersect_object;
                    ////				//lv_result = lo_intersect_object.nspline;
                    ////				lo_segment_result_right = lo_intersect_object.object;

                    ////			}
                    ////		}
                    ////	}
                    ////}


                    for (let lv_i = 0; lv_i < lo_spline_result_right.object.parent.children.length - 1; lv_i++) {

                        if (lo_spline_result_right.object.parent.children[lv_i].type == "Group") {

                            let lv_line_index = lo_spline_result_right.object.parent.children[lv_i].children.length - 1;

                            let lo_segment_line = lo_spline_result_right.object.parent.children[lv_i].children[lv_line_index];

                            //13122024 let lo_intersect_object = this.GetTwoShapeIntersect(lo_line_to_right, lo_segment_line)
                            let lo_intersect_object = this.main.common_func.GetTwoShapeIntersect(lo_line_to_right, lo_segment_line); //13122024

                            if (lo_intersect_object) {

                                if (lo_prev_segment_right) {
                                    if (lo_intersect_object.min_y < lo_prev_segment_right.min_y) {
                                        //16082024 lo_segment_result_right = lo_intersect_object.nspline;
                                        lo_segment_result_right = lo_intersect_object.object; //16082024
                                        lo_prev_segment_right = lo_intersect_object;
                                    }
                                }
                                else {
                                    lo_prev_segment_right = lo_intersect_object;
                                    //lv_result = lo_intersect_object.nspline;
                                    lo_segment_result_right = lo_intersect_object.object;

                                }
                            }
                        }
                    }


                }



                ////if (lo_spline_result_left == lo_spline_result_right) {

                ////	if (lo_prev_intersect_spline_right) {
                ////		lo_spline_result_right = lo_prev_intersect_spline_right.object;
                ////	}
                ////	else {

                ////		if (lo_prev_intersect_spline_left) {
                ////			lo_spline_result_left = lo_prev_intersect_spline_left.object;
                ////		}

                ////	}

                ////}




                while (true) {


                    if (lo_spline_result_left && lo_spline_result_right) {

                        if (lo_spline_result_left.object == lo_spline_result_right.object) {


                            if (lo_prev_spline_left && lo_prev_spline_right) {

                                if (lo_spline_result_left.object != lo_prev_spline_left.object) {

                                    lo_spline_result_left = lo_prev_spline_left;

                                    //lo_spline_result_right = null;//18072024
                                }
                                else {


                                    if (lo_spline_result_right.object != lo_prev_spline_right.object) {

                                        lo_spline_result_right = lo_prev_spline_right;

                                        //lo_spline_result_left = lo_prev_spline_left;
                                        //lo_spline_result_right = null;
                                    }
                                    else {
                                        lo_spline_result_left = null;
                                    }

                                }
                                break;


                            }
                            else {

                                if (lo_prev_spline_left && lo_prev_spline_right == null) {

                                    if (lo_spline_result_left.object != lo_prev_spline_left.object) {
                                        lo_spline_result_right = null;
                                    }
                                    else {

                                        lo_spline_result_left = lo_prev_spline_left;
                                    }

                                    break;

                                }

                                else {

                                    if (lo_prev_spline_left == null && lo_prev_spline_right) {

                                        lo_spline_result_left = null;

                                    }

                                    else {

                                        if (lo_prev_spline_left == null && lo_prev_spline_right == null) {

                                        }

                                    }


                                }

                            }

                        }

                    }


                    break;
                }







                //if (lo_spline_result_left.object == lo_spline_result_right.object) {

                //	if (lo_prev_intersect_spline_left) {

                //		if (lo_spline_result_left.object != lo_prev_intersect_spline_left.object) {
                //			lo_spline_result_left = lo_prev_intersect_spline_left;
                //		}
                //		else {

                //			lo_spline_result_left = null;
                //			//if (lo_prev_intersect_spline_left) {
                //			//	if (lo_spline_result_left.object != lo_prev_intersect_spline_left.object) {
                //			//		lo_spline_result_left = lo_prev_intersect_spline_left;
                //			//	}

                //			//	lo_spline_result_left = lo_prev_intersect_spline_left;
                //			//}

                //		}



                //	}
                //	////else {

                //	////	if (lo_prev_intersect_spline_left) {
                //	////		lo_spline_result_left = lo_prev_intersect_spline_left;
                //	////	}

                //	////}

                //}






                //	}

                //}



                this.main.common_func.removeObjectsWithChildren(lo_line_to_left, true);
                this.main.common_func.removeObjectsWithChildren(lo_line_to_right, true);



            }

            catch (e) {

                alert('error get_splines_and_segment_of_clicked_figure: ' + /*e.message + "\n" +*/ e.stack);

            }


            let lo_out_spline_left = null;
            let lo_out_spline_right = null;
            //let lo_out_segment_right = null;


            if (lo_spline_result_left) {
                lo_out_spline_left = lo_spline_result_left.object;
            }
            if (lo_spline_result_right) {
                lo_out_spline_right = lo_spline_result_right.object;
            }


            return {

                spline_left: lo_out_spline_left,
                spline_right: lo_out_spline_right,
                segment: lo_segment_result_right
            }
        }



        //------------------------------------------------------------------------
        Shapes.prototype.get_spline_name_by_number = function (pv_spline_number) {
            return "spline_" + pv_spline_number;
        }



        //-----------------------------------------------------------------
        // получение максимальной высоты (длины) кривых
        Shapes.prototype.get_spline_height = function (po_spline_group) {

            let lv_result = 0;

            try {
                let lar_spline_positions_array = po_spline_group.children[po_spline_group.children.length - 1].geometry.attributes.position.array;
                lv_result = Math.abs(lar_spline_positions_array[lar_spline_positions_array.length - 2]); // наибольшая координата y

            }

            catch (e) {

                alert('error get_spline_height: ' + e.stack);

            }

            return lv_result;
        }

        //-----------------------------------------------------------------
        // получение максимальной высоты (длины) кривых
        Shapes.prototype.get_splines_height_max = function () {

            let lv_result = 1;


            let lv_y_max = -1000;
            let lv_y_curr = 0;

            let lv_attr_length = 0;

            try {

                for (let lv_i = 0; lv_i < this.main.shapes.ar_splines.length; lv_i++) {

                    lv_attr_length = this.main.shapes.ar_splines[lv_i].children[this.main.shapes.ar_splines[lv_i].children.length - 1].geometry.attributes.position.array.length;

                    lv_y_curr = this.main.shapes.ar_splines[lv_i].children[this.main.shapes.ar_splines[lv_i].children.length - 1].geometry.attributes.position.array[lv_attr_length - 2];

                    if (lv_y_curr > lv_y_max) {

                        lv_y_max = lv_y_curr;
                    }
                }

                lv_result = lv_y_max;

            }

            catch (e) {

                alert('error get_current_splines_height: ' + e.stack);

            }

            return lv_result;

        }


        //------------------------------------------------------------------------
        Shapes.prototype.get_distance_bt_curves = function () {

            ////let lv_distance = this.shape_width * this.distance_between_curves_in_percent_of_width / 100;
            ////return lv_distance;

            return this.distance_between_curves;
        }



        //------------------------------------------------------------------------
        Shapes.prototype.get_splines_points = function () {

            let lar_points = [];

            try {

                let lo_spline_group;

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    for (let lv_j = 0; lv_j < lo_spline_group.children.length; lv_j++) {

                        let lo_segment_group = lo_spline_group.children[lv_j];

                        if (lo_segment_group instanceof THREE.Group) {

                            for (let lv_k = 0; lv_k < lo_segment_group.children.length; lv_k++) {

                                if (lo_segment_group.children[lv_k] instanceof THREE.Mesh) {

                                    lar_points.push(lo_segment_group.children[lv_k]);

                                }

                            }
                        }

                    }

                }

            }

            catch (e) {

                alert('error get_splines_points: ' + e.stack);

            }



            return lar_points;

        }


        //------------------------------------------------------------------------
        Shapes.prototype.get_segments_points = function (po_spline_group) {

            let lar_segments_points = [];

            try {

                let lo_segment_group;

                for (let lv_i = 0; lv_i < po_spline_group.children.length; lv_i++) {

                    let lo_segment_points = po_spline_group.children[lv_i];

                    if (lo_segment_points instanceof THREE.Group) {

                        let lar_segment_points = [];

                        for (let lv_k = 0; lv_k < lo_segment_points.children.length; lv_k++) {

                            if (lo_segment_points.children[lv_k] instanceof THREE.Mesh) {

                                lar_segment_points.push(lo_segment_points.children[lv_k].position);
                            }
                        }

                        lar_segments_points.push({
                            points: lar_segment_points,
                            parent: lo_segment_points
                        });


                    }
                    else {

                        continue;
                    }

                }


            }

            catch (e) {

                alert('error get_segments_points: ' + e.stack);

            }

            return lar_segments_points;

        }



        //-----------------------------------------------------------------
        // Восстановление цвета фигур
        Shapes.prototype.redraw_meshes_color = function (par_splines_order) {

            try {

                this.clear_group_color_mesh();//03082024

                for (let lv_i = 0; lv_i < this.ar_shapes_colors.length; lv_i++) {

                    if (this.ar_shapes_colors[lv_i] == null /* 20012025 || !this.ar_shapes_colors[lv_i]*/) {
                        continue;
                    }
                    let lo_spline_left = this.main.common_func.getSplineByNumber(par_splines_order, this.ar_shapes_colors[lv_i].num_spline_left);
                    let lo_spline_right = this.main.common_func.getSplineByNumber(par_splines_order, this.ar_shapes_colors[lv_i].num_spline_right);
                    //03022025 this.draw_contour_and_shape(this.ar_shapes_colors[lv_i].color, lo_spline_left, lo_spline_right, false, false, false, true);
                    this.draw_contour_and_shape(this.ar_shapes_colors[lv_i].color, lo_spline_left, lo_spline_right, false, false, false, true);//03022025
                }

            }

            catch (e) {

                alert('error redraw_meshes_color: ' + e.stack);

            }
        }

        //-----------------------------------------------------------------
        // Сделать зеркальное отражение выделенных сегментов
        Shapes.prototype.make_mirror_selected_segments = function () {

            let lar_selected_spline_groups = [];

            //26022025let lo_segment;//23042024

            try {

                for (let lv_i = 0; lv_i < this.ar_selected_segments.length; lv_i++) {

                    let lo_selected_segment = this.ar_selected_segments[lv_i];

                    if (lo_selected_segment.parent) {

                        let lo_parent_parent = lo_selected_segment.parent.parent;

                        this.ar_selected_segments[lv_i] = this.make_mirror_segment(lo_selected_segment);//23042024


                        lar_selected_spline_groups.push(lo_parent_parent);
                    }
                }















                // Оставляем уникальные элементы
                lar_selected_spline_groups = [...new Set(lar_selected_spline_groups)];


                for (let lv_i = 0; lv_i < lar_selected_spline_groups.length; lv_i++) {

                    let lar_spline_points = [];

                    let lar_segments_groups = lar_selected_spline_groups[lv_i].children;

                    for (let lv_j = 0; lv_j < lar_segments_groups.length; lv_j++) {

                        let lar_segments_nodes = lar_segments_groups[lv_j];

                        if (lar_segments_nodes.type == "Group") {

                            for (let lv_k = 0; lv_k < lar_segments_nodes.children.length; lv_k++) {

                                if (lar_segments_nodes.children[lv_k].type == "Mesh") {
                                    lar_spline_points.push(lar_segments_nodes.children[lv_k].position);
                                }
                            }
                        }

                        if (lar_segments_nodes.type == "Line") {

                            this.main.common_func.removeObjectsWithChildren(lar_segments_nodes, true);//22042024

                        }


                    }



                    //26022025 lo_segment = this.main.splines.draw_curve(lar_selected_spline_groups[lv_i], lar_spline_points, cv_segment_name_prefix, true);//25042024
                    this.main.splines.draw_curve(lar_selected_spline_groups[lv_i], lar_spline_points, cv_segment_name_prefix, true);//26022025

                }

            }

            catch (e) {

                alert('error make_mirror_selected_segments: ' + e.stack);

            }

            return null;//? 26022025  lo_segment;
        }



        //-----------------------------------------------------------------
        // Сделать зеркальное отражение выделенных сегментов
        Shapes.prototype.make_mirror_segment = function (po_segment) {


            let lar_new_segment_points = [];

            let lo_segment_point;

            let lv_base_x = 0;

            let lo_segment;//23042024

            try {

                for (let lv_i = 0; lv_i < po_segment.parent.children.length - 1; lv_i++) {

                    lo_segment_point = po_segment.parent.children[lv_i];

                    if (lv_i == 0) {
                        lv_base_x = lo_segment_point.position.x;
                    }

                    let lv_delta = lv_base_x - lo_segment_point.position.x;

                    lo_segment_point.position.x = lv_base_x + lv_delta;


                    lar_new_segment_points.push(lo_segment_point.position);

                }


                // Удаление предыдущих линий
                let lo_parent = po_segment.parent;
                let lar_lines = this.main.shapes.get_lines_in_group(po_segment.parent);
                for (let lv_i = 0; lv_i < lar_lines.length; lv_i++) {
                    this.main.common_func.removeObjectsWithChildren(lar_lines[lv_i], true);
                }

                lo_segment = this.main.splines.draw_curve(lo_parent, lar_new_segment_points, cv_segment_name_prefix, false);//05082024

            }

            catch (e) {

                alert('error make_mirror_segment: ' + e.stack);

            }

            return lo_segment;

        }

        //-----------------------------------------------------------------
        // Сделать для выделенного сегмента случайные размеры
        Shapes.prototype.make_random_segment = function (po_segment) {

            let lar_new_segment_points = [];

            let lo_segment_point;

            let lv_base_x = 0;
            //let lv_base_y = 0; //1102205

            let lv_delta = 0;
            let lo_segment;

            try {

                //11022025 for (let lv_i = 0; lv_i < po_segment.parent.children.length - 1; lv_i++) {
                for (let lv_i = 0; lv_i < po_segment.parent.children.length/* - 1*/; lv_i++) {

                    lo_segment_point = po_segment.parent.children[lv_i];

                    if (lv_i == 0) {
                        lv_base_x = lo_segment_point.position.x;
                        //lv_base_y = lo_segment_point.position.y;//11022025 
                    }

                    lv_delta = lv_base_x - lo_segment_point.position.x;
                    //let lv_delta_x = lv_base_x + lo_segment_point.position.x;
                    //let lv_delta_y = lv_base_y - lo_segment_point.position.y;



                    lo_segment_point.position.x = lv_base_x + lv_delta;

                    //lo_segment_point.position.x = lv_base_x - lv_delta_x + Math.random() * 3; //11022025
                    //lo_segment_point.position.y = lv_base_y - lv_delta_y + Math.random() * 3; //11022025





                    lar_new_segment_points.push(lo_segment_point.position);

                }


                // Удаление предыдущих линий
                let lo_parent = po_segment.parent;
                let lar_lines = this.main.shapes.get_lines_in_group(po_segment.parent);
                for (let lv_i = 0; lv_i < lar_lines.length; lv_i++) {
                    this.main.common_func.removeObjectsWithChildren(lar_lines[lv_i], true);
                }

                lo_segment = this.main.splines.draw_curve(lo_parent, lar_new_segment_points, cv_segment_name_prefix, false);//05082024

            }

            catch (e) {

                alert('error make_random_segment: ' + e.stack);

            }

            return lo_segment;

        }



        //-----------------------------------------------------------------
        // Сделать случайные размеры выделенных сегментов
        Shapes.prototype.make_random_selected_segments = function () {

            let lar_selected_spline_groups = [];


            let lo_segment;//23042024

            try {


                for (let lv_i = 0; lv_i < this.ar_selected_segments.length; lv_i++) {

                    let lo_selected_segment = this.ar_selected_segments[lv_i];

                    if (lo_selected_segment.parent) {

                        let lo_parent_parent = lo_selected_segment.parent.parent;

                        this.ar_selected_segments[lv_i] = this.make_random_segment(lo_selected_segment);

                        lar_selected_spline_groups.push(lo_parent_parent);
                    }
                }


                for (let lv_i = 0; lv_i < lar_selected_spline_groups.length; lv_i++) {

                    let lar_spline_points = [];

                    let lar_segments_groups = lar_selected_spline_groups[lv_i].children;

                    for (let lv_j = 0; lv_j < lar_segments_groups.length; lv_j++) {

                        let lar_segments_nodes = lar_segments_groups[lv_j];

                        if (lar_segments_nodes.type == "Group") {

                            for (let lv_k = 0; lv_k < lar_segments_nodes.children.length; lv_k++) {

                                if (lar_segments_nodes.children[lv_k].type == "Mesh") {
                                    lar_spline_points.push(lar_segments_nodes.children[lv_k].position);
                                }
                            }
                        }

                        if (lar_segments_nodes.type == "Line") {

                            this.main.common_func.removeObjectsWithChildren(lar_segments_nodes, true);//22042024

                        }


                    }





                    lo_segment = this.main.splines.draw_curve(lar_selected_spline_groups[lv_i], lar_spline_points, cv_segment_name_prefix, true);//25042024

                    //////11022025 {
                    //lo_segment.scale.x = 0.5;
                    //lo_segment.scale.у = 0.5;
                    //lo_segment.updateMatrix();
                    //lo_segment.updateMatrixWorld();
                    //lo_segment.updateWorldMatrix();
                    //////11022025 }
                }

            }

            catch (e) {

                alert('error make_random_selected_segments: ' + e.stack);

            }

            return lo_segment;
        }




        //-----------------------------------------------------------------
        // удалить выделенные сегменты
        Shapes.prototype.make_delete_selected_segments = function () {

            let lo_line_selected_segment = null;
            //let lo_beg_point_position = null;
            let lo_segment_beg_point = null;
            let lv_is_first_segment = false;
            let lv_is_last_segment = false;
            let lo_indexes_data = null; // индекс выделенного сегмента

            let lo_segment_data = null;

            let lar_spline_points = [];
            let lo_new_spline_group_with_sel_segment = null; // new THREE.Group();
            let lv_shift_y = 0;
            let lo_spline_group_with_sel_segment = null;
            let lar_segment_points = null;
            ////////150320025 let lo_next_segment_beg_point = null;

            let lo_copy_curr_segment_group = null;
            let lv_sel_index = -1;

            let lv_index_spline_group = 0;
            let lo_line = null;
            let lar_lines_names_selected_segments = [];

            ////////150320025 let lar_objects_for_delete = [];
            let lo_prev_segment_line = null;
            let lv_prev_segment_line_name = "";
            let lo_result_curve = null;//13032025


            let lo_end_point_position = 0;
            let lo_beg_point_position = 0;
            let lo_first_node_position = null;
            let lo_first_node_mesh = null;

            let lar_to_remove = [];
            try {

                this.ar_splines = this.get_splines();//11032025
                this.ar_splines_nodes = this.get_splines_points();//11032025



                // группа всех кривых
                let lo_main_curves_group = this.main.scene.getObjectByName(this.main_curves_group_prefix);
                if (!lo_main_curves_group) {
                    return;
                }


                // цикл по выделенным сегментам

                // Формирование массива имён линий выделенных сегментов
                for (let lo_segment_line of this.ar_selected_segments) {
                    lar_lines_names_selected_segments.push(lo_segment_line.name);
                }



                for (let lv_i = 0; lv_i < lar_lines_names_selected_segments.length; lv_i++) {


                    lar_to_remove = [];//16032025

                    lo_line_selected_segment = this.main.common_func.get_object_by_name_via_search_area(this.main.scene, lar_lines_names_selected_segments[lv_i]); //14032025

                    if (!lo_line_selected_segment.parent) {
                        continue;
                    }

                    lo_spline_group_with_sel_segment = lo_line_selected_segment.parent.parent;// группа сплайна выделенного сегмента

                    ////////150320025 lo_segment_group_of_sel_segment = lo_line_selected_segment.parent;// группа выделенного сегмента

                    // Определение индекса сплайн-группы выделенного сегмента в массиве сплайнов
                    lv_index_spline_group = lo_main_curves_group.children.findIndex(obj => obj.name === lo_spline_group_with_sel_segment.name); //13032025


                    lo_new_spline_group_with_sel_segment = new THREE.Group();
                    lo_new_spline_group_with_sel_segment.name = lo_spline_group_with_sel_segment.name;

                    // индексы в сплайн-группе и в сегмент-группе выделенного сегмента
                    // lo_indexes_data.ar_splines_index
                    // lo_indexes_data.segment_index

                    lo_indexes_data = this.get_spline_group_index_of_selected_segment(lo_line_selected_segment);
                    if (lo_indexes_data.segment_index < 0) {
                        return null;
                    }

                    // Определяем разницу по y (между последним и первым узлом выделенного сегмента), на которую надо будет сдвинуть
                    // сегменты после удаляемого выделенного
                    let lar_segment_meshes = this.ar_splines[lo_indexes_data.ar_splines_index].children[lo_indexes_data.segment_index].children;

                    lo_end_point_position = lar_segment_meshes[lar_segment_meshes.length - 2].position; // позиция последнего узла удаляемого сегмента
                    lo_beg_point_position = lar_segment_meshes[0].position; // позиция первого узла удаляемого сегмента

                    lv_shift_y = lo_end_point_position.y - lo_beg_point_position.y;





                    ////lo_beg_point_position = lar_segment_meshes[lar_segment_meshes.length - 2].position; // позиция последнего узла сегмента, перед которым
                    ////// вставляется новый сегмент
                    ////lo_segment_beg_point = new THREE.Vector2(lo_beg_point_position.x, lo_beg_point_position.y);//02032025

                    ////if (lo_indexes_data.segment_index == 0) {
                    ////    lv_is_first_segment = true;
                    ////}
                    ////else {
                    ////    lv_is_first_segment = false;
                    ////}

                    ////if (lo_indexes_data.segment_index === lo_spline_group_with_sel_segment.children.length - 2) {
                    ////    lv_is_last_segment = true;
                    ////}
                    ////else {
                    ////    lv_is_last_segment = false;
                    ////}



                    let lv_is_after = false;
                    lar_spline_points = [];//16032025


                    // цикл по группам сегментов,принадлежащих сплайну с выделенным сегментом
                    for (let lv_j = 0; lv_j < lo_spline_group_with_sel_segment.children.length; lv_j++) {

                        if (lo_spline_group_with_sel_segment.children[lv_j].type !== "Group") {
                            continue;
                        }

                        let lo_curr_segment_group = lo_spline_group_with_sel_segment.children[lv_j];


                        if (lo_curr_segment_group.name === lo_line_selected_segment.parent.name) { //13032025

                            // это группа выделенного сегмента



                            if (lv_j === 0) { // выделенный сегмент - первый, запоминаем его первый узел
                                // который добавим к новому первому сегменту

                                //lo_first_node = lo_curr_segment_group.children[0].clone();
                                lo_first_node_mesh = lo_curr_segment_group.children[0].clone();
                                lo_first_node_position = lo_curr_segment_group.children[0].position.clone();


                            }

                            // Заносим группу сегмента в массив для последующего удаления
                            //this.main.common_func.removeObjectsWithChildren(lo_curr_segment_group, true, false, false);//14032025
                            lar_to_remove.push(lo_curr_segment_group);//16032025








                            //////// перемещение выделенного сегмента в новую сплайн группу

                            //////lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                            //////let lv_point = lar_segment_points[lar_segment_points.length - 1];
                            //////if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                            //////    // удаление точки с нулевыми координатами (от объекта Line)
                            //////    lar_segment_points.pop();
                            //////}

                            //////lar_spline_points.push(...lar_segment_points);

                            //////lo_copy_curr_segment_group = lo_curr_segment_group.clone();




                            //////// удаление прежней линии сегмента
                            //////lo_prev_segment_line = lo_copy_curr_segment_group.children.find(obj => obj.type === "Line");
                            //////if (lo_prev_segment_line) {
                            //////    lv_prev_segment_line_name = lo_prev_segment_line.name;
                            //////}

                            //////lo_copy_curr_segment_group.remove(lo_prev_segment_line);

                            //////this.main.common_func.removeObjectsWithChildren(lo_prev_segment_line, true, false, false);//14032025


                            //////// новая кривая сегмента
                            //////lo_result_curve = this.main.splines.draw_curve(lo_copy_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false);
                            //////lo_result_curve.name = lv_prev_segment_line_name; // присваиваем имя прежней кривой


                            //////lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            //////lv_sel_index = this.ar_selected_segments.findIndex(obj => obj.name === lo_line_selected_segment.name);
                            //////if (lv_sel_index !== -1) {
                            //////    this.ar_selected_segments.splice(lv_sel_index, 1, lo_result_curve); // Вставка выделенного сегмента 
                            //////}                                                            // на место прежнего выделенного сегмента


                            //////// создание группы нового вставляемого сегмента
                            //////let lo_new_segment_group = new THREE.Group();
                            //////lo_new_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_new_segment_group);

                            //////lo_segment_data = this.main.segments.create_segment(
                            //////    lo_new_segment_group, //lo_segment_group,
                            //////    this.main.segment_transform_data,
                            //////    lo_segment_beg_point,
                            //////    lv_is_first_segment, // признак первого сегмента
                            //////    lv_is_last_segment  // признак последнего сегмента
                            //////);

                            //////// сдвиг по y сегментов после вставки нового сегмента:
                            //////lv_shift_y = lo_segment_data.segment_beg_point.y - lo_segment_beg_point.y;


                            //////////////150320025 lo_next_segment_beg_point = lo_segment_data.segment_beg_point;
                            //////this.main.splines.draw_curve(lo_new_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);
                            //////lar_spline_points.push(...lo_segment_data.points);
                            //////lo_new_spline_group_with_sel_segment.add(lo_new_segment_group);


                            lv_is_after = true;
                        }
                        else {

                            //  группа не выделенного сегмента

                            if (lv_is_after) {

                                // коррекция y-координаты на длину вставляемого сегмента

                                let lo_current_point = null;
                                for (let lv_k = 0; lv_k < lo_curr_segment_group.children.length; lv_k++) {

                                    lo_current_point = lo_curr_segment_group.children[lv_k];

                                    if (lo_current_point.type == "Mesh") {

                                        lo_current_point.position.y = lo_current_point.position.y - lv_shift_y;//030032025
                                    }

                                }



                                lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                                let lv_point = lar_segment_points[lar_segment_points.length - 1];
                                if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                                    // удаление точки с нулевыми координатами (от объекта Line)
                                    lar_segment_points.pop();
                                }



                                lo_copy_curr_segment_group = lo_curr_segment_group.clone();




                                //16032025 {
                                // если сегмент стал первым, добавляем в него первый узел от удалённого первого сегмента
                                if (lv_j == 1) {
                                    if (lo_first_node_position) {
                                        //lar_segment_points.push(lo_first_node);

                                        //lar_segment_points.splice(0, 0, lo_first_node);
                                        lar_segment_points.unshift(lo_first_node_position); // вставка на первое место массива
                                        //lo_copy_curr_segment_group.children.unshift(lo_first_node_mesh); // вставка на первое место массива


                                        // у добавляемого узла делаем то же состояние видимости, что и других (первого) узла сегмента
                                        lo_first_node_mesh.visible = lo_copy_curr_segment_group.children[0].visible;

                                        ////////lo_copy_curr_segment_group.add(lo_first_node_mesh);  // Добавляем объект
                                        //////// Перемещаем объект на первое место в children
                                        //////lo_copy_curr_segment_group.remove(lo_first_node_mesh);
                                        //////lo_first_node_mesh.parent = lo_copy_curr_segment_group;

                                        lo_first_node_mesh.parent = lo_copy_curr_segment_group
                                        lo_copy_curr_segment_group.children.unshift(lo_first_node_mesh);

                                    }
                                }



                                //16032025 }





                                // удаление предыдущей линии
                                lo_prev_segment_line = lo_copy_curr_segment_group.children.find(obj => obj.type === "Line");
                                if (lo_prev_segment_line) {
                                    lv_prev_segment_line_name = lo_prev_segment_line.name;
                                }

                                lo_copy_curr_segment_group.remove(lo_prev_segment_line);
                                this.main.common_func.removeObjectsWithChildren(lo_prev_segment_line, true, false, false);//14032025


                                // Проверка, есть ли линия сегмента среди массива выделенных сегментов
                                let lv_is_exist_from_selects = false;
                                let lv_idx = this.ar_selected_segments.findIndex(obj => obj.name === lv_prev_segment_line_name);
                                if (lv_idx >= 0) {
                                    // удаление линии сегмента из массива выделенных сегментов
                                    this.ar_selected_segments.splice(lv_idx, 1);
                                    lv_is_exist_from_selects = true;
                                }


                                lo_result_curve = this.main.splines.draw_curve(lo_copy_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false);//13032025
                                lo_result_curve.name = lv_prev_segment_line_name;

                                lar_spline_points.push(...lar_segment_points);


                                //////if (lv_is_exist_from_selects) {
                                //////    // вставка сегмента в массив выделенных сегментов
                                //////    this.ar_selected_segments.push(lo_result_curve);
                                //////}




                                lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            }
                            else { // not is_after

                                // удаление предыдущей линии сегмента
                                lo_line = lo_curr_segment_group.children.find(obj => obj.type === "Line");
                                let lo_prev_segment_line_name = lo_line.name; //12032025

                                // Проверка, есть ли линия сегмента среди массива выделенных сегментов
                                let lv_is_exist_from_selects = false;
                                let lv_idx = this.ar_selected_segments.findIndex(obj => obj.name === lo_prev_segment_line_name);
                                if (lv_idx >= 0) {
                                    // удаление линии сегмента из массива выделенных сегментов
                                    this.ar_selected_segments.splice(lv_idx, 1);
                                    lv_is_exist_from_selects = true;
                                }


                                lo_curr_segment_group.remove(lo_line);
                                this.main.common_func.removeObjectsWithChildren(lo_line, true, false, false);//14032025


                                lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                                let lv_point = lar_segment_points[lar_segment_points.length - 1];
                                if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                                    // удаление точки с нулевыми координатами (от объекта Line)
                                    lar_segment_points.pop();
                                }

                                let lo_new_segment_line = this.main.splines.draw_curve(lo_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false); //12032025
                                lo_new_segment_line.name = lo_prev_segment_line_name;//12032025

                                lar_spline_points.push(...lar_segment_points);


                                if (lv_is_exist_from_selects) {

                                    // вставка сегмента в массив выделенных сегментов
                                    this.ar_selected_segments.push(lo_new_segment_line);
                                }

                                lo_copy_curr_segment_group = lo_curr_segment_group.clone();
                                lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            }


                        }// else группа НЕ выделенного сегмента

                        //lar_spline_points.push(...lo_segment_data.points);
                    } // lv_j


                    lo_main_curves_group.remove(lo_spline_group_with_sel_segment);//06032025

                    if (lar_spline_points.length > 0) {  //16032025 
                        this.main.splines.draw_curve(lo_new_spline_group_with_sel_segment, lar_spline_points, cv_spline_name_prefix, true);

                        // Вставляем сплайн-группу на своё место
                        //16032025 lo_main_curves_group.remove(lo_spline_group_with_sel_segment);//06032025
                        lo_main_curves_group.add(lo_new_spline_group_with_sel_segment);//06032025

                        // Постановка сплайн-группы на своё место
                        let lo_temp_spline_group = lo_main_curves_group.children.splice(lo_main_curves_group.children.length - 1, 1)[0]; // Удаляем элемент
                        lo_main_curves_group.children.splice(lv_index_spline_group, 0, lo_temp_spline_group); // Вставляем на новое место

                    } //16032025



                    // удаление групп с выделенными сегментами
                    for (let lo_obj_to_remove in lar_to_remove) {
                        this.main.common_func.removeObjectsWithChildren(lo_obj_to_remove, true, false, false);//14032025
                    }


                    this.ar_splines = this.get_splines();//06032025
                    this.ar_splines_nodes = this.get_splines_points();//06032025

                } // lv_i

                // Очистка массива выделенных сегментов
                this.ar_selected_segments = []; // 16032025

            }
            catch (e) {

                alert('error make_delete_selected_segments: ' + e.stack);

            }

            return;
        }


        //-----------------------------------------------------------------
        // Вставить сегменты перед выделенными
        Shapes.prototype.make_insert_segments_before_selected_segments = function () {

            let lo_line_selected_segment = null;
            let lo_beg_point_position = null;
            let lo_segment_beg_point = null;
            let lv_is_first_segment = false;
            let lv_is_last_segment = false;
            let lo_indexes_data = null; // индекс выделенного сегмента

            let lo_segment_data = null;
            ////////150320025 let lo_segment = null;
            ////////150320025 let lo_segment_group_of_sel_segment = null;

            let lar_spline_points = [];
            let lo_new_spline_group_with_sel_segment = null; // new THREE.Group();
            let lv_shift_y = 0;
            let lo_spline_group_with_sel_segment = null;
            let lar_segment_points = null;
            ////////150320025 let lo_next_segment_beg_point = null;

            let lo_copy_curr_segment_group = null;
            let lv_sel_index = -1;

            let lv_index_spline_group = 0;
            let lo_line = null;
            let lar_lines_names_selected_segments = [];

            //let lar_objects_for_delete = [];
            let lo_prev_segment_line = null;
            let lv_prev_segment_line_name = "";
            let lo_result_curve = null;//13032025

            try {

                this.ar_splines = this.get_splines();//11032025
                this.ar_splines_nodes = this.get_splines_points();//11032025



                // группа всех кривых
                let lo_main_curves_group = this.main.scene.getObjectByName(this.main_curves_group_prefix);
                if (!lo_main_curves_group) {
                    return;
                }


                // цикл по выделенным сегментам

                // Формирование массива имён линий выделенных сегментов
                for (let lo_segment_line of this.ar_selected_segments) {
                    lar_lines_names_selected_segments.push(lo_segment_line.name);
                }



                for (let lv_i = 0; lv_i < lar_lines_names_selected_segments.length; lv_i++) {

                    lo_line_selected_segment = this.main.common_func.get_object_by_name_via_search_area(this.main.scene, lar_lines_names_selected_segments[lv_i]); //14032025

                    if (!lo_line_selected_segment.parent) {
                        continue;
                    }
                    lo_spline_group_with_sel_segment = lo_line_selected_segment.parent.parent;// группа сплайна выделенного сегмента

                    //15032025 lo_segment_group_of_sel_segment = lo_line_selected_segment.parent;// группа выделенного сегмента

                    // Определение индекса сплайн-группы выделенного сегмента в массиве сплайнов
                    lv_index_spline_group = lo_main_curves_group.children.findIndex(obj => obj.name === lo_spline_group_with_sel_segment.name); //13032025




                    lo_new_spline_group_with_sel_segment = new THREE.Group();
                    lo_new_spline_group_with_sel_segment.name = lo_spline_group_with_sel_segment.name;


                    lo_indexes_data = this.get_spline_group_index_of_selected_segment(/*lar_selected_segments,*/ lo_line_selected_segment);
                    if (lo_indexes_data.segment_index < 0) {
                        return null;
                    }


                    let lar_segment_meshes = this.ar_splines[lo_indexes_data.ar_splines_index].children[lo_indexes_data.segment_index].children;

                    lo_beg_point_position = lar_segment_meshes[lar_segment_meshes.length - 2].position; // позиция последнего узла сегмента, перед которым 
                    // вставляется новый сегмент
                    lo_segment_beg_point = new THREE.Vector2(lo_beg_point_position.x, lo_beg_point_position.y);//02032025

                    if (lo_indexes_data.segment_index == 0) {
                        lv_is_first_segment = true;
                    }
                    else {
                        lv_is_first_segment = false;
                    }

                    if (lo_indexes_data.segment_index === lo_spline_group_with_sel_segment.children.length - 2) {
                        lv_is_last_segment = true;
                    }
                    else {
                        lv_is_last_segment = false;
                    }



                    let lv_is_after = false;

                    // цикл по группам сегментов,принадлежащих сплайну с выделенным сегментом
                    for (let lv_j = 0; lv_j < lo_spline_group_with_sel_segment.children.length; lv_j++) {

                        if (lo_spline_group_with_sel_segment.children[lv_j].type !== "Group") {
                            continue;
                        }

                        let lo_curr_segment_group = lo_spline_group_with_sel_segment.children[lv_j];


                        if (lo_curr_segment_group.name === lo_line_selected_segment.parent.name) { //13032025


                            // это группа выделенного сегмента


                            // перемещение выделенного сегмента в новую сплайн группу

                            lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                            let lv_point = lar_segment_points[lar_segment_points.length - 1];
                            if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                                // удаление точки с нулевыми координатами (от объекта Line)
                                lar_segment_points.pop();
                            }

                            lar_spline_points.push(...lar_segment_points);


                            lo_copy_curr_segment_group = lo_curr_segment_group.clone();


                            // удаление прежней линии сегмента
                            lo_prev_segment_line = lo_copy_curr_segment_group.children.find(obj => obj.type === "Line");
                            if (lo_prev_segment_line) {
                                lv_prev_segment_line_name = lo_prev_segment_line.name;
                            }

                            lo_copy_curr_segment_group.remove(lo_prev_segment_line);

                            this.main.common_func.removeObjectsWithChildren(lo_prev_segment_line, true, false, false);//14032025


                            // новая кривая сегмента
                            lo_result_curve = this.main.splines.draw_curve(lo_copy_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false);
                            lo_result_curve.name = lv_prev_segment_line_name; // присваиваем имя прежней кривой


                            lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            lv_sel_index = this.ar_selected_segments.findIndex(obj => obj.name === lo_line_selected_segment.name);
                            if (lv_sel_index !== -1) {
                                this.ar_selected_segments.splice(lv_sel_index, 1, lo_result_curve); // Вставка выделенного сегмента 
                            }                                                            // на место прежнего выделенного сегмента


                            // создание группы нового вставляемого сегмента
                            let lo_new_segment_group = new THREE.Group();
                            lo_new_segment_group.name = this.main.common_func.get_object_name(cv_segment_group_name_prefix, lo_new_segment_group);

                            lo_segment_data = this.main.segments.create_segment(
                                lo_new_segment_group, //lo_segment_group,
                                this.main.segment_transform_data,
                                lo_segment_beg_point,
                                lv_is_first_segment, // признак первого сегмента
                                lv_is_last_segment  // признак последнего сегмента
                            );

                            // сдвиг по y сегментов после вставки нового сегмента:
                            lv_shift_y = lo_segment_data.segment_beg_point.y - lo_segment_beg_point.y;


                            ////////150320025 lo_next_segment_beg_point = lo_segment_data.segment_beg_point;
                            this.main.splines.draw_curve(lo_new_segment_group, lo_segment_data.points, cv_segment_name_prefix, false);
                            lar_spline_points.push(...lo_segment_data.points);
                            lo_new_spline_group_with_sel_segment.add(lo_new_segment_group);


                            lv_is_after = true;
                        }
                        else {

                            //  группа не выделенного сегмента


                            if (lv_is_after) {

                                // коррекция y-координаты на длину вставляемого сегмента

                                let lo_current_point = null;
                                for (let lv_k = 0; lv_k < lo_curr_segment_group.children.length; lv_k++) {

                                    lo_current_point = lo_curr_segment_group.children[lv_k];

                                    if (lo_current_point.type == "Mesh") {

                                        lo_current_point.position.y = lo_current_point.position.y + lv_shift_y;//030032025
                                    }

                                }



                                lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                                let lv_point = lar_segment_points[lar_segment_points.length - 1];
                                if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                                    // удаление точки с нулевыми координатами (от объекта Line)
                                    lar_segment_points.pop();
                                }



                                lo_copy_curr_segment_group = lo_curr_segment_group.clone();



                                // удаление предыдущей линии
                                lo_prev_segment_line = lo_copy_curr_segment_group.children.find(obj => obj.type === "Line");
                                if (lo_prev_segment_line) {
                                    lv_prev_segment_line_name = lo_prev_segment_line.name;
                                }

                                lo_copy_curr_segment_group.remove(lo_prev_segment_line);
                                this.main.common_func.removeObjectsWithChildren(lo_prev_segment_line, true, false, false);//14032025


                                // Проверка, есть ли линия сегмента среди массива выделенных сегментов
                                let lv_is_exist_from_selects = false;
                                let lv_idx = this.ar_selected_segments.findIndex(obj => obj.name === lv_prev_segment_line_name);
                                if (lv_idx >= 0) {
                                    // удаление линии сегмента из массива выделенных сегментов
                                    this.ar_selected_segments.splice(lv_idx, 1);
                                    lv_is_exist_from_selects = true;
                                }


                                lo_result_curve = this.main.splines.draw_curve(lo_copy_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false);//13032025
                                lo_result_curve.name = lv_prev_segment_line_name;

                                lar_spline_points.push(...lar_segment_points);


                                if (lv_is_exist_from_selects) {
                                    // вставка сегмента в массив выделенных сегментов
                                    this.ar_selected_segments.push(lo_result_curve);
                                }

                                lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            }
                            else { // not is_after

                                // удаление предыдущей линии сегмента
                                lo_line = lo_curr_segment_group.children.find(obj => obj.type === "Line");
                                let lo_prev_segment_line_name = lo_line.name; //12032025

                                // Проверка, есть ли линия сегмента среди массива выделенных сегментов
                                let lv_is_exist_from_selects = false;
                                let lv_idx = this.ar_selected_segments.findIndex(obj => obj.name === lo_prev_segment_line_name);
                                if (lv_idx >= 0) {
                                    // удаление линии сегмента из массива выделенных сегментов
                                    this.ar_selected_segments.splice(lv_idx, 1);
                                    lv_is_exist_from_selects = true;
                                }




                                lo_curr_segment_group.remove(lo_line);
                                this.main.common_func.removeObjectsWithChildren(lo_line, true, false, false);//14032025


                                lar_segment_points = lo_curr_segment_group.children.map(mesh => mesh.position.clone());
                                let lv_point = lar_segment_points[lar_segment_points.length - 1];
                                if (lv_point.x == 0 && lv_point.y == 0 && lv_point.z == 0) {
                                    // удаление точки с нулевыми координатами (от объекта Line)
                                    lar_segment_points.pop();
                                }

                                let lo_new_segment_line = this.main.splines.draw_curve(lo_curr_segment_group, lar_segment_points, cv_segment_name_prefix, false); //12032025
                                lo_new_segment_line.name = lo_prev_segment_line_name;//12032025

                                lar_spline_points.push(...lar_segment_points);


                                if (lv_is_exist_from_selects) {

                                    // вставка сегмента в массив выделенных сегментов
                                    this.ar_selected_segments.push(lo_new_segment_line);
                                }

                                lo_copy_curr_segment_group = lo_curr_segment_group.clone();
                                lo_new_spline_group_with_sel_segment.add(lo_copy_curr_segment_group);

                            }


                        }// else группа НЕ выделенного сегмента





                        //lar_spline_points.push(...lo_segment_data.points);
                    } // lv_j


                    this.main.splines.draw_curve(lo_new_spline_group_with_sel_segment, lar_spline_points, cv_spline_name_prefix, true);

                    // Вставляем сплайн-группу на своё место
                    lo_main_curves_group.remove(lo_spline_group_with_sel_segment);//06032025
                    lo_main_curves_group.add(lo_new_spline_group_with_sel_segment);//06032025

                    // Постановка сплайн-группы на своё место
                    let lo_temp_spline_group = lo_main_curves_group.children.splice(lo_main_curves_group.children.length - 1, 1)[0]; // Удаляем элемент
                    lo_main_curves_group.children.splice(lv_index_spline_group, 0, lo_temp_spline_group); // Вставляем на новое место

                    this.ar_splines = this.get_splines();//06032025
                    this.ar_splines_nodes = this.get_splines_points();//06032025

                } // lv_i



            }
            catch (e) {

                alert('error make_insert_segments_before_selected_segments: ' + e.stack);

            }

            return;// lo_segment;
        }



        //-----------------------------------------------------------------
        Shapes.prototype.move_curve_along_x = function (po_moved_node, pv_delta_x) {

            try {


                let lo_spline_group = po_moved_node.parent.parent;

                let lar_spline_points = this.get_spline_points(lo_spline_group);

                // Сдвиг узлов по оси x
                for (let lv_i = 0; lv_i < lar_spline_points.length; lv_i++) {
                    lar_spline_points.x = lar_spline_points.x + pv_delta_x;
                }


                this.main.splines.draw_curve(lo_spline_group, lar_spline_points, cv_spline_name_prefix, true);


            }

            catch (e) {

                alert('error move_curve_along_x: ' + e.stack);

            }


        }


        //------------------------------------------------------------------------
        Shapes.prototype.redraw_segments = function (po_spline_group) {

            try {

                let lo_spline_group;

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    // Если po_spline_group не задан, перерисовываем все сплайны
                    if (po_spline_group) {
                        if (lo_spline_group != po_spline_group) {
                            continue;
                        }
                    }


                    let lar_segment_parents = [];

                    for (let lv_i = this.ar_selected_segments.length - 1; lv_i >= 0; lv_i--) {

                        if (this.ar_selected_segments[lv_i].parent) {

                            if (this.ar_selected_segments[lv_i].parent.parent) {

                                if (this.ar_selected_segments[lv_i].parent.parent.name == lo_spline_group.name) { //14032025

                                    let lv_exist = false;
                                    // Запоминание родительских групп удаляемых сегментов
                                    for (let lv_j = 0; lv_j < lar_segment_parents.length; lv_j++) {
                                        if (lar_segment_parents[lv_j].name === this.ar_selected_segments[lv_i].parent.name) { //14032025
                                            lv_exist = true;
                                            break;
                                        }
                                    }
                                    if (!lv_exist) {
                                        // если ещё нет в массиве - вставляем
                                        lar_segment_parents.push(this.ar_selected_segments[lv_i].parent);
                                    }

                                    this.ar_selected_segments.splice(lv_i, 1);
                                }

                            }
                            else // this.ar_selected_segments[lv_i].parent == null
                            {
                                this.main.common_func.removeObjectsWithChildren(this.ar_selected_segments[lv_i], true);
                                this.ar_selected_segments.splice(lv_i, 1);
                            }


                        }
                        else // this.ar_selected_segments[lv_i].parent == null
                        {
                            this.main.common_func.removeObjectsWithChildren(this.ar_selected_segments[lv_i], true);
                            this.ar_selected_segments.splice(lv_i, 1);
                        }

                    }


                    // список узлов сегментов сплайна
                    let lar_segment_points = this.get_segments_points(lo_spline_group);

                    for (let lv_j = 0; lv_j < lar_segment_points.length; lv_j++) {

                        // Удаление предыдущих линий
                        let lar_lines = this.main.shapes.get_lines_in_group(lar_segment_points[lv_j].parent);
                        for (let lv_k = 0; lv_k < lar_lines.length; lv_k++) {
                            this.main.common_func.removeObjectsWithChildren(lar_lines[lv_k], true);
                        }

                        // рисование новых линий
                        let lo_new_segment = this.main.splines.draw_curve(lar_segment_points[lv_j].parent, lar_segment_points[lv_j].points, cv_segment_name_prefix, false);//////////////

                        // Если родительская группа совпадает, вставка сегмента в список выделенных
                        for (let lv_k = 0; lv_k < lar_segment_parents.length; lv_k++) {
                            if (lar_segment_parents[lv_k].name == lar_segment_points[lv_j].parent.name) { //14032025
                                this.ar_selected_segments.push(lo_new_segment);
                            }

                        }

                    }

                    lar_segment_points = null;//30072024 leaks
                    lar_segment_parents = null;//30072024 leaks
                }

                lo_spline_group = null; //leaks

            }

            catch (e) {

                alert('error redraw_segments: ' + e.stack);

            }

        }

        //-----------------------------------------------------------------

        Shapes.prototype.set_shape_color = function (po_spline_left, po_spline_right, pv_color) {

            try {

                let lar_left_points = this.main.common_func.getLinePoints(po_spline_left);
                let lar_right_points = this.main.common_func.getLinePoints(po_spline_right);
                let lar_left_points_reversed = lar_left_points.reverse();



                let lo_shape = new THREE.Shape()
                    .splineThru(lar_right_points)
                    .splineThru(lar_left_points_reversed);

                ///////////////////////////////////////////////this.addShape(lo_shape, 0x0000ff);


                lo_shape = new THREE.Shape()
                    .moveTo(0, lar_left_points[0].y)
                    .splineThru(lar_left_points)
                    .lineTo(0, lar_left_points[lar_left_points.length - 1].y)
                    .lineTo(0, lar_left_points[0].y);

				//lo_shape.autoClose = true;


		        ///////////////////////////////////////////////////////////this.addShape(lo_shape, pv_color);

				//==================================================================================
				// Line2 ( LineGeometry, LineMaterial )


				////////const positions = [];
				////////const colors = [];

				////////const points = GeometryUtils.hilbert3D(new THREE.Vector3(0, 0, 0), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7);

				////////const spline = new THREE.CatmullRomCurve3(points);
				////////const divisions = Math.round(12 * points.length);
				////////const point = new THREE.Vector3();
				////////const color = new THREE.Color();

				////////for (let i = 0, l = divisions; i < l; i++) {

				////////	const t = i / l;

				////////	spline.getPoint(t, point);
				////////	positions.push(point.x, point.y, point.z);

				////////	color.setHSL(t, 1.0, 0.5, THREE.SRGBColorSpace);
				////////	colors.push(color.r, color.g, color.b);


				////////}




				////////const geometry2 = new LineGeometry();
				////////geometry2.setPositions(lar_right_points);
				////////geometry2.setColors(colors);

				////////let matLine2 = new LineMaterial({

				////////	color: 0xffffff,
				////////	linewidth: 15, // in world units with size attenuation, pixels otherwise
				////////	vertexColors: true,

				////////	//resolution:  // to be set by renderer, eventually
				////////	dashed: false,
				////////	alphaToCoverage: false //true,


				////////});

				////////let line2 = new Line2(geometry2, matLine2);
				////////line2.computeLineDistances();
				////////line2.scale.set(1, 1, 1);
				////////line2.visible = true;
				////////this.scene.add(line2);

				////////matLine2.resolution.set(window.innerHeight, window.innerHeight); // resolution of the inset viewport





				//////let cv_rect_height = 100;
				//////let cv_rect_width = 100;











				////////////////////let positions = [];

				//////////////////////////positions.push(0, 0, 0);
				//////////////////////////positions.push(0, cv_rect_height, 0);
				//////////////////////////positions.push(cv_rect_width, cv_rect_height, 0);
				//////////////////////////positions.push(cv_rect_width, 0, 0);
				//////////////////////////positions.push(0, 0, 0);

				//////////////////////positions = lar_right_points;

				//////////////////////positions.push(0, 0);
				//////////////////////positions.push(0, cv_rect_height);
				//////////////////////positions.push(cv_rect_width, cv_rect_height);
				//////////////////////positions.push(cv_rect_width, 0);
				//////////////////////positions.push(0, 0);

				////////////////////for (let lv_ii = 0; lv_ii < lar_right_points.length; lv_ii++) {
				////////////////////	positions.push(lar_right_points[lv_ii].x, lar_right_points[lv_ii].y, 0);
				////////////////////}



				//////////////////////let lv_color = 0x0040f0;
				//////////////////////let lv_color = 0x00ff00;

				//////////////////////let lv_x = 0; 


				//////////////////////let lv_y = 0;

				////////////////////const clrs = [];

				////////////////////positions.forEach(() => {
				////////////////////	clrs.push(0, 0, 255);//!! цвет линии
				////////////////////});


				////////////////////let geometry = new LineGeometry();

				////////////////////geometry.setPositions(positions);/////

				////////////////////geometry.setColors(clrs);

				////////////////////let resolution = new THREE.Vector2();

				////////////////////let renderer = new THREE.WebGLRenderer({  });
				////////////////////renderer.getSize(resolution);

				////////////////////let material = new LineMaterial({
				////////////////////	//color: new Color("#fff").getHex(),
				////////////////////	vertexColors: 0x00f, //VertexColors,
				////////////////////	linewidth: 0.8, //0.5, //1, //2,
				////////////////////	resolution
				////////////////////});

				//////////////////////material.needsUpdate = true;

				////////////////////let lo_line = new Line2(geometry, material);
				//////////////////////lo_line.computeLineDistances();

				//////////////////////lo_line.position.set(lv_x, lv_y);

				////////////////////this.scene.add(lo_line);








				//==================================================================================


				////let triangleShape = new THREE.Shape()
				////	.moveTo(80, 20)
				////	.lineTo(40, 80)
				////	.lineTo(120, 80)
				////	.lineTo(80, 20); // close path


				////// flat shape

				////geometry = new THREE.ShapeGeometry(shape);

				////mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide }));
				////mesh.position.set(x, y, z - 125);
				////mesh.rotation.set(rx, ry, rz);
				////mesh.scale.set(s, s, s);
				////group.add(mesh);


				////const x = 0, y = 0;

				////const heartShape = new THREE.Shape()
				////	.moveTo(x + 25, y + 25)
				////	.bezierCurveTo(x + 25, y + 25, x + 20, y, x, y)
				////	.bezierCurveTo(x - 30, y, x - 30, y + 35, x - 30, y + 35)
				////	.bezierCurveTo(x - 30, y + 55, x - 10, y + 77, x + 25, y + 95)
				////	.bezierCurveTo(x + 60, y + 77, x + 80, y + 55, x + 80, y + 35)
				////	.bezierCurveTo(x + 80, y + 35, x + 80, y, x + 50, y)
				////	.bezierCurveTo(x + 35, y, x + 25, y + 25, x + 25, y + 25);





				////const californiaPts = [];

				////californiaPts.push(new THREE.Vector2(610, 320));
				////californiaPts.push(new THREE.Vector2(450, 300));
				////californiaPts.push(new THREE.Vector2(392, 392));
				////californiaPts.push(new THREE.Vector2(266, 438));
				////californiaPts.push(new THREE.Vector2(190, 570));
				////californiaPts.push(new THREE.Vector2(190, 600));
				////californiaPts.push(new THREE.Vector2(160, 620));
				////californiaPts.push(new THREE.Vector2(160, 650));
				////californiaPts.push(new THREE.Vector2(180, 640));
				////californiaPts.push(new THREE.Vector2(165, 680));
				////californiaPts.push(new THREE.Vector2(150, 670));
				////californiaPts.push(new THREE.Vector2(90, 737));
				////californiaPts.push(new THREE.Vector2(80, 795));
				////californiaPts.push(new THREE.Vector2(50, 835));
				////californiaPts.push(new THREE.Vector2(64, 870));
				////californiaPts.push(new THREE.Vector2(60, 945));
				////californiaPts.push(new THREE.Vector2(300, 945));
				////californiaPts.push(new THREE.Vector2(300, 743));
				////californiaPts.push(new THREE.Vector2(600, 473));
				////californiaPts.push(new THREE.Vector2(626, 425));
				////californiaPts.push(new THREE.Vector2(600, 370));
				////californiaPts.push(new THREE.Vector2(610, 320));

				////for (let i = 0; i < californiaPts.length; i++) californiaPts[i].multiplyScalar(0.25);

				////const californiaShape = new THREE.Shape(californiaPts);




				////// Circle

				////const circleRadius = 40;
				////const circleShape = new THREE.Shape()
				////	.moveTo(0, circleRadius)
				////	.quadraticCurveTo(circleRadius, circleRadius, circleRadius, 0)
				////	.quadraticCurveTo(circleRadius, - circleRadius, 0, - circleRadius)
				////	.quadraticCurveTo(- circleRadius, - circleRadius, - circleRadius, 0)
				////	.quadraticCurveTo(- circleRadius, circleRadius, 0, circleRadius);



				////// Spline shape

				////const splinepts = [];
				////splinepts.push(new THREE.Vector2(70, 20));
				////splinepts.push(new THREE.Vector2(80, 90));
				////splinepts.push(new THREE.Vector2(- 30, 70));
				////splinepts.push(new THREE.Vector2(0, 0));

				////const splineShape = new THREE.Shape()
				////	.moveTo(0, 0)
				////	.splineThru(splinepts);





//===========================================================================================================
//===========================================================================================================


				/*let*/ lar_left_points = this.main.common_func.getLinePoints(po_spline_left);
				/*let*/ lar_right_points = this.main.common_func.getLinePoints(po_spline_right);
				/*let*/ lar_left_points_reversed = lar_left_points.reverse();
                let lar_right_points_reversed = lar_right_points.reverse();

                try {


                    ////let lo_resolution = new THREE.Vector2();
                    ////let lo_renderer = new THREE.WebGLRenderer({ antialias: true });
                    ////lo_renderer.getSize(lo_resolution);

                    let material = new LineMaterial({
                        //color: new Color("#fff").getHex(),
                        vertexColors: 0x00f, //VertexColors,
                        linewidth: 7, //30012025  1, //0.5, //1, //2,
                        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // Обязательно 30012025 lo_resolution,
                    });



                    let lar_positions = [];



                    for (let lv_i = 0; lv_i < lar_left_points.length; lv_i++) {
                        lar_positions.push(lar_left_points[lv_i].x, lar_left_points[lv_i].y, 0);
                    }

                    for (let lv_i = 0; lv_i < lar_right_points_reversed.length; lv_i++) {
                        lar_positions.push(lar_right_points_reversed[lv_i].x, lar_right_points_reversed[lv_i].y, 0);
                    }

                    const clrs = [];

                    lar_positions.forEach(() => {
                        clrs.push(255, 0, 255);//!! цвет линии
                    });


                    ////////let lo_geometry = new LineGeometry();

                    ////////lo_geometry.setPositions(lar_positions);/////

                    ////////lo_geometry.setColors(clrs);

                    ////////let lo_resolution = new THREE.Vector2();

                    ////////let lo_renderer = new THREE.WebGLRenderer({});
                    ////////lo_renderer.getSize(lo_resolution);

                    ////////let lo_material = new LineMaterial({
                    ////////	//color: new Color("#fff").getHex(),
                    ////////	vertexColors: 0x00f, //VertexColors,
                    ////////	linewidth: 0.1, //0.5, //1, //2,
                    ////////	lo_resolution
                    ////////});

                    //////////material.needsUpdate = true;

                    ////////let lo_line = new Line2(lo_geometry, lo_material);
                    //////////lo_line.computeLineDistances();

                    //////////lo_line.position.set(lv_x, lv_y);

                    ////////this.scene.add(lo_line);



                    let geometry = new LineGeometry();

                    //geometry.setPositions(positions);/////
                    geometry.setPositions(lar_positions);/////

                    geometry.setColors(clrs);

                    ////let resolution = new THREE.Vector2();
                    ////let lo_renderer = new THREE.WebGLRenderer({});
                    ////lo_renderer.getSize(resolution);

                    ////let material = new LineMaterial({
                    ////	//color: new Color("#fff").getHex(),
                    ////	vertexColors: 0x00f, //VertexColors,
                    ////	linewidth: 1, //0.5, //1, //2,
                    ////	resolution
                    ////});

                    //material.needsUpdate = true;

                    let lo_line = new Line2(geometry, material);
                    //lo_line.computeLineDistances();

                    //lo_line.position.set(lv_x, lv_y);

                    this.scene.add(lo_line);
                    //this.plane.add(lo_line);//31012025






                }

                catch (e) {

                    alert('error draw_contour_and_shape: ' + e.stack);

                }


            }

            catch (e) {

                alert('error set_shape_color: ' + e.stack);

            }
        }

        //-----------------------------------------------------------------

        Shapes.prototype.select_shape_contour = function (po_clicked_splines/*, pv_is_shape_gragging*/) {

            //let pv_draw_contour = !pv_is_shape_gragging;

            this.draw_contour_and_shape(0x0f0, po_clicked_splines.spline_left, po_clicked_splines.spline_right, true, true, true, false);
            //this.draw_contour_and_shape(0x0f0, po_clicked_splines.spline_left, po_clicked_splines.spline_right, true, true, pv_draw_contour, false); //10032025

            ////this.main.camera.updateProjectionMatrix();
            ////this.main.render();

        }



        //------------------------------------------------------------------------
        Shapes.prototype.set_spline_points = function (po_spline_group, par_points) {

            try {

                let lo_spline_group;
                let lv_ipoint = 0;

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    if (lo_spline_group != po_spline_group) {

                        continue;
                    }


                    for (let lv_j = 0; lv_j < lo_spline_group.children.length; lv_j++) {

                        let lo_segment_group = lo_spline_group.children[lv_j];

                        if (lo_segment_group instanceof THREE.Group) {

                            for (let lv_k = 0; lv_k < lo_segment_group.children.length; lv_k++) {

                                if (lo_segment_group.children[lv_k] instanceof THREE.Mesh) {

                                    lo_segment_group.children[lv_k].position.x = par_points[lv_ipoint].x;
                                    lo_segment_group.children[lv_k].position.y = par_points[lv_ipoint].y;
                                    lv_ipoint++;
                                }

                            }
                        }

                    }

                }

            }

            catch (e) {

                alert('error get_spline_points: ' + e.stack);

            }

            return par_points;

        }

        //-----------------------------------------------------------------

        Shapes.prototype.set_visible_nodes = function (pv_visible) {

            try {

                let lo_spline_group;

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lo_spline_group = this.ar_splines[lv_i];

                    for (let lv_j = 0; lv_j < lo_spline_group.children.length; lv_j++) {

                        let lo_segment_group = lo_spline_group.children[lv_j];

                        if (lo_segment_group instanceof THREE.Group) {

                            for (let lv_k = 0; lv_k < lo_segment_group.children.length; lv_k++) {

                                if (lo_segment_group.children[lv_k] instanceof THREE.Mesh) {

                                    lo_segment_group.children[lv_k].visible = pv_visible;

                                }

                            }
                        }

                    }

                }

            }

            catch (e) {

                alert('error set_visible_nodes: ' + e.stack);

            }

        }




        //29062024 {
        //////////-----------------------------------------------------------------

        ////////Shapes.prototype.switch_visible_nodes_by_spline = function (po_spline) {

        ////////	//return;

        ////////	try {

        ////////		let lo_segment_group;

        ////////		for (let lv_i = 0; lv_i < po_spline.parent.children.length - 1; lv_i++) {
        ////////			lo_segment_group = po_spline.parent.children[lv_i];

        ////////			for (let lv_j = 0; lv_j < lo_segment_group.children.length - 1; lv_j++) {

        ////////				let lo_segment_point = lo_segment_group.children[lv_j];

        ////////				if (lo_segment_point instanceof THREE.Mesh) {

        ////////					////if (lo_obj.userData) {

        ////////					////	if (lo_obj.userData.nspline == po_spline) {

        ////////					lo_segment_point.visible = !lo_segment_point.visible;

        ////////					////	}

        ////////					////}
        ////////				}


        ////////			}

        ////////		}

        ////////	}

        ////////	catch (e) {

        ////////		alert('error switch_visible_nodes_by_spline: ' + e);

        ////////	}

        ////////}
        //29062024 }



        //13122024 {
        ////////////-----------------------------------------------------------------

        //////////Shapes.prototype.GetTwoShapeIntersect = function (object1, object2) {
        //////////    // (example from https://stackoverflow.com/questions/49417007/how-to-find-intersection-of-objects-in-three-js)
        //////////    /**
        //////////     * This function check if two object3d intersect or not
        //////////     * @param {THREE.Object3D} object1
        //////////     * @param {THREE.Object3D} object2
        //////////     * @returns {Boolean}
        //////////    */

        //////////    let lv_result = null;


        //////////    try {

        //////////        // Check for intersection using bounding box intersection test
        //////////        let bBox1 = new THREE.Box3().setFromObject(object1);
        //////////        bBox1.max.z = 0;
        //////////        bBox1.min.z = 0;

        //////////        object2.geometry.computeBoundingBox();

        //////////        let bBox2 = new THREE.Box3().setFromObject(object2);
        //////////        bBox2.max.z = 0;
        //////////        bBox2.min.z = 0;

        //////////        const intersection = bBox1.intersectsBox(bBox2);
        //////////        // const intersection = mesh1.geometry.boundingBox.intersectsBox(mesh2.geometry.boundingBox);

        //////////        if (intersection) { // The shape geometries intersect.

        //////////            //let lv_nspline = this.get_nspline_by_name(object2.name);

        //////////            lv_result = {
        //////////                min_x: bBox2.min.x,
        //////////                min_y: bBox2.min.y,
        //////////                max_x: bBox2.max.x,
        //////////                max_y: bBox2.max.y,
        //////////                object: object2
        //////////                //nspline: lv_nspline
        //////////            };
        //////////        }
        //////////        //else
        //////////        //{ // The shape geometries do not intersect.
        //////////        //	return false
        //////////        //}



        //////////    }

        //////////    catch (e) {

        //////////        alert('error GetTwoShapeIntersect: ' + e.stack);

        //////////    }



        //////////    return lv_result;

        //////////}
        //13122024 }


        //-----------------------------------------------------------------------------------
        // Упорядочивание групп сплайнов слева направо
        Shapes.prototype.SortGroupsSplinesFromLeftToRight = function () {


            //let lar_sorted = [];

            let lar_result = [];

            try {


                //let boundingBox;
                let lar_for_sort = [];

                //let lo_sort_obj = {}

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    //////boundingBox = new THREE.Box3().setFromObject(this.ar_splines[lv_i]);

                    //////// сплайн - последний дочерний член группы this.ar_splines[lv_i]
                    //////let lv_index = this.ar_splines[lv_i].children.length - 1;

                    //////let lo_spline = this.ar_splines[lv_i].children[lv_index];

                    //let lv_index = this.ar_splines[lv_i].children[0].children.length - 1;
                    let lv_x = this.ar_splines[lv_i].children[0].children[0].position.x;


                    lar_for_sort.push({ x: lv_x, spline: this.ar_splines[lv_i] });

                }

                //lar_sorted = this.main.common_func.sortByProperty(lar_for_sort, "x");

                lar_for_sort.sort((a, b) => a.x - b.x); // По возрастанию

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    lar_result.push(this.ar_splines[lv_i]);
                }
            }

            catch (e) {
                alert('error SortSplinesOrderFromLeftToRight: ' + e.stack);
            }

            return lar_result; // lar_sorted;


        }

        //-----------------------------------------------------------------------------------
        // Упорядочивание сплайнов слева направо
        Shapes.prototype.SortSplinesOrderFromLeftToRight = function () {

            let lar_sorted = [];

            try {
                let boundingBox;
                let lar_for_sort = [];

                //let lo_sort_obj = {}

                for (let lv_i = 0; lv_i < this.ar_splines.length; lv_i++) {

                    boundingBox = new THREE.Box3().setFromObject(this.ar_splines[lv_i]);

                    // сплайн - последний дочерний член группы this.ar_splines[lv_i]
                    let lv_index = this.ar_splines[lv_i].children.length - 1;

                    let lo_spline = this.ar_splines[lv_i].children[lv_index];


                    lar_for_sort.push({ x: boundingBox.min.x, spline: lo_spline });

                }

                lar_sorted = this.main.common_func.sortByProperty(lar_for_sort, "x");
            }

            catch (e) {
                alert('error SortSplinesOrderFromLeftToRight: ' + e.stack);
            }

            return lar_sorted;
        }
        //-----------------------------------------------------------------------------------



        //------------------------------------------------------------------------

        Shapes.prototype.switch_visible_nodes_by_segment = function (po_segment) {

            try {

                let lo_segment_point;

                for (let lv_i = 0; lv_i < po_segment.parent.children.length - 1; lv_i++) {

                    lo_segment_point = po_segment.parent.children[lv_i];

                    //for (let lv_j = 0; lv_j < lo_segment.children.length - 1; lv_j++) {

                    //let lo_segment_point = lo_segment.children[lv_j];

                    if (lo_segment_point instanceof THREE.Mesh) {

                        ////if (lo_obj.userData) {

                        ////	if (lo_obj.userData.nspline == po_spline) {

                        lo_segment_point.visible = !lo_segment_point.visible;

                        // Занесение в или удаление из массива выделенных сегментов

                        if (lv_i == 0) // выполняем только один раз 
                        {

                            if (lo_segment_point.visible) {
                                this.ar_selected_segments.push(po_segment);

                                //05032025 оставляем только уникальные значения
                                this.ar_selected_segments = [...new Set(this.ar_selected_segments)];

                            }
                            else {
                                // удаление элемента из массива
                                this.delete_from_selected_segments(po_segment);

                            }




                        }


                        ////	}

                        ////}
                    }


                    //}

                }

            }

            catch (e) {

                alert('error switch_visible_nodes_by_segment: ' + e.stack);

            }

        }




        //====================================================================
    }  // if (typeof this.redraw_shapes !== "function")

    //====================================================================


}

// end Class Shapes
//=====================================================================


var go_this = null;

//================================================================================
// Class ProgressDialog

export function ProgressDialog(pv_url, pv_read_method/*, pv_read_result_refresh_model*/) {

    this.url = pv_url;
    this.read_method = pv_read_method;
    //this.method_read_result_refresh_model = pv_read_result_refresh_model;


    this.progress_value = 0; // bvi

    this.progressTimer = null;
    this.progressbar = document.getElementById("id_progressbar"); // $("#id_progressbar");
    this.progressLabel = $(".progress-label");


    this.dialogButtons = null;
    this.dialog = null;
    this.downloadButton = null;
    //this.progressbar = null;

    this.monitoring_server_timer = null;


    //=====================================================================

    if (typeof this.init_progress_dialog != "function") {


        //-----------------------------------------------------------------------------------

        ProgressDialog.prototype.init_progress_dialog = function () {

            try {

                //14112024 go_this = this;


                this.dialogButtons = [{
                    text: "Cancel Download",
                    click: go_this.closeDownload
                }];

                this.dialog = $("#id_progress_dialog").dialog({
                    autoOpen: false,
                    closeOnEscape: false,
                    resizable: false,
                    buttons: go_this.dialogButtons,
                    open: function () {
                        //go_this.progressTimer = setTimeout(go_this.progress, 2000);
                        go_this.progressTimer = setTimeout(go_this.do_progress, 100);

                        go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 1);//bvi

                    },
                    beforeClose: function () {
                        go_this.downloadButton.button("option", {
                            disabled: false,
                            label: "Start Download"
                        });
                    }
                });

                this.downloadButton = $("#id_downloadButton")
                    .button()
                    .on("click", function () {

                        try {
                            $(this).button("option", {
                                disabled: true,
                                label: "Downloading..."
                            });
                            go_this.dialog.dialog("open");

                        }

                        catch (e) {

                            alert('error on_click_downloadButton: ' + e.stack);

                        }

                    });


                this.progressbar.progressbar({
                    value: false,
                    change: function () {
                        let lv_value_progressbar = go_this.get_progress_value(); // go_this.progressbar.progressbar("value");


                        //bvi go_this.progressLabel.text("Current Progress: " + go_this.progressbar.progressbar("value") + "%");
                        go_this.progressLabel.text("Current Progress: " + lv_value_progressbar + "%"); //bvi
                        //14112024 go_this.progressbar.progressbar("value", lv_value_progressbar);// bvi
                        go_this.progressbar.value = lv_value_progressbar;// 14112024 bvi

                    },
                    complete: function () {
                        go_this.progressLabel.text("Complete!");
                        go_this.dialog.dialog("option", "buttons", [{
                            text: "Close",
                            click: go_this.closeDownload
                        }]);
                        $(".ui-dialog button").last().trigger("focus");
                        setTimeout(go_this.dialog.dialog("close"), 2000);//bvi
                    }
                });


            }

            catch (e) {

                alert('error init_progress_dialog: ' + e.stack);

            }

        }
        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.do_progress = function () {

            try {
                //bvi var val = go_this.progressbar.progressbar("value") || 0;

                var lv_progress_value = go_this.get_progress_value();// bvi

                //go_this.progressbar.progressbar("value", val + Math.floor(Math.random() * 3));
                //14112024 go_this.progressbar.progressbar("value", lv_progress_value);
                go_this.progressbar.value = lv_progress_value;//14112024


                let lv_str1 = lv_progress_value.toString();
                let lv_str2 = (100 - lv_progress_value).toString();


                //let lo_table = "<table width=100%><tr><td>{2}%</td></tr>" +
                //    "<tr><td bgcolor=blue width='{0}%'>&nbsp;</td>" +
                //    "<td width='{1}%'></td></tr></table>";
                //let lo_table_str = "<table width=100%><tr><td>" + lv_str1 + "%</td></tr>" +
                //    "<tr><td bgcolor=blue width='" + lv_str1 + "%'>&nbsp;</td>" +
                //    "<td width='" + lv_str2 + "%'></td></tr></table>";




                //lo_table = String.format(lo_table, lv_progress_value, 100 - lv_progress_value, lv_progress_value);
                //$get("id_span_progress_").innerHTML = lo_table_str;
               /* $("#id_span_progress").innerHTML = lo_table_str;*/

                if (lv_progress_value >= 100) {

                    go_this.clear_timers();
                    //setTimeout(go_this.dialog.dialog("close"), 2000);//bvi

                }
                else {
                //bvi if (lv_progress_value <= 99) {
                    //bvi go_this.progressTimer = setTimeout(go_this.do_progress, 50);

                    if (lv_progress_value < 50) {
                        go_this.progressTimer = setTimeout(go_this.monitoring_server_progress, 250); //bvi
                    }
                    else {

                        //go_this.progressTimer = setTimeout(go_this.do_progress, 250);
                        go_this.clear_timers();
                    }
                }

            }

            catch (e) {

                alert('error progress: ' + e.stack);

            }
        }

        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.monitoring_server_progress = function () {

            try {

                let lv_url = go_this.url + "?method=" + go_this.read_method;

                get_monitoring_server_progress(lv_url);
                //--------------------------------------------------
                async function get_monitoring_server_progress(pv_url) { //, pf_callback) {

                    try {
                        await $.get(pv_url, "", go_this.oncomplete_monitoring_server_progress);
                    }

                    catch (e) {

                        alert('error get_monitoring_server_progress: ' + e.stack);

                    }

                }

            }

            catch (e) {

                alert('error monitoring_server_progress: ' + e.stack);

            }
        }

        //////-----------------------------------------------------------------------------------
        ////ProgressDialog.prototype.oncomplete_monitoring_server_progress = function (pv_progress_value) {




        ////    go_this.set_progress_value(pv_progress_value);


        ////    go_this.progress_value = pv_progress_value;
        ////    //14112024 go_this.progressbar.progressbar("value", go_this.progress_value);
        ////    go_this.progressbar.value = pv_progress_value;//14112024

        ////    go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%");

        ////    if (pv_progress_value < 50) {

        ////        //go_this.progress_value = pv_progress_value;
        ////        //go_this.progressbar.progressbar("value", go_this.progress_value);
        ////        //go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%");


        ////        go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 250);
        ////    }
        ////    else {

        ////        clearTimeout(go_this.monitoring_server_timer);// bvi

        ////        //let ls_progress_data = JSON.parse(po_data);

        ////        go_this.read_method_result_refresh_model();



        ////        ////go_this.monitoring_server_timer = setTimeout(go_this.do_progress, 250);
        ////    }
        ////}

        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.set_display_value = function (pv_progress_value) {

            go_this.progress_value = pv_progress_value;
            //14112024 go_this.progressbar.progressbar("value", go_this.progress_value);
            go_this.progressbar.value = pv_progress_value;//14112024

            pv_progress_value


            go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%"); 
        }

        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.set_progress_value = function (pv_progress_value) {

            this.progress_value = pv_progress_value;
        }
        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.get_progress_value = function () {

            return this.progress_value;
        }
        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.clear_timers = function () {

            clearTimeout(go_this.progressTimer);
            clearTimeout(go_this.monitoring_server_timer);// bvi
        }

        //-----------------------------------------------------------------------------------
        ProgressDialog.prototype.closeDownload = function () {


            try {
                //function closeDownload() {
                ////clearTimeout(go_this.progressTimer);
                ////clearTimeout(go_this.monitoring_server_timer);// bvi
                go_this.clear_timers(); //bvi

                go_this.dialog
                    .dialog("option", "buttons", go_this.dialogButtons)
                    .dialog("close");
                //14112024 go_this.progressbar.progressbar("value", false);
                go_this.progressbar.value = false;//14112024


                go_this.progressLabel
                    .text("Starting download...");
                go_this.downloadButton.trigger("focus");
            }



            catch (e) {

                alert('error closeDownload: ' + e.stack);

            }

            //====================================================================
        }  // if (typeof this.redraw_shapes !== "function")


        //14112024 ///////////////////////       this.init_progress_dialog();

        go_this = this; //14112024



        //====================================================================
    }

    // end Class Shapes
    //=====================================================================

}

// https://github.com/eligrey/FileSaver.js/blob/master/FileSaver.js

/* FileSaver.js
* A saveAs() FileSaver implementation.
* 2015-05-07.2
*
* By Eli Grey, http://eligrey.com
* License: X11/MIT
*   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
*/

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function (view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		doc = view.document
		// only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function () {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function (node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function () {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function (file) {
			var revoker = function () {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function (blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], { type: blob.type });
			}
			return blob;
		}
		, FileSaver = function (blob, name) {
			blob = auto_bom(blob);
			// First try a.download, then web filesystem, then object URLs
			var
				filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function () {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function () {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function (func) {
					return function () {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = { create: true, exclusive: false }
				, slice
				;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
					var save = function () {
						dir.getFile(name, create_if_not_found, abortable(function (file) {
							file.createWriter(abortable(function (writer) {
								writer.onwriteend = function (event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function () {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function (event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function () {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, { create: false }, abortable(function (file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function (ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function (blob, name) {
			return new FileSaver(blob, name);
		}
		;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function (blob, name) {
			return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
		};
	}

	FS_proto.abort = function () {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
		FS_proto.onwritestart =
		FS_proto.onprogress =
		FS_proto.onwrite =
		FS_proto.onabort =
		FS_proto.onerror =
		FS_proto.onwriteend =
		null;

	return saveAs;
}(
	typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
	module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
	define([], function () {
		return saveAs;
	});
}

//import * as THREE from 'three';
//import { Line2 } from 'three/addons/lines/Line2.js';
//import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineGeometry } from 'three/addons/lines/LineGeometry.js';



import { Constants } from './my_common_const.js';
//import {
//    struc_gabarits,
//    struc_segment_transform_data,
//    cv_spline_name_prefix,
//    cv_segment_name_prefix,

//    typ_color_data,
//    typ_side_data,
//    typ_mesh_colors,
//    type_rotate_mode,
//    typ_sides_data,
//    typ_parameters

//} from "./my_common_types.js";

import { CommonFunc } from './my_common_func.js';

import {
    //get_active_side_shape_generator,
    //get_passive_side_shape_generator,

    //gc_id_prefix_up,
    //gc_id_prefix_lateral,
    //gc_id_prefix_end,

    //go_up_side_shape_generator,
    //go_lateral_side_shape_generator,
    //go_end_side_shape_generator,

    go_tab_orders

} from './my_shape_generator.js';

//==========================================================================================
// Class Tab_orders
export function Tab_orders(/*po_container, po_camera,po_scene,*/
    /*po_params*/ /*pv_shape_width, pv_shape_height*/
) {

    // Свойства
    ////0511204 this.container = po_container;
    ////0511204 this.camera = po_camera;
    //this.scene = po_scene;

    //////this.shape_width = po_params.shape_width;
    //////this.shape_height = po_params.shape_height;
    //this.shape_width = pv_shape_width;
    //this.shape_height = pv_shape_height;

    //this.shape;

    //this.group_rect = null;

    //this.cv_rectangle_name = "my_rectangle";


    this.model_prefix_filename = null; // префикс имени файла модели
    //=====================================================================

    if (typeof this.init_tab_orders != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------



        //////Rectangle.prototype.create_rectangle = function () {


        //////	try {


        //////	}

        //////	catch (e) {

        //////		alert('error create_rectangle: ' + e.stack);

        //////	}


        //////}


        //------------------------------------------------------------------------
        Tab_orders.prototype.init_tab_orders = function (/*pv_distance_bt_curves*//*pv_shape_width, pv_shape_height*/) {


            try {

                $("#id_but_model_download").on("click", this.onclick_but_model_download);
                $("#id_but_go_to_amazon").on("click", this.onclick_but_go_to_amazon);

            }

            catch (e) {

                alert('error init_tab_orders: ' + e.stack);

            }

        }

        //-----------------------------------------------------------------

        Tab_orders.prototype.onclick_but_model_download = function (po_event) {


            try {

                $("#id_order_loading_indicator").show(); // показываем индикатор загрузки

                let lv_filename_zip = $("#id_model_name").val();//19012025  + Constants.file_model_zip;//   "test_file.zip"; // это имя файла надо считывать или hash-имя файла

                let lv_url = "/Index?handler=" + Constants.method_read_model_parts_zip_file
                    + "&"
                    + "filename" + "=" + lv_filename_zip
                    + "&" + Constants.is_make_order + "=true"
                    + "&chdata=" + Math.random().toString(); 

                let lv_is_download_to_downloads_folder = true;// сохранение в папку "Загрузки"
                let lv_downloaded_filename = lv_filename_zip + "_" + Constants.downloaded_filename; // "_jb_puzzle_parts.zip"; 
                let lv_is_save_to_server = false;// сохранение файла на сервер
                CommonFunc.prototype.read_file_from_server(lv_url, lv_is_download_to_downloads_folder, lv_downloaded_filename, lv_is_save_to_server);

            }

            catch (e) {

                $("#id_order_loading_indicator").hide(); // скрывакм индикатор загрузки

                //alert('error onclick_but_model_download: ' + e.stack);
                CommonFunc.prototype.Show_message("Error while downloading model!", 2000);

            }
        }


        //-----------------------------------------------------------------

        Tab_orders.prototype.onclick_but_go_to_amazon = function (po_event) {


            try {

                let lv_url = "https://www.amazon.com/s?k=loose+leaf+tea%2C+not+bagged&i=grocery&crid=1YUTWIU5EM8LJ&sprefix=loose+leaf+tea%2C+not+bagged%2Cgrocery%2C144&ref=nb_sb_noss";
                let lo_new_window = window.open(lv_url, "_blank");

                //window.open();

            }

            catch (e) {

                alert('error onclick_but_go_to_amazon: ' + e.stack);

            }
        }

        //====================================================================
    }  // if (typeof this.create_rectangle !== "function")

    //====================================================================



    this.init_tab_orders();


}

// end Class Tab_orders
//=====================================================================
import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"

import { Line2 } from 'three/addons/lines/Line2.js';
//import { Line2 } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/Line2.js';


import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineMaterial } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineMaterial.js';



import { Text } from 'troika-three-text';//06022025


import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

//import { Font } from 'three/addons/loaders/FontLoader.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';




import { Constants } from './my_common_const.js';
import { CommonFunc } from './my_common_func.js';

import {
    gc_id_prefix_up,
    gc_id_prefix_lateral,
    gc_id_prefix_end,

    go_up_side_shape_generator,
    go_lateral_side_shape_generator,
    go_end_side_shape_generator,

    get_active_side_shape_generator

} from './my_shape_generator.js';


import {
    typ_color_part
} from "./my_common_types.js";

//========================================================================================
const cv_rectangle_name = "my_end_shape";


// Class Rectangle
export function EndShape(po_main) { //, po_is_use_data, po_sides_data ) {

    // Свойства

    this.main = po_main;

    //this.is_use_data = po_is_use_data;
    //this.sides_data = po_sides_data;

    //07022025 this.scene = null; // = po_scene;
    this.shape_width = null; // = pv_shape_width;
    this.shape_height = null; // = pv_shape_height;

    this.shape;

    // материал линий разреза деталей
    this.cut_lines_material = new THREE.LineBasicMaterial({ color: Constants.shape_line_color });



    ////let lo_renderer = new THREE.WebGLRenderer({ antialias: true });
    ////let lo_resolution = new THREE.Vector2();
    ////lo_renderer.getSize(lo_resolution);

    this.part_contour_material = new LineMaterial({
        resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // Обязательно 30012025 lo_resolution,
        linewidth: Constants.line_width_shape_contour, //7, //30012025 0.7,
        color: Constants.color_shape_countour
    });



    //this.group_rect = null;

    //this.cv_rectangle_name = "my_end_shape";


    this.ColorParts = null; // new Array(10);

    this.cell_text_font = null;

    this.cell_text_geometry = null;

    this.cell_text_material = new THREE.MeshPhongMaterial({ color: Constants.cell_text_color, flatShading: true });

    //this.cell_text_mesh = null; //07022025




    //this.fontLoader = new FontLoader();
    //this.fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',

    //    function (font) {
    //        const textGeometry = new TextGeometry('3D Text!',
    //            {
    //                font: font,
    //                size: 1,
    //                height: 0.2,
    //                curveSegments: 12,
    //                bevelEnabled: true,
    //                bevelThickness: 0.03,
    //                bevelSize: 0.02,
    //                bevelSegments: 5
    //            });


    //        const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    //        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
    //        textMesh.position.set(-2, 1, 0); // Устанавливаем позицию
    //        scene.add(textMesh);
    //    });

    this.texts_array = [];

    //=====================================================================

    if (typeof this.redraw_end_shape != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------


        //------------------------------------------------------------------------
        EndShape.prototype.appending_texts_array = function (pv_required_dimension) {


            let lo_cell_text_material = null;
            let lv_cell_text_label = "";
            let lv_name_text_mesh = "";

            try {

                let lv_length_prev = this.texts_array.length;

                if (pv_required_dimension <= lv_length_prev) {

                    return;
                }

                let lv_i_beg = this.texts_array.length;
                let lv_j_beg = lv_i_beg;

                // Создаём пустые строки
                for (let lv_i = lv_i_beg; lv_i < pv_required_dimension; lv_i++) {
                    this.texts_array[lv_i] = [];
                }

                for (let lv_i = 0 /*lv_i_beg*/; lv_i < pv_required_dimension; lv_i++) {

                    if (lv_i < lv_i_beg) {
                        // предыдущие строки массива, заполняем только новые столбцы

                        lv_j_beg = lv_length_prev;
                    }
                    else {
                        // новые строки массива, заполняем все столбцы

                        lv_j_beg = 0;

                    }


                    for (let lv_j = lv_j_beg; lv_j < pv_required_dimension; lv_j++) {

                        lv_cell_text_label = this.main.common_func.get_cell_text_label(lv_i, lv_j);
                        lv_name_text_mesh = this.main.common_func.get_textmesh_name(lv_i, lv_j);

                        let lo_text_geometry = new TextGeometry(

                            lv_cell_text_label,

                            {
                                font: go_end_side_shape_generator.end_shape.cell_text_font,
                                size: Constants.cell_text_size,
                                curveSegments: 6,
                                height: 0.5,
                                bevelEnabled: true,
                                bevelThickness: 0.05,
                                bevelSize: 0.02,
                                bevelSegments: 3
                            }
                        );

                        lo_cell_text_material = this.cell_text_material.clone();

                        let lo_meshtext = new THREE.Mesh(lo_text_geometry, lo_cell_text_material);

                        lo_meshtext.name = lv_name_text_mesh;

                        this.texts_array[lv_i][lv_j] = lo_meshtext;

                    }
                }

            }

            catch (e) {

                alert('error appending_texts_array: ' + e.stack);

            }

        }
        //------------------------------------------------------------------------
        EndShape.prototype.create_texts_array = function (pv_dimension) {

            try {

                let lo_cell_text_material = null;
                let lv_cell_text_label = "";
                let lv_name_text_mesh = "";


                // очистка массива
                this.texts_array.splice(0, this.texts_array.length);



                // Создаём пустые строки
                for (let lv_i = 0; lv_i < pv_dimension; lv_i++) {
                    this.texts_array[lv_i] = [];
                }



                for (let lv_i = 0; lv_i < pv_dimension; lv_i++) {
                    for (let lv_j = 0; lv_j < pv_dimension; lv_j++) {

                        //10022025 {
                        //lv_text = (lv_i + 1).toString() + "_" + (lv_j+1).toString();
                        //lv_name_text_mesh = "text_mesh_" + lv_text;
                        //10022025 }


                        lv_cell_text_label = this.main.common_func.get_cell_text_label(lv_i, lv_j);
                        lv_name_text_mesh = this.main.common_func.get_textmesh_name(lv_i, lv_j);

                        let lo_text_geometry = new TextGeometry(

                            lv_cell_text_label,

                            {
                                font: go_end_side_shape_generator.end_shape.cell_text_font,
                                size: Constants.cell_text_size,
                                curveSegments: 6, //12,
                                height: 0.5,
                                bevelEnabled: true,
                                bevelThickness: 0.05,
                                bevelSize: 0.02,
                                bevelSegments: 3
                            }
                        );

                        lo_cell_text_material = this.cell_text_material.clone();


                        let lo_meshtext = new THREE.Mesh(lo_text_geometry, lo_cell_text_material);

                        lo_meshtext.name = lv_name_text_mesh;

                        this.texts_array[lv_i][lv_j] = lo_meshtext;

                    }
                }

            }

            catch (e) {

                alert('error create_texts_array: ' + e.stack);

            }

        }
        //------------------------------------------------------------------------
        EndShape.prototype.draw_cells_contours_and_texts = function () {


            let lo_cell_text_mesh = null;

            try {

                CommonFunc.prototype.clear_group_childrens(this.main.group_end_cells_contours);

                let lv_delta = 0.5;

                if (go_end_side_shape_generator) {
                    CommonFunc.prototype.clear_group_childrens(go_end_side_shape_generator.group_cell_texts, true, true);
                }

                //17032025 {
                if (!this.ColorParts) {
                    return;
                }
                //17032025 }


                for (let lv_i = 0; lv_i < this.ColorParts.length; lv_i++) {
                    for (let lv_j = 0; lv_j < this.ColorParts[0].length; lv_j++) {

                        let lo_rectangle = CommonFunc.prototype.get_drawing_rectangle_by_points(
                            this.ColorParts[lv_i][lv_j].left_bottom,
                            this.ColorParts[lv_i][lv_j].right_top,
                            Constants.color_shape_countour, //lv_color,
                            this.part_contour_material, //27012025 lo_material,
                            lv_delta
                        );

                        lo_rectangle.visible = this.ColorParts[lv_i][lv_j].is_contour_visible;
                        lo_rectangle.name = lv_i.toString() + "_" + lv_j.toString();

                        // Присвоение текстовых меток контурам деталей
                        let lv_text = (lv_i + 1).toString() + "_" + (lv_j + 1).toString();

                        if (go_end_side_shape_generator.params.is_show_text_labels) {
                            if (this.texts_array.length > 0) {

                                // считывание text_mesh из массива подготовленных текстов
                                lo_cell_text_mesh = this.texts_array[lv_i][lv_j];

                                let lv_x = this.ColorParts[lv_i][lv_j].left_bottom.x + 2;
                                let lv_y = this.ColorParts[lv_i][lv_j].right_top.y - 5;
                                lo_cell_text_mesh.position.set(lv_x, lv_y, 0);

                                this.ColorParts[lv_i][lv_j].text_mesh = lo_cell_text_mesh; //09022025 

                                go_end_side_shape_generator.group_cell_texts.add(lo_cell_text_mesh);//07022025
                            }

                        } //10022025 }


                        this.main.group_end_cells_contours.add(lo_rectangle);

                    }
                }

            }

            catch (e) {

                alert('error draw_cells_contours_and_texts: ' + e.stack);

            }

        }
        //------------------------------------------------------------------------
        EndShape.prototype.handle_click_on_end_side = function (po_event) {


            try {

                let lo_active_side = get_active_side_shape_generator();



                while (true) {

                    let { top, left, width, height } = lo_active_side.container.getBoundingClientRect();//07052024

                    let lv_clickMouse = new THREE.Vector2();
                    lv_clickMouse.x = ((po_event.clientX - left) / width) * 2 - 1;
                    lv_clickMouse.y = - ((po_event.clientY - top) / height) * 2 + 1;

                    // Определение - щелчок внутри фигуры, или нет
                    let lo_rectangle = this.main.group_end_shape.children[0];

                    if (lo_rectangle && lo_rectangle.name == cv_rectangle_name) {

                        let lv_isInside = lo_active_side.common_func.IsInsideRectangle(po_event, lo_rectangle /*lo_active_side.rectangle*/)

                        if (!lv_isInside) {
                            return;
                        }

                        //// Сброс выделенности всех контуров
                        //this.set_visible_all_contours(false);


                        let lo_rectangle_color_cell = this.get_rectangle_color_cell(po_event);

                        if (lo_rectangle_color_cell) {

                            if (lo_rectangle_color_cell.rectangle) {

                                lo_rectangle_color_cell.rectangle.visible = !lo_rectangle_color_cell.rectangle.visible;

                                let lv_cell_row = lo_rectangle_color_cell.row;
                                let lv_cell_col = lo_rectangle_color_cell.col;

                                // Запоминание состояния видимости контура в массиве ячеек
                                this.ColorParts[lv_cell_row][lv_cell_col].is_contour_visible = lo_rectangle_color_cell.rectangle.visible;


                                // Сброс выделенности всех предыдущих контуров
                                this.set_visible_all_contours(lo_rectangle_color_cell.rectangle, lv_cell_row, lv_cell_col, false);
                            }

                        }



                    }


                    break;
                }// while


                lo_active_side.render();


            }

            catch (e) {

                alert('error handle_click_on_end_side: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        EndShape.prototype.init_color_parts = function (pv_up_splines_amount, pv_lateral_splines_amount) {


            try {


                let lar_array;

                let lv_cols = pv_up_splines_amount + 1;
                let lv_rows = pv_lateral_splines_amount + 1;

                lar_array = new Array(lv_cols);

                //05022025 let lo_color = new THREE.Color(+Constants.background_color); 
                let lo_color = new THREE.Color(Constants.background_color); //05022025


                for (let lv_i = 0; lv_i < lv_cols; lv_i++) {

                    lar_array[lv_i] = new Array(lv_rows);

                    for (let lv_j = 0; lv_j < lv_rows; lv_j++) {
                        lar_array[lv_i][lv_j] = new typ_color_part();
                        lar_array[lv_i][lv_j].left_bottom = new THREE.Vector2(0, 0);
                        lar_array[lv_i][lv_j].right_top = new THREE.Vector2(0, 0);
                        lar_array[lv_i][lv_j].cell_color = lo_color;// +Constants.background_color;

                        //let lv_part_label_text = lv_i.toString() + "_" + lv_j.toString();
                        //lar_array[lv_i][lv_j].text_mesh
                        //    = CommonFunc.prototype.create_text_mesh(
                        //        this.main.textfont,
                        //        lv_part_label_text,
                        //        lar_array[lv_i][lv_j].text_mesh);
                        //lar_array[lv_i][lv_j].text_mesh.name = lv_part_label_text;
                    }

                }

                this.ColorParts = JSON.parse(JSON.stringify(lar_array)); // копирование в новую область памяти

            }

            catch (e) {

                alert('error init_color_parts: ' + e.stack);

            }

        }


        //------------------------------------------------------------------------
        EndShape.prototype.get_spline_position_by_side_and_num_spline = function (po_side, pv_num_spline) {

            let lv_result = null;


            try {

                if (!po_side) {

                    return lv_result;
                }

                if (pv_num_spline == null || pv_num_spline < 0) {

                    return lv_result;
                }

                if (po_side.shapes
                    && po_side.shapes.ar_splines[pv_num_spline]
                    && po_side.shapes.ar_splines[pv_num_spline].children[0]
                    && po_side.shapes.ar_splines[pv_num_spline].children[0].children[0]
                    && po_side.shapes.ar_splines[pv_num_spline].children[0].children[0].position.x
                ) {
                    lv_result = po_side.shapes.ar_splines[pv_num_spline].children[0].children[0].position.x;
                }
                else {

                    return lv_result;
                }

            }


            catch (e) {

                alert('error get_spline_position: ' + e.stack);

            }

            return lv_result;

        }


        //------------------------------------------------------------------------
        EndShape.prototype.get_rectangle_color_cell = function (po_event) {

            //let lo_result = null;
            let lo_result_rectangle = null;

            let lo_pos = null;
            try {

                let lo_active_side = get_active_side_shape_generator();

                let lo_container = lo_active_side.container;

                let lo_click_pos = this.main.common_func.recalc_coord_event2world(this.main.camera, lo_container, po_event.clientX, po_event.clientY); //06052024

                let lv_rows = go_lateral_side_shape_generator.shapes.ar_splines.length + 1;
                let lv_cols = go_up_side_shape_generator.shapes.ar_splines.length + 1;


                let lv_spline_position;

                let lv_prev_spline_position = 0;

                let lv_cell_num_column = null;
                let lv_cell_num_row = null;



                for (let lv_i = 0; lv_i < lv_rows; lv_i++) {

                    //координата начальной точки текущей кривой
                    if (lv_i == lv_rows - 1) {
                        lv_spline_position = 0;
                    }
                    else {
                        lv_spline_position = go_lateral_side_shape_generator.params.shape_width
                            - this.get_spline_position_by_side_and_num_spline(go_lateral_side_shape_generator, lv_i);
                    }

                    if (lo_click_pos.y >= lv_spline_position) {

                        lv_cell_num_row = lv_i;

                        break;
                    }
                }

                if (lv_cell_num_row == null) {
                    return null;
                }

                //----------

                for (let lv_i = 0; lv_i < lv_cols; lv_i++) {

                    //координата начальной точки текущей кривой

                    if (lv_i == lv_cols - 1) {
                        lv_spline_position = go_up_side_shape_generator.params.shape_width;
                    }
                    else {
                        lv_spline_position = this.get_spline_position_by_side_and_num_spline(go_up_side_shape_generator, lv_i);
                    }


                    if (lo_click_pos.x <= lv_spline_position) {

                        lv_cell_num_column = lv_i;
                        break;
                    }
                }

                if (lv_cell_num_column == null) {
                    return null;
                }

                // Формирование имени контура по номеру строки и столбца

                let lv_rectangle_name = this.main.common_func.get_name_by_numrow_numcol(lv_cell_num_row, lv_cell_num_column);

                // Чтение объекта контура по имени
                if (lv_rectangle_name) {

                    lo_result_rectangle = this.main.group_end_cells_contours.getObjectByName(lv_rectangle_name);
                }

                return { rectangle: lo_result_rectangle, row: lv_cell_num_row, col: lv_cell_num_column }
            }

            catch (e) {

                alert('error get_rectangle_color_cell: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        EndShape.prototype.loadFont = function () {

            try {

                const loader = new FontLoader();
                loader.load('fonts/optimer_regular.typeface.json',

                    function (response) {

                        go_end_side_shape_generator.end_shape.cell_text_font = response;
                        console.warn("font загружен");

                        //09022025 {
                        go_end_side_shape_generator.end_shape.cell_text_geometry = new TextGeometry(
                            "", //text,
                            {
                                font: go_end_side_shape_generator.end_shape.cell_text_font,
                                size: Constants.cell_text_size

                                //depth: depth,
                                //curveSegments: curveSegments,

                                //bevelThickness: bevelThickness,
                                //bevelSize: bevelSize,
                                //bevelEnabled: bevelEnabled

                            }

                        );

                        go_end_side_shape_generator.end_shape.create_texts_array(Constants.texts_array_start_dimension);

                        //09022025 }

                    });
            }

            catch (e) {

                alert('error loadFont: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        EndShape.prototype.refresh_end_shapes = function () {

            try {

                if (!this.ColorParts || !this.ColorParts[0]) { //27012025 
                    return;
                }

                let lv_nrows = this.ColorParts.length;
                let lv_ncols = this.ColorParts[0].length;
                let lv_color = null;

                CommonFunc.prototype.clear_group_childrens(this.main.end_group_cells_mesh);


                for (let lv_i = 0; lv_i < lv_nrows; lv_i++) {

                    for (let lv_j = 0; lv_j < lv_ncols; lv_j++) {

                        lv_color = this.ColorParts[lv_i][lv_j].cell_color;
                        this.set_color_to_rectangle_cell(lv_color, lv_i, lv_j);

                    }

                }
            }

            catch (e) {

                alert('error refresh_end_shapes: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        EndShape.prototype.redefine_arr_color_parts = function (
            po_main,
            pv_up_splines_amount, pv_lateral_splines_amount,
            pv_added_spline_num, pv_deleted_spline_num

        ) {


            let lv_up_added_spline_num = null;
            let lv_up_deleted_spline_num = null;
            let lv_lateral_added_spline_num = null;
            let lv_lateral_deleted_spline_num = null;



            try {

                if (!this.ColorParts) {  
                    this.init_color_parts(pv_up_splines_amount, pv_lateral_splines_amount);
                    return;
                }


                switch (po_main) {

                    case go_up_side_shape_generator:
                        lv_up_added_spline_num = pv_added_spline_num;
                        lv_up_deleted_spline_num = pv_deleted_spline_num;
                        break;

                    case go_lateral_side_shape_generator:
                        lv_lateral_added_spline_num = pv_added_spline_num;
                        lv_lateral_deleted_spline_num = pv_deleted_spline_num;
                        break;

                    default:
                        return;
                        break;
                }


                let lv_shape_up_parts_amount = pv_up_splines_amount + 1;
                let lv_shape_lateral_parts_amount = pv_lateral_splines_amount + 1;

                let lv_color_up_parts_amount = this.ColorParts[0].length;
                let lv_color_lateral_parts_amount = this.ColorParts.length;

                let lar_newRow = null;



                let lar_cop_color_parts = JSON.parse(JSON.stringify(this.ColorParts));




                let lv_is_changed = false;

                // добавление строки

                if (typeof lv_lateral_added_spline_num === "number") { //07022025

                    if (lv_lateral_added_spline_num >= 0) {


                        lar_newRow = JSON.parse(JSON.stringify(lar_cop_color_parts[lv_lateral_added_spline_num]));
                        lar_cop_color_parts[lar_cop_color_parts.length] = lar_newRow;

                        lv_is_changed = true;
                    }
                }


                // удаление строки

                if (typeof lv_lateral_deleted_spline_num === "number") {
                    if (lv_lateral_deleted_spline_num >= 0) {

                        for (let lv_j = 0; lv_j < lar_cop_color_parts[0].length; lv_j++) {  //09022025
                            // Удаляем текстовые элементы из удаляемой строки
                            this.main.common_func.disposeTextMesh(lar_cop_color_parts[lv_lateral_deleted_spline_num][lv_j].text_mesh, true);

                        }


                        lar_cop_color_parts.splice(lv_lateral_deleted_spline_num, 1); // Удаляем строку с индексом pv_deleted_up_spline_num
                        lv_is_changed = true;

                    }
                }




                // добавление столбца

                if (typeof lv_up_added_spline_num === "number") { //07022025
                    if (lv_up_added_spline_num >= 0) {


                        // копирование столбца
                        let lar_column = lar_cop_color_parts.map(row => JSON.parse(JSON.stringify(row[lv_up_added_spline_num]))); //29122024

                        // добавление
                        for (let lv_i = 0; lv_i < lar_cop_color_parts.length; lv_i++) {
                            lar_cop_color_parts[lv_i].splice(lv_up_added_spline_num, 0, lar_column[lv_i]);

                        }
                        lv_is_changed = true;

                    }
                }


                // удаление столбца
                if (typeof lv_up_deleted_spline_num === "number") { //07022025

                    if (lv_up_deleted_spline_num >= 0) {

                        for (let lar_row of lar_cop_color_parts) {

                            // Удаляем текстовый элемент из удаляемого столбца
                            this.main.common_func.disposeTextMesh(lar_row[lv_up_deleted_spline_num].text_mesh, true);

                            lar_row.splice(lv_up_deleted_spline_num, 1); // Удаляем элемент из каждой строки

                            //lv_i++;
                        }
                        lv_is_changed = true;

                    }
                }

                if (lv_is_changed) {
                    this.ColorParts = JSON.parse(JSON.stringify(lar_cop_color_parts));//08022025

                }

            }

            catch (e) {

                alert('error redefine_arr_color_parts: ' + e.stack);

            }

        }

        //------------------------------------------------------------------------
        EndShape.prototype.redraw_end_shape = function (
            po_main,
            pv_added_spline_num, pv_deleted_spline_num,
            po_is_use_data,
            po_sides_data
        ) {


            let lv_up_splines_amount = 0;
            let lv_lateral_splines_amount = 0;

            let lv_up_shape_width = 0;
            let lv_lateral_shape_width = 0;


            try {





                //27012025 {
                if (po_is_use_data) {

                    lv_up_splines_amount = po_sides_data.data1.numCurves;
                    lv_lateral_splines_amount = po_sides_data.data2.numCurves;

                    lv_up_shape_width = po_sides_data.data1.M_Width;
                    lv_lateral_shape_width = po_sides_data.data2.M_Width;

                    this.ColorParts = po_sides_data.ColorParts;//29012025


                    CommonFunc.prototype.clear_group_childrens(this.main.group_end_shape);

                }
                else {
                    //lv_up_splines_amount = go_up_side_shape_generator.params.shape_amount_curves;
                    //lv_lateral_splines_amount = go_lateral_side_shape_generator.params.shape_amount_curves;

                    //17032025 {
                    if (!go_up_side_shape_generator.shapes) {
                        return;
                    }
                    if (!go_lateral_side_shape_generator) {
                        return;
                    }

                    if (!go_lateral_side_shape_generator.shapes) {
                        return;
                    }

                    //17032025 }

                    lv_up_splines_amount = go_up_side_shape_generator.shapes.ar_splines.length;
                    lv_lateral_splines_amount = go_lateral_side_shape_generator.shapes.ar_splines.length;


                    lv_up_shape_width = go_up_side_shape_generator.params.shape_width;
                    lv_lateral_shape_width = go_lateral_side_shape_generator.params.shape_width;


                    //this.loadFont();


                }
                //27012025 }






                //let lv_up_splines_amount = go_up_side_shape_generator.shapes.shape_amount_curves;
                //let lv_lateral_splines_amount = go_lateral_side_shape_generator.shapes.shape_amount_curves;




                // переопределение размерности массива цветов

                this.redefine_arr_color_parts(
                    po_main,
                    lv_up_splines_amount, lv_lateral_splines_amount,
                    pv_added_spline_num, pv_deleted_spline_num
                );


                CommonFunc.prototype.clear_group_childrens(this.main.group_end_shape);



                let lv_cols = lv_up_splines_amount + 1;
                let lv_rows = lv_lateral_splines_amount + 1;



                // Общий контур торцевой стороны
                let lo_rectangle = CommonFunc.prototype.get_drawing_rectangle(
                    //go_lateral_side_shape_generator.params.shape_width, //11012025
                    //go_up_side_shape_generator.params.shape_width

                    lv_up_shape_width, //27012025 go_up_side_shape_generator.params.shape_width,
                    lv_lateral_shape_width //27012025 go_lateral_side_shape_generator.params.shape_width //11012025

                );
                lo_rectangle.name = cv_rectangle_name;

                this.main.group_end_shape.add(lo_rectangle);





                let lo_line_curr = null;
                let lo_geom_hor = null;
                let lo_geom_vert = null;
                let lo_line_hor = null;
                let lo_line_vert = null;

                lo_geom_hor = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(lv_up_shape_width, 0)
                ]);
                lo_line_hor = new THREE.LineSegments(lo_geom_hor, this.cut_lines_material);//27012025

                lo_geom_vert = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector2(0, 0),
                    //27012025 new THREE.Vector2(0, go_lateral_side_shape_generator.params.shape_width)
                    new THREE.Vector2(0, lv_lateral_shape_width)
                ]);
                //27012025 lo_line_vert = new THREE.LineSegments(lo_geom_vert, lo_material);
                lo_line_vert = new THREE.LineSegments(lo_geom_vert, this.cut_lines_material); //27012025


                let lv_line_position = 0;
                let lv_prev_line_position = 0;
                let lv_cell_position = 0;
                let lv_spline_position = 0;


                // Задание горизонтальных линий по y
                //------------------------------------------------------------------------------------

                for (let lv_i = 0; lv_i < lv_rows; lv_i++) {

                    lo_line_curr = lo_line_hor.clone();

                    if (lv_i == 0) {

                        //координаты начальной точки текущей кривой
                        lv_spline_position = this.get_spline_position_by_side_and_num_spline(go_lateral_side_shape_generator, lv_i);
                        lv_line_position = lv_lateral_shape_width - lv_spline_position;

                        lv_cell_position = lv_lateral_shape_width;


                        if (this.ColorParts) { //27012025 
                            if (this.ColorParts[0]) { //27012025 

                                for (let lv_j = 0; lv_j < this.ColorParts[0].length; lv_j++) { //25122024
                                    this.ColorParts[lv_i][lv_j].right_top.y = lv_cell_position;
                                }
                            } //27012025 }
                        }


                        lo_line_curr.position.y = lv_line_position;
                        lv_prev_line_position = lv_line_position;

                        this.main.group_end_shape.add(lo_line_curr);

                    }
                    else {

                        if (lv_i == lv_rows - 1) {

                            lv_cell_position = 0; // go_lateral_side_shape_generator.params.shape_width;;

                            if (this.ColorParts) { //27012025 
                                if (this.ColorParts[0]) { //27012025 

                                    for (let lv_j = 0; lv_j < this.ColorParts[0].length; lv_j++) { //25122024

                                        this.ColorParts[lv_i - 1][lv_j].left_bottom.y = lv_prev_line_position; // 29122024

                                        this.ColorParts[lv_i][lv_j].left_bottom.y = lv_cell_position;
                                        this.ColorParts[lv_i][lv_j].right_top.y = lv_prev_line_position; // go_lateral_side_shape_generator.params.shape_width;

                                    }
                                }
                            }
                        }

                        else {

                            lo_line_curr = lo_line_hor.clone();

                            //координаты начальной точки текущей кривой
                            lv_spline_position = this.get_spline_position_by_side_and_num_spline(go_lateral_side_shape_generator, lv_i);
                            lv_line_position = lv_lateral_shape_width - lv_spline_position;


                            lo_line_curr.position.y = lv_line_position; // lv_curve_distance_hor * (lv_i + 1);

                            // присвоение координат в массиве ячеек ColorParts

                            // присвоение координаты y
                            if (this.ColorParts) { //27012025 
                                if (this.ColorParts[0]) { //27012025 

                                    for (let lv_j = 0; lv_j < this.ColorParts[0].length; lv_j++) {

                                        this.ColorParts[lv_i - 1][lv_j].left_bottom.y = lv_prev_line_position; // lv_line_position;
                                        this.ColorParts[lv_i][lv_j].right_top.y = lv_prev_line_position; //lv_line_position;
                                        this.ColorParts[lv_i][lv_j].left_bottom.y = lv_line_position; //lv_line_position;

                                    }
                                }
                            }

                            lv_prev_line_position = lv_line_position; // lv_spline_position; // lv_cell_position; // lv_line_position;

                            this.main.group_end_shape.add(lo_line_curr);

                        }

                    }
                }

                // Задание вертикальных линий по x
                //------------------------------------------------------------------------------------


                for (let lv_j = 0; lv_j < lv_cols; lv_j++) {

                    lo_line_curr = lo_line_vert.clone();

                    if (lv_j == 0) {

                        // первый столбец

                        //координаты начальной точки текущей кривой

                        lv_spline_position = this.get_spline_position_by_side_and_num_spline(go_up_side_shape_generator, lv_j);
                        lv_line_position = /*go_up_side_shape_generator.params.shape_width -*/ lv_spline_position;

                        lv_cell_position = 0;// go_up_side_shape_generator.params.shape_width;


                        if (this.ColorParts) { //27012025 
                            if (this.ColorParts[0]) { //27012025


                                //08022025 {
                                //for (let lv_i = 0; lv_i < this.ColorParts[0].length; lv_i++) {  //30122024
                                //    this.ColorParts[lv_j][lv_i].left_bottom.x = lv_cell_position;
                                //}


                                //09022025 for (let lv_i = 0; lv_i < this.ColorParts[0].length; lv_i++) {  
                                for (let lv_i = 0; lv_i < this.ColorParts.length; lv_i++) {  //09022025
                                    this.ColorParts[lv_i][lv_j].left_bottom.x = lv_cell_position;
                                }


                                //08022025 }


                            }
                        }

                        lo_line_curr.position.x = lv_line_position;
                        lv_prev_line_position = lv_line_position; // lv_spline_position;

                        this.main.group_end_shape.add(lo_line_curr);

                    }
                    else {
                        // последний столбец

                        if (lv_j == lv_cols - 1) {

                            if (this.ColorParts) { //27012025 
                                if (this.ColorParts[0]) { //27012025


                                    for (let lv_i = 0; lv_i < this.ColorParts.length; lv_i++) {

                                        this.ColorParts[lv_i][lv_j - 1].right_top.x = lv_prev_line_position; // 29122024

                                        this.ColorParts[lv_i][lv_j].right_top.x = lv_up_shape_width;

                                        this.ColorParts[lv_i][lv_j].left_bottom.x = lv_prev_line_position; //25122024
                                    }
                                }
                            }
                        }

                        else {

                            lo_line_curr = lo_line_vert.clone();

                            lv_spline_position = this.get_spline_position_by_side_and_num_spline(go_up_side_shape_generator, lv_j);
                            lv_line_position = lv_spline_position;
                            lo_line_curr.position.x = lv_line_position;

                            // присвоение координат в массиве ячеек ColorParts

                            // присвоение координаты x 
                            if (this.ColorParts) { //27012025 
                                if (this.ColorParts[0]) { //27012025 

                                    for (let lv_i = 0; lv_i < this.ColorParts.length; lv_i++) {

                                        this.ColorParts[lv_i][lv_j - 1].right_top.x = lv_prev_line_position;
                                        this.ColorParts[lv_i][lv_j].right_top.x = lv_line_position;
                                        this.ColorParts[lv_i][lv_j].left_bottom.x = lv_prev_line_position;

                                    }
                                }
                            }

                            lv_prev_line_position = lv_line_position; //lv_spline_position; // lv_line_position;
                            this.main.group_end_shape.add(lo_line_curr);

                            //}

                        }

                    }
                }



            }

            catch (e) {

                alert('error redraw_end_shape: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        EndShape.prototype.set_color_to_rectangle_cell = function (po_color, pv_cell_num_row, pv_cell_num_col) {

            try {

                let lo_rectangle = null;

                let lv_cell_name = CommonFunc.prototype.get_name_by_numrow_numcol(pv_cell_num_row, pv_cell_num_col)

                // Чтение объекта контура по имени
                if (lv_cell_name) {
                    lo_rectangle = this.main.group_end_cells_contours.getObjectByName(lv_cell_name);
                }

                if (!lo_rectangle) {
                    return;
                }


                let lo_mesh_prev = this.main.end_group_cells_mesh.getObjectByName(lv_cell_name);
                if (lo_mesh_prev) {
                    CommonFunc.prototype.removeObjectsWithChildren(lo_mesh_prev, true);
                }


                let lar_shape_points = [];
                lar_shape_points.push(
                    new THREE.Vector2(this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.x, this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.y/*, 0*/),
                    new THREE.Vector2(this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.x, this.ColorParts[pv_cell_num_row][pv_cell_num_col].right_top.y/*, 0*/),
                    new THREE.Vector2(this.ColorParts[pv_cell_num_row][pv_cell_num_col].right_top.x, this.ColorParts[pv_cell_num_row][pv_cell_num_col].right_top.y/*, 0*/),
                    new THREE.Vector2(this.ColorParts[pv_cell_num_row][pv_cell_num_col].right_top.x, this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.y/*, 0*/),
                    new THREE.Vector2(this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.x, this.ColorParts[pv_cell_num_row][pv_cell_num_col].left_bottom.y/*, 0*/)
                );

                this.ColorParts[pv_cell_num_row][pv_cell_num_col].cell_color = po_color; //05022025 "+" - для представление в виде числа, а не строки

                let lo_shape = new THREE.Shape(lar_shape_points);
                let lo_geometry = new THREE.ShapeGeometry(lo_shape);

                let lo_material = new THREE.MeshBasicMaterial({ color: po_color });//05022025

                let lo_mesh = new THREE.Mesh(lo_geometry, lo_material);
                lo_mesh.name = lv_cell_name;


                this.main.end_group_cells_mesh.add(lo_mesh);

            }

            catch (e) {

                alert('error set_color_to_rectangle_cell: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------
        EndShape.prototype.set_color_to_selected_rectangle_cells = function (pv_color_value) {

            let lv_i_result = null;
            let lv_j_result = null;

            try {


                let lv_nrows = this.ColorParts.length;
                let lv_ncols = this.ColorParts[0].length;

                let lv_is_break = false;

                for (let lv_i = 0; lv_i < lv_nrows; lv_i++) {
                    for (let lv_j = 0; lv_j < lv_ncols; lv_j++) {

                        if (this.ColorParts[lv_i][lv_j].is_contour_visible) {
                            this.set_color_to_rectangle_cell(pv_color_value, lv_i, lv_j);
                            lv_i_result = lv_i;
                            lv_j_result = lv_j;
                            lv_is_break = true;
                            break;
                        }

                    }
                    if (lv_is_break) {
                        break;
                    }
                }



            }

            catch (e) {

                alert('error set_color_to_selected_rectangle_cells: ' + e.stack);

            }

            return {
                cell_num_row: lv_i_result,
                cell_num_col: lv_j_result
            }

        }

        //------------------------------------------------------------------------
        EndShape.prototype.set_show_text_labels = function (pv_value) {

            try {

                this.draw_cells_contours_and_texts();
            }

            catch (e) {

                alert('error set_show_text_labels: ' + e.stack);

            }
        }

        //------------------------------------------------------------------------
        EndShape.prototype.set_visible_all_contours = function (po_rectangle, pv_cell_row, pv_cell_col, pv_is_visible) {

            try {


                //28012025 this.main.group_end_cells_contours

                for (let lo_mesh of this.main.group_end_cells_contours.children) {


                    if (lo_mesh.type == "Line2") {

                        if (lo_mesh !== po_rectangle) {

                            lo_mesh.visible = pv_is_visible;
                        }
                    }

                }

                this.set_visible_all_color_cells(pv_cell_row, pv_cell_col, pv_is_visible, pv_is_visible);

            }

            catch (e) {

                alert('error reset_all_contours: ' + e.stack);

            }
        }


        //------------------------------------------------------------------------
        EndShape.prototype.set_visible_all_color_cells = function (pv_cell_row, pv_cell_col, pv_is_visible) {

            try {

                let lv_nrows = this.ColorParts.length;
                let lv_ncols = this.ColorParts[0].length;

                for (let lv_i = 0; lv_i < lv_nrows; lv_i++) {

                    for (let lv_j = 0; lv_j < lv_ncols; lv_j++) {

                        if (lv_i !== pv_cell_row || lv_j !== pv_cell_col) {

                            this.ColorParts[lv_i][lv_j].is_contour_visible = pv_is_visible;
                        }
                    }
                }
            }

            catch (e) {

                alert('error set_visible_all_color_cells: ' + e.stack);

            }
        }




        //====================================================================



    }  // if (typeof this.create_rectangle !== "function")

    //====================================================================

    this.loadFont();// Загрузка шрифта


    this.redraw_end_shape(
        null,
        null, null,          //   po_main,
        null, null           //   pv_added_spline_num, pv_deleted_spline_num,
    );                       //   po_is_use_data, po_sides_data





}

// end Class Rectangle
//=====================================================================

//15012025 import * as THREE from 'three';
//import { Line2 } from 'three/addons/lines/Line2.js';
//import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineGeometry } from 'three/addons/lines/LineGeometry.js';


//import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
//import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

//import { STLLoader } from 'three/addons/loaders/STLLoader.js';//20082024

//14032025 import { STLLoader } from 'https://unpkg.com/three@v0.149.0/examples/jsm/loaders/STLLoader.js';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';//14032025


//import {
//    get_active_side_shape_generator,
//    get_passive_side_shape_generator
//} from './my_shape_generator.js';


import {
    get_active_side_shape_generator,
    get_passive_side_shape_generator,

    gc_id_prefix_up,
    gc_id_prefix_lateral,
    gc_id_prefix_end,

    go_up_side_shape_generator,
    go_lateral_side_shape_generator,
    go_end_side_shape_generator,

    //Shape_generator
} from './my_shape_generator.js';





import {
    Constants,
    Wide_model_types
} from './my_common_const.js';


var go_this = null;
var go_grid = null; //$("#id_GridSelectModels");



//==================================================================================================
// Class GridSelectModels
export function GridSelectModels(pv_prefix) {

    //// Свойства
    //this.container = po_container;
    //this.camera = po_camera;
    //this.scene = po_scene;

    //this.shape_width = po_params.shape_width;
    //this.shape_height = po_params.shape_height;

    //this.shape;

    //this.group_rect = null;

    this.prefix = pv_prefix;

    //this.cv_grid_select_models = "my_grid_select_models";

    this.$grid = null;

    //=====================================================================

    if (typeof this.create_grid_select_models != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------



        //Rectangle.prototype.create_GridSelectModels = function () {


        //	try {


        //	}

        //	catch (e) {

        //		alert('error create_shapes: ' + e.stack);

        //	}


        //}


        //------------------------------------------------------------------------
        GridSelectModels.prototype.create_grid_select_models = function (  /*pv_distance_bt_curves*/) {

            //const cv_rect_width = this.shape_width;
            //const cv_rect_height = this.shape_height;

            try {

                go_this = this;


                //const positions = [];
                //positions.push(0, 0, 0);
                //positions.push(0, cv_rect_height, 0);
                //positions.push(cv_rect_width, cv_rect_height, 0);
                //positions.push(cv_rect_width, 0, 0);
                //positions.push(0, 0, 0);


                //let lv_color = 0x0040f0;
                //let lv_x = 0; //13032024  pv_distance_bt_curves/2;// / 2; // 0;
                //let lv_y = 0;

                //const clrs = [];

                //positions.forEach(() => {
                //	clrs.push(255, 0, 255);
                //});


                //let geometry = new LineGeometry();

                //geometry.setPositions(positions);/////

                //geometry.setColors(clrs);

                //let resolution = new THREE.Vector2();

                //let renderer = new THREE.WebGLRenderer({ /*antialias: true*/ });
                //renderer.getSize(resolution);

                //let material = new LineMaterial({
                //	//color: new Color("#fff").getHex(),
                //	vertexColors: 0xf0f, //VertexColors,
                //	linewidth: 0.5, //1, //2,
                //	resolution: resolution
                //	//dashed: false, //true,
                //	//gapSize: 0.75,
                //	//dashScale: 1.5,
                //	//dashSize: 1
                //});

                //material.needsUpdate = true;

                //this.shape = new Line2(geometry, material);
                //this.shape.computeLineDistances();
                //////lo_line.scale.set(1, 1, 1);

                //this.shape.name = this.cv_rectangle_name;

                //this.shape.position.set(lv_x, lv_y);//, 0 pv_z - 25);

                //////lo_group.add(this.shape);
                //////this.group_rect = lo_group;
                //////this.scene.add(lo_group);

                //this.scene.add(this.shape);

                //this.prefix = pv_prefix;

                ////this.$div_grid = $(this.prefix + "id_div_GridSelectModels");
                ////this.$grid = $(this.prefix + "id_GridSelectModels");
                ////this.$gridPager = $(this.prefix + "id_div_GridSelectModelsPager");

                this.$div_grid = $("#id_div_GridSelectModels");
                this.$grid = $("#id_GridSelectModels");
                this.$gridPager = $("#id_div_GridSelectModelsPager");


                this.$div_grid.dialog({
                    title: '                                  List of models',
                    autoOpen: false,
                    modal: true,
                    resizable: false,
                    height: 650, //"auto", //600, //"auto",
                    width: "auto", // 600,
                    buttons: {
                        "Close": function () {
                            $(this).dialog("close");
                        }
                    },
                    //open: function () {
                    //    $(this).dialog("widget").find(".ui-dialog-titlebar").hide();
                    //},

                    //position: { my: "center top", at: "left bottom"/*, of: button*/ }
                    /*position: { at: "center center+25%", my: "center center+25%" }*/

                });

                go_grid = this.$grid;


                //----------------  grid  -----------------------------------------------------------------

                this.$grid.jqGrid({
                    //go_Grid.jqGrid({
                    //url: 'jqGridSelectBlockSetingsHandler.ashx',
                    datatype: 'json',
                    //height: auto, //230,//120,//90, //250,
                    width: 1100, //800, //1000,

                    //23092021 autowidth: true,

                    hoverrows: true, //true, //false, // подсвечивание строк

                    rowattr: function (rowData, currentObj, rowId) {
                        /*if (rowData.SomeField == "SomeValue") {*/
                        return {
                            //"class": "ui-state-disabled",
                            "style": "cursor:pointer"
                        };
                        /*}*/
                    },


                    onSelectRow: function (rowid, status) {
                        $('#' + rowid).removeClass('ui-state-highlight');

                        let lo_active_side = get_active_side_shape_generator();

                        lo_active_side.grid_select_models.OndblClickRow(rowid);
                    },



                    //colNames: ['pathFile', 'Hash_name', '№ п/п', 'Имя настройки', 'Описание', 'Дата изм.', 'Время изм.', '<i class="bi-share"></i>', 'username_hash_with_postfix'],
                    //colModel: [
                    //	{ name: 'pathFile', index: 'pathFile', hidden: true },
                    //	{ name: 'Hash_name', index: 'Hash_name', hidden: true, width: 70, sortable: true, align: 'center' },
                    //	{ name: 'RowID', index: 'RowID', width: 50, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ },
                    //	{ name: 'NameSet', index: 'NameSet', align: 'center', width: 160, sortable: true/*, formatter: cellLinkFormater*/ },
                    //	{ name: 'Description', index: 'Description', width: 300, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ },
                    //	{ name: 'DateChange', index: 'DateChange', width: 70, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ },
                    //	{ name: 'changeTime', index: 'changeTime', width: 90, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ },
                    //	{ name: 'IsCommonNastr', index: 'IsCommonNastr', sortable: true, width: 35, align: 'center'/*, formatter: is_shared_file_formatter*/ },
                    //	{ name: 'username_hash_with_postfix', index: 'username_hash_with_postfix', hidden: true }

                    //],
                    //	  public string path_file_wo_ext { get; set; }
                    //      public string filename { get; set; }
                    //      //public string descr { get; set; }
                    //      public byte[] picture { get; set; }
                    //      ////public string path_file_sides_data { get; set; }
                    //      ////public string path_file_prev_model { get; set; }
                    //      ////public string path_file_final_model { get; set; }
                    //      public wide_model_types wide_model_type { get; set; }
                    //      public string price { get; set; }
                    //      public string change_datetime { get; set; }


                    //colNames: ['pathFile', '<i class="bi-share"></i>', 'Model name', /*'Description',*/ 'Picture', 'Change date', 'Change time', 'username_hash_with_postfix'],
                    //colNames: ['path_file_wo_ext', 'filename', 'picture', '< i class= "bi-share" ></i >', 'price', 'Change time'],
                    colNames: ['&nbsp;<i class= "bi-share" title="Shared or private model" />&nbsp;', 'path_file_wo_ext', 'Filename', 'Picture', 'Price', 'Change time'],
                    colModel: [
                        { name: 'wide_model_type', index: 'wide_model_type', sortable: true, width: 10, align: 'center', formatter: this.is_shared_file_formatter },
                        { name: 'path_file_wo_ext', index: 'path_file_wo_ext', hidden: true },
                        { name: 'filename', index: 'filename', align: 'center', width: 70, sortable: true/*, formatter: cellLinkFormater*/ },
                        { name: 'picture', index: 'Picture', width: 60, sortable: true, formatter: this.imageformatter /*, formatter: cellLinkFormater*/ },
                        //{ name: 'path_file_sides_data', index: 'path_file_sides_data', hidden: true },
                        //{ name: 'path_file_sides_data', index: 'path_file_sides_data', hidden: true },
                        //{ name: 'path_file_sides_data', index: 'path_file_sides_data', hidden: true },
                        //{ name: 'Description', index: 'Description', width: 300, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ },
                        { name: 'price', index: 'price', width: 30, sortable: true, align: 'center'/*, formatter: cellLinkFormater */ },
                        { name: 'change_datetime', index: 'change_datetime', width: 40, sortable: true, align: 'center'/*, formatter: cellLinkFormater*/ }

                    ],





                    //caption: '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' + 'List of models',
                    caption: "", //"Выбор настройки",
                    rowNum: 100, //10,
                    //rowList: [10, 50, 100],
                    pager: this.$gridPager,
                    sortname: 'change_datetime', //'RowID',

                    ////viewrecords: false, //true,//////////////////////////

                    /////////////////////////////////editurl: "/Index?handler=GridListBlockSetings?delete=yes", //10092022

                    sortorder: 'desc', //'asc',

                    //firstsortorder: 'desc',

                    /////////////////// 08112024 ondblClickRow: this.OndblClickRow,

                    datatype: 'local',


                    //////onSelectRow: function (e1, e2, e3) { alert("onSelectRow e1=" + e1 + "  e2=" + e2 + "e3= " + e3) },


                    //deepempty: true,

                    //loadonce: false,
                    //cache: true,


                    //hiddengrid: 'false' //'true'


                    //        gridComplete: function () {
                    //            var ids = lv_GridSelectBlockSettings.jqGrid('getDataIDs');
                    //            for (var i = 0; i < ids.length; i++) {
                    //                var cl = ids[i];
                    ////                be = "<input style='height:22px;width:20px;' type='button' value='E' onclick=\"jQuery('#id_GridSelectBlockSettings').delRowData('" + cl + "');\"  />";
                    //                be = "<input style='height:22px;width:20px;' type='button' value='E' onclick=\"jQuery('#id_GridSelectBlockSettings').delGridRow('" + cl + "');\"  />";
                    //                lv_GridSelectBlockSettings.jqGrid('setRowData', ids[i], { act: be });
                    //            }
                    //        }


                    //onSelectRow: function (id) {
                    //    if (id && id !== lastsel2) {
                    //        $('#GridSelectBlockSettings').jqGrid('restoreRow', lastsel2);
                    //        $('#GridSelectBlockSettings').jqGrid('editRow', id, true);
                    //        lastsel2 = id;
                    //    }
                    //},


                    ////////////////loadComplete: function (id) { //03062022


                    ////////////////	//var lv_rows = lv_LoadedTextGrid.getGridParam("reccount");

                    ////////////////	//if (lv_rows > 0) {


                    ////////////////	//    $("#id_dialog_file_saved").dialog("open");

                    ////////////////	//}


                    ////////////////}

                });// Grid
                //------------------------------------------------------------------------------------------

            }

            catch (e) {

                alert('error create_grid_select_models: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------------------------
        GridSelectModels.prototype.do_row_choice = function (pv_rowid) {

            let lv_ar;

            try {

                lv_ar = this.$grid.getRowData(pv_rowid);


                let lv_pathFile = lv_ar["path_file_wo_ext"];

                if (typeof (lv_pathFile) == "undefined" || lv_pathFile == "" || lv_pathFile == null) {
                    return;
                }

                this.read_model_from_server(lv_pathFile);

                this.$div_grid.dialog("close");
            }

            catch (e) {

                alert('error do_row_choice: ' + e.stack);

            }
        }


        //-----------------------------------------------------------------------------------------

        GridSelectModels.prototype.imageformatter = function (pv_cellvalue, ps_options, po_rowObject) {


            let lv_return = pv_cellvalue;


            try {
                let lv_str = po_rowObject[1];
                lv_str = lv_str.replace("wwwroot/", "");

                // дату добавляем для исключения кеширования
                lv_return = '<div class="wrapper_img for_cell"> <img  src="' + lv_str + Constants.file_model_graph + '?date=' + new Date() + '" /></div>'; //class="cell_img"

            }

            catch (e) {

                alert('error imageformatter: ' + e.stack);

            }

            return lv_return;

        }


        //-----------------------------------------------------------------------------------------

        GridSelectModels.prototype.is_shared_file_formatter = function (pv_cellvalue, ps_options, po_rowObject) {

            let lv_return = pv_cellvalue;
            try {
                if (pv_cellvalue == "") {

                    return "";
                }

                if (pv_cellvalue == Wide_model_types.common) {
                    lv_return = '<i class= "bi-share" title = "Shared model" />';
                };

                if (pv_cellvalue == Wide_model_types.user) {
                    lv_return = '<i class="bi-person-fill" title="Private model" />';
                };


            }

            catch (e) {

                alert('error is_shared_file_formatter: ' + e.stack);

            }

            return lv_return;

        }
        //------------------------------------------------------------------------------------------
        GridSelectModels.prototype.OndblClickRow = function (e) {

            //var grid = $("#id_GridSelectBlockSettings");

            try {

                let rowKey = go_grid.jqGrid('getGridParam', "selrow");

                if (rowKey) {

                    go_this.do_row_choice(rowKey);

                }
                else {
                    return;
                }

            }

            catch (e) {

                alert('error OndblClickRow: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------------------------
        GridSelectModels.prototype.oncomplete_read_model_from_server = function (po_data) {

            try {

                let lo_active_side = get_active_side_shape_generator();

                if (!lo_active_side) {
                    return;
                }

                //26012025 {
                // очистка данных модели
                go_up_side_shape_generator.clear_model_data();
                go_lateral_side_shape_generator.clear_model_data();
                go_end_side_shape_generator.clear_model_data();
                //26012025 }


                lo_active_side.is_ask_about_save_file = false;
                lo_active_side.is_model_changed = false;


                //////// тестовый пример загрузки изображения
                //////let $id_div_visual_model = $("#id_screenshot");
                //////$id_div_visual_model.empty();
                //////let lo_img = document.createElement("img");
                //////lo_img.src = po_data;
                //////$id_div_visual_model.append(lo_img);
                //////$id_div_visual_model.css('display', 'block');


                let lo_data = JSON.parse(po_data); //29102024

                ////// Очистка группы с превью
                ////lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);


                //27012025 {
                ////// Очистка группы с деталями модели
                ////lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);
                ////lo_active_side.render_mod();
                //27012025 }


                if (!lo_data) {
                    return;
                }


                let loader = null;
                let lo_geometry = null;

                if (lo_data.prev_model.length > 100) {

                    loader = new STLLoader();
                    lo_geometry = loader.parse(lo_data.prev_model);

                }


                ////07012025 {
                //if (!lo_active_side) {
                //    return;
                //}
                ////07012025 }


                // Задержка после парсинга ?
                setTimeout(function () {

                    let lo_active_side = get_active_side_shape_generator();

                    if (!lo_active_side) {
                        return;
                    }

                    $("#id_model_name").val(lo_data.model_name);


                    if (lo_geometry) {
                        lo_active_side.on_load_model(lo_geometry);
                        lo_active_side.render_mod();
                    }
                    if (lo_data.sides_data) {
                        lo_active_side.draw_shape_by_sides_data(lo_data.sides_data);

                        go_up_side_shape_generator.common_func.hideWaitingIndicator();

                        //lo_active_side.render();//27012025
                    }

                }, 100);



                //// Очистка сцены
                //let lar_no_delete = ["PointLight", "PerspectiveCamera", "Group"];// "Mesh",
                //28102024 lo_active_side.common_func.clearScene(lo_active_side.scene_mod, lar_no_delete);

                ////lo_active_side.common_func.clear_group_childrens(lo_active_side.group_parts_mod);
                ////lo_active_side.render_mod();




                ////////////////////////lo_active_side.on_load_model(lo_geometry);
                ////////////////////////lo_active_side.render_mod();


            }

            catch (e) {

                go_up_side_shape_generator.common_func.hideWaitingIndicator();

                alert('error oncomplete_read_model_from_server: ' + e.stack);

            }

        }



        //------------------------------------------------------------------------------------------
        GridSelectModels.prototype.read_model_from_server = function (pv_pathFile, pv_is_initial_load) {


            go_up_side_shape_generator.common_func.showWaitingIndicator('Reading model..');

            let lv_url = "";


            lv_url = "/Index?handler=" + Constants.method_read_model_from_server + "&pathmodel=" + pv_pathFile;
            if (pv_is_initial_load) {

                lv_url = lv_url + "&" + Constants.initial_load + "=true";
            }


            get_read_model_from_server(lv_url);


            //--------------------------------------------------
            async function get_read_model_from_server(pv_url) {


                try {

                    await $.get(pv_url, "", go_this.oncomplete_read_model_from_server);

                }

                catch (e) {

                    go_up_side_shape_generator.common_func.hideWaitingIndicator();

                    alert('error get_read_model_from_server: ' + e.stack);

                }

            }

        }

        //====================================================================

    }  // if (typeof this.create_rectangle !== "function")

    //====================================================================



    this.create_grid_select_models();


}

// end Class GridSelectModels
//=====================================================================
//import { CommonFunc } from './my_common_func.js';

import { Constants } from './my_common_const.js';

var go_this = null;

//================================================================================
// Class ProgressBar

export function ProgressBar(po_side, pv_client_id, pv_url, pv_name_start_method, pv_read_result_method, pv_end_watching_progress_value) {

    go_this = this;//24112024


    this.client_id = pv_client_id;
    this.shg_side = po_side;
    this.url = pv_url;
    this.name_start_method = pv_name_start_method;
    this.read_result_method = pv_read_result_method;

    this.div_progressbar = $(po_side.id_prefix + "id_div_progressbar");
    this.progress_value = 0; // bvi

    this.task_id = 0;

    this.progressTimer = null;
    this.progressbar = document.getElementById(po_side.id_prefix_wo_sharp + "id_progressbar"); // $("#id_progressbar");
    this.progressLabel = $(po_side.id_prefix + "id_label_progress");


    //this.dialogButtons = null;
    //this.dialog = null;
    //this.downloadButton = null;
    //this.progressbar = null;

    this.monitoring_server_timer = null;

    this.end_watching_progress_value = pv_end_watching_progress_value

    //=====================================================================

    //if (typeof this.init_progress_bar != "function") {
    if (typeof this.init_progress_bar != "function") {


        //-----------------------------------------------------------------------------------

        ProgressBar.prototype.init_progress_bar = function () {

            try {

                //24112024 go_this = this; 

                //22112024 this.task_id = this.shg_side.common_func.get_random_number_int(1, 9999999999).toString();


            }

            catch (e) {

                alert('error init_progress_bar: ' + e.stack);

            }

        }


        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.start_progress = function () {

            try {

                //go_this = this;

                //go_this.task_id = this.shg_side.common_func.get_random_number_int(1, 9999999999).toString(); //22112024

                //go_this.div_progressbar.show(1000);
                ///go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 1);//bvi
                //go_this.div_progressbar.slideDown();
                go_this.div_progressbar.fadeIn();
                ///go_this.div_progressbar.toggle("slide");
                //go_this.div_progressbar.toggle("clip");


                //go_this.taskId = get_random_number_int(1, 9999999999).toString();
                go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 500);
            }

            catch (e) {

                alert('error start_progress: ' + e.stack);

            }
        }



        //-----------------------------------------------------------------------------------
       ProgressBar.prototype.monitoring_server_progress = function () {

            try {

                let lv_url = go_this.url + "?method=" + Constants.method_read_progress_value
                    + "&client_id=" + go_this.client_id
                    + "&task_id=" + go_this.task_id;

                get_monitoring_server_progress(lv_url);

                //--------------------------------------------------
                async function get_monitoring_server_progress(pv_url) { 

                    try {
                        await $.get(pv_url, "", go_this.oncomplete_monitoring_server_progress);
                    }

                    catch (e) {

                        alert('error get_monitoring_server_progress: ' + e.stack);

                    }

                }

            }

            catch (e) {

                alert('error monitoring_server_progress: ' + e.stack);

            }
        }


        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.oncomplete_monitoring_server_progress = function (po_data) {

            try {

                let ls_progress_data = JSON.parse(po_data);

                if (ls_progress_data == null) {

                    go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 500);
                    return;
                }

                go_this.set_progress_value(ls_progress_data.progress_indicator);
                go_this.set_display_value(ls_progress_data.progress_indicator);


                //go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%");

                let lv_progress_indicator = parseInt(ls_progress_data.progress_indicator);

                //if (lv_progress_indicator < 50) {
                if (lv_progress_indicator < go_this.end_watching_progress_value) {

                    //go_this.progress_value = pv_progress_value;
                    //go_this.progressbar.progressbar("value", go_this.progress_value);
                    //go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%"); 

                    go_this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 500);
                }
                else {

                    go_this.stop_monitoring();

                    go_this.read_result_method(ls_progress_data);
                }

            }

            catch (e) {

                alert('error oncomplete_monitoring_server_progress: ' + e.stack);

            }

        }
        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.stop_progress = function () {
            try {

                go_this.clear_timers();
                //go_this.progressbar.visible = false;
                //go_this.div_progressbar.hide(1000);
                //go_this.div_progressbar.slideUp();
                go_this.div_progressbar.fadeOut();
                ///go_this.div_progressbar.toggle("slide");
                ///go_this.div_progressbar.toggle("clip");

            }

            catch (e) {

                alert('error stop_progress: ' + e.stack);

            }
        }

        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.stop_monitoring = function () {
            try {

                go_this.progress_value = 0;

                go_this.clear_timers();
            }

            catch (e) {

                alert('error stop_monitoring: ' + e.stack);

            }
        }
        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.do_progress = function () {

            try {
                //bvi var val = go_this.progressbar.progressbar("value") || 0;

                var lv_progress_value = go_this.get_progress_value();// bvi

                //go_this.progressbar.progressbar("value", val + Math.floor(Math.random() * 3));
                //14112024 go_this.progressbar.progressbar("value", lv_progress_value);

                go_this.progressbar.value = lv_progress_value;//14112024
                go_this.progressLabel.value = "Current Progress: " + lv_progress_value + "%";

                //let lv_str1 = lv_progress_value.toString();
                //let lv_str2 = (100 - lv_progress_value).toString();


                //let lo_table = "<table width=100%><tr><td>{2}%</td></tr>" +
                //    "<tr><td bgcolor=blue width='{0}%'>&nbsp;</td>" +
                //    "<td width='{1}%'></td></tr></table>";
                //let lo_table_str = "<table width=100%><tr><td>" + lv_str1 + "%</td></tr>" +
                //    "<tr><td bgcolor=blue width='" + lv_str1 + "%'>&nbsp;</td>" +
                //    "<td width='" + lv_str2 + "%'></td></tr></table>";




                //lo_table = String.format(lo_table, lv_progress_value, 100 - lv_progress_value, lv_progress_value);
                //$get("id_span_progress_").innerHTML = lo_table_str;
                /* $("#id_span_progress").innerHTML = lo_table_str;*/

                if (lv_progress_value >= 100) {

                    go_this.clear_timers();
                    //setTimeout(go_this.dialog.dialog("close"), 2000);//bvi

                }
                else {
                    //bvi if (lv_progress_value <= 99) {
                    //bvi go_this.progressTimer = setTimeout(go_this.do_progress, 50);

                    if (lv_progress_value < 50) {
                        this.monitoring_server_timer = setTimeout(go_this.monitoring_server_progress, 250); //bvi
                    }
                    else {

                        //go_this.progressTimer = setTimeout(go_this.do_progress, 250);
                        go_this.clear_timers();
                    }
                }

            }

            catch (e) {

                alert('error do_progress: ' + e.stack);

            }
        }

        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.set_display_value = function (pv_progress_value) {

            //go_this.progress_value = pv_progress_value;

            //setTimeout(
            //    function () {

            go_this.progressbar.value = pv_progress_value;//14112024
            go_this.progressLabel.text("Current Progress: " + pv_progress_value + "%");

            //}, 50


            //);

            ////    go_this.progressbar.value = pv_progress_value;//14112024
            ////    go_this.progressLabel.text("Current Progress: " + go_this.progress_value + "%");
        }

        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.set_progress_value = function (pv_progress_value) {

            this.progress_value = pv_progress_value;
        }
        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.get_progress_value = function () {

            return this.progress_value;
        }
        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.clear_timers = function () {

            clearTimeout(go_this.progressTimer);
            clearTimeout(go_this.monitoring_server_timer);// bvi
        }

        //-----------------------------------------------------------------------------------
        ProgressBar.prototype.closeDownload = function () {


            try {
                //function closeDownload() {
                ////clearTimeout(go_this.progressTimer);
                ////clearTimeout(go_this.monitoring_server_timer);// bvi
                go_this.clear_timers(); //bvi

                go_this.dialog
                    .dialog("option", "buttons", go_this.dialogButtons)
                    .dialog("close");
                //14112024 go_this.progressbar.progressbar("value", false);
                go_this.progressbar.value = false;//14112024


                go_this.progressLabel
                    .text("Starting download...");
                go_this.downloadButton.trigger("focus");
            }



            catch (e) {

                alert('error closeDownload: ' + e.stack);

            }

            //====================================================================
        }  // if (typeof this.redraw_shapes !== "function")


        //24112024 this.init_progress_bar();

        //go_this = this; //14112024



        //====================================================================
    }

    // end Class Shapes
    //=====================================================================

}

import * as THREE from 'three';
//import * as THREE from "https://unpkg.com/three@v0.149.0/build/three.module.js"
//import { THREE } from "https://unpkg.com/three@v0.149.0/build/three.module.js"

import { Line2 } from 'three/addons/lines/Line2.js';
//import { Line2 } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/Line2.js';

import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
//import { LineMaterial } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineMaterial.js';

import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
//import { LineGeometry } from 'https://unpkg.com/three@v0.149.0/examples/jsm/lines/LineGeometry.js';


import { Constants } from './my_common_const.js';

import { CommonFunc } from './my_common_func.js';


// Class Rectangle
export function Rectangle(/*po_container, po_camera,*/ po_scene,
	/*po_params*/ pv_shape_width, pv_shape_height

) {

    // Свойства
    //0511204 this.container = po_container;
    //0511204 this.camera = po_camera;
    this.scene = po_scene;

    ////this.shape_width = po_params.shape_width;
    ////this.shape_height = po_params.shape_height;
    this.shape_width = pv_shape_width;
    this.shape_height = pv_shape_height;

    this.shape;

    this.group_rect = null;

    this.cv_rectangle_name = "my_rectangle";

    //=====================================================================

    if (typeof this.create_rectangle != "function") {

        //----------------------------------------------------------
        // Методы
        //----------------------------------------------------------



        //////Rectangle.prototype.create_rectangle = function () {


        //////	try {


        //////	}

        //////	catch (e) {

        //////		alert('error create_rectangle: ' + e.stack);

        //////	}


        //////}


        //------------------------------------------------------------------------
        Rectangle.prototype.create_rectangle = function (/*pv_distance_bt_curves*//*pv_shape_width, pv_shape_height*/) {

            ////const cv_rect_width = this.shape_width; 
            ////const cv_rect_height = this.shape_height; 

            try {

                //let lo_group = new THREE.Group();

                const positions = [];
                positions.push(0, 0, 0);
                ////positions.push(0, cv_rect_height, 0);
                ////positions.push(cv_rect_width, cv_rect_height, 0);
                ////positions.push(cv_rect_width, 0, 0);
                ////positions.push(pv_shape_width, pv_shape_height, 0);
                ////positions.push(pv_shape_width, 0, 0);

                positions.push(0, this.shape_height, 0);
                positions.push(this.shape_width, this.shape_height, 0);
                positions.push(this.shape_width, 0, 0);
                positions.push(0, 0, 0);


                let lv_color = 0x0040f0;
                //let lv_x = 0; //13032024  pv_distance_bt_curves/2;// / 2; // 0;
                //let lv_y = 0;

                const clrs = [];

                let lo_rgb = CommonFunc.prototype.hexToRgb(Constants.color_shape_countour_str);


                positions.forEach(() => {
                    //clrs.push(255, 0, 255);
                    clrs.push(lo_rgb.r, lo_rgb.g, lo_rgb.b);

                });


                let geometry = new LineGeometry();

                geometry.setPositions(positions);/////

                geometry.setColors(clrs);

                ////let lo_resolution = new THREE.Vector2();
                ////let lo_renderer = new THREE.WebGLRenderer({ antialias: true });
                ////lo_renderer.getSize(lo_resolution);

                let material = new LineMaterial({
                    //color: new Color("#fff").getHex(),
                    vertexColors: true, //0xf0f, //VertexColors,
                    linewidth: Constants.line_width_shape_contour, // 7,// 30012025   0.5, //1, //2,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight), // Обязательно 30012025 lo_resolution,
                    //dashed: false, //true,
                    //gapSize: 0.75,
                    //dashScale: 1.5,
                    //dashSize: 1
                });

                material.needsUpdate = true;

                this.shape = new Line2(geometry, material);
                this.shape.computeLineDistances();
                ////lo_line.scale.set(1, 1, 1);

                this.shape.name = this.cv_rectangle_name;

                //30012025 this.shape.position.set(lv_x, lv_y);//, 0 pv_z - 25);

                ////lo_group.add(this.shape);
                ////this.group_rect = lo_group;
                ////this.scene.add(lo_group);

                this.scene.add(this.shape);
                //this.plane.add(this.shape);//31012025

            }

            catch (e) {

                alert('error create_rectangle: ' + e.stack);

            }

        }



        //-----------------------------------------------------------------


        //====================================================================
    }  // if (typeof this.create_rectangle !== "function")

    //====================================================================



    this.create_rectangle();


}

// end Class Rectangle
//=====================================================================
